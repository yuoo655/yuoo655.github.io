<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> ğŸš§ Welcome to my blog!</a></li><li class="chapter-item "><a href="new.html"><strong aria-hidden="true">2.</strong> ğŸš§ å­˜æ¡£</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="futures_in_rust/futrue.html"><strong aria-hidden="true">2.1.</strong> ğŸš§ Futures in Rust</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="futures_in_rust/2022-01-20.html"><strong aria-hidden="true">2.1.1.</strong> lambda calculus---&gt;closure</a></li><li class="chapter-item "><a href="futures_in_rust/2022-01-21.html"><strong aria-hidden="true">2.1.2.</strong> closure---&gt;generator</a></li><li class="chapter-item "><a href="futures_in_rust/2022-01-23.html"><strong aria-hidden="true">2.1.3.</strong> generator---&gt;future</a></li></ol></li><li class="chapter-item "><a href="os_camp_log.md.html"><strong aria-hidden="true">2.2.</strong> ğŸš§ 2021-os-camp</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="camp-daliy/7-6.html"><strong aria-hidden="true">2.2.1.</strong> 7.6 æŒ‡å®šç¨‹åºå†…å­˜å¸ƒå±€</a></li><li class="chapter-item "><a href="camp-daliy/7-7.html"><strong aria-hidden="true">2.2.2.</strong> 7.7 é“¾æ¥è„šæœ¬ç¼–å†™</a></li><li class="chapter-item "><a href="camp-daliy/7-8.html"><strong aria-hidden="true">2.2.3.</strong> 7.8 å®ç°å½©è‰²è¾“å‡º</a></li><li class="chapter-item "><a href="camp-daliy/7-9.html"><strong aria-hidden="true">2.2.4.</strong> 7.9 intelæ‰‹å†Œä¸­çš„å¤šæ ¸å¯åŠ¨</a></li><li class="chapter-item "><a href="camp-daliy/7-10.html"><strong aria-hidden="true">2.2.5.</strong> 7.10 å¤šæ ¸æ”¯æŒ</a></li><li class="chapter-item "><a href="camp-daliy/7-11.html"><strong aria-hidden="true">2.2.6.</strong> 7.11 ä¸­æ–­æœºåˆ¶æ¦‚å†µ</a></li><li class="chapter-item "><a href="camp-daliy/7-13.html"><strong aria-hidden="true">2.2.7.</strong> 7.13 ä¸­æ–­è¯¦ç»†å®ç°</a></li><li class="chapter-item "><a href="camp-daliy/7-14.html"><strong aria-hidden="true">2.2.8.</strong> 7.14 è¿è¡Œç”¨æˆ·ç¨‹åº</a></li><li class="chapter-item "><a href="camp-daliy/7-15.html"><strong aria-hidden="true">2.2.9.</strong> 7.15 è¿è¡Œç”¨æˆ·ç¨‹åºæ€»ç»“</a></li><li class="chapter-item "><a href="camp-daliy/7-16.html"><strong aria-hidden="true">2.2.10.</strong> 7.16 ç”¨æˆ·ç¨‹åºåˆ‡æ¢</a></li><li class="chapter-item "><a href="camp-daliy/7-17.html"><strong aria-hidden="true">2.2.11.</strong> 7.17 stride è°ƒåº¦ç®—æ³•</a></li><li class="chapter-item "><a href="camp-daliy/7-18.html"><strong aria-hidden="true">2.2.12.</strong> 7.18 ç‰©ç†å†…å­˜åˆ†é…</a></li><li class="chapter-item "><a href="camp-daliy/7-19.html"><strong aria-hidden="true">2.2.13.</strong> 7.19 é¡µè¡¨</a></li><li class="chapter-item "><a href="camp-daliy/7-20.html"><strong aria-hidden="true">2.2.14.</strong> 7.20 debug</a></li><li class="chapter-item "><a href="camp-daliy/7-21.html"><strong aria-hidden="true">2.2.15.</strong> 7.21</a></li><li class="chapter-item "><a href="camp-daliy/7-23.html"><strong aria-hidden="true">2.2.16.</strong> 7.23</a></li><li class="chapter-item "><a href="camp-daliy/7-24.html"><strong aria-hidden="true">2.2.17.</strong> 7.24 æ–‡ä»¶ç³»ç»Ÿ</a></li><li class="chapter-item "><a href="camp-daliy/7-25.html"><strong aria-hidden="true">2.2.18.</strong> 7.25</a></li><li class="chapter-item "><a href="camp-daliy/7-26.html"><strong aria-hidden="true">2.2.19.</strong> 7.26</a></li><li class="chapter-item "><a href="camp-daliy/7-27.html"><strong aria-hidden="true">2.2.20.</strong> 7.27</a></li></ol></li><li class="chapter-item "><a href="rust/2022-1-16.html"><strong aria-hidden="true">2.3.</strong> ğŸš§ rustç¬”è®°</a></li><li class="chapter-item "><a href="c2rust.html"><strong aria-hidden="true">2.4.</strong> ğŸš§c2rust</a></li><li class="chapter-item "><a href="foo.html"><strong aria-hidden="true">2.5.</strong> ğŸš§ dockerç¬”è®°</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-å­˜æ¡£"><a class="header" href="#-å­˜æ¡£">ğŸš§ å­˜æ¡£</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-futures-in-rust"><a class="header" href="#-futures-in-rust">ğŸš§ Futures in Rust</a></h1>
<h1 id="rustå¼‚æ­¥è¿è¡Œæ—¶è¯¦è§£"><a class="header" href="#rustå¼‚æ­¥è¿è¡Œæ—¶è¯¦è§£">rustå¼‚æ­¥è¿è¡Œæ—¶è¯¦è§£</a></h1>
<p>lambda calculus --&gt; closure --&gt; generator --&gt; future</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä»lambda-calculusåˆ°é—­åŒ…closure"><a class="header" href="#ä»lambda-calculusåˆ°é—­åŒ…closure">ä»lambda calculusåˆ°é—­åŒ…(closure)</a></h1>
<p>lambdaæ¼”ç®—æ˜¯Alonzo Churchåœ¨1935å¹´è®¾è®¡çš„è®¡ç®—æ¨¡å‹ï¼Œä¸Turingæ˜¯åŒæ—¶ä»£çš„ã€‚ä»–ä»¬æå‡ºäº†éå¸¸ä¸åŒçš„è®¡ç®—æ¨¡å‹ã€‚</p>
<p>Turingè¯æ˜äº†ä¸¤è€…åœ¨è®¡ç®—èƒ½åŠ›ä¸Šæ˜¯ç­‰æ•ˆçš„,å®ƒä»¬éƒ½å¯ä»¥æœ‰æ•ˆçš„æ¨¡ä»¿å¦ä¸€ä¸ª,æ˜¯ç­‰æ•ˆçš„è®¡ç®—æ¨¡å‹.</p>
<p>lambdaæ¼”ç®—éå¸¸ç‰¹åˆ«,å› ä¸ºå®ƒç”±ä»…ç”±å‡½æ•°å’Œè¿™äº›å‡½æ•°çš„å‚æ•°ç»„æˆçš„è¡¨è¾¾å¼ç»„æˆ</p>
<h2 id="lambdaæ¼”ç®—"><a class="header" href="#lambdaæ¼”ç®—">lambdaæ¼”ç®—</a></h2>
<blockquote>
<p>Î»x. y å®šä¹‰å‚æ•° x å¹¶è¿”å›å€¼ y çš„å‡½æ•°</p>
</blockquote>
<blockquote>
<p>(Î»x. x)  è¿™æ˜¯ä¸€ä¸ªæ’ç­‰å‡½æ•°. å…¶ä¸­Î»xè¡¨ç¤ºå‚æ•°, xè¡¨ç¤ºå‡½æ•°çš„è¿”å›å€¼<br />
((Î»x. x) 2) = 2</p>
</blockquote>
<blockquote>
<p>æœ‰ä¸¤ä¸ªå‚æ•°x ,yçš„æƒ…å†µ<br />
((Î»x. Î»y. x+y) 2 3) = 5</p>
</blockquote>
<blockquote>
<p>((Î»x. (x x)) (Î»x. (x x))) =  ((Î»x. (x x)) (Î»x. (x x))) = ((Î»x. (x x)) (Î»x. (x x)))   loop<br />
å¯ä»¥ä¼ å…¥å‡½æ•°ä½œä¸ºå‚æ•°. è¿™ä¸ªä¾‹å­ä¸­è¿”å›çš„å°†æ°¸è¿œæ˜¯å®ƒè‡ªå·±.</p>
</blockquote>
<h2 id="åŒ¿åå‡½æ•°"><a class="header" href="#åŒ¿åå‡½æ•°">åŒ¿åå‡½æ•°</a></h2>
<p>åŒ¿åå‡½æ•°åˆç§°lambdaå‡½æ•°, lambdaæŠ½è±¡, lambdaè¡¨è¾¾å¼,å»ºç«‹åœ¨lambdaæ¼”ç®—åŸºç¡€ä¸Š.</p>
<p>pythonä¸­lambdaå‡½æ•°ä¾‹å­:</p>
<pre><code class="language-python">&gt;&gt;&gt; foo = lambda x: x * x
&gt;&gt;&gt; foo(10)
100
</code></pre>
<p>rustä¸­çš„lambdaå‡½æ•°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let adder = |a, b| a + b;
<span class="boring">}
</span></code></pre></pre>
<h2 id="é—­åŒ…closure"><a class="header" href="#é—­åŒ…closure">é—­åŒ…(Closure)</a></h2>
<p>é—­åŒ…(Closure)ï¼Œå‡½æ•°é—­åŒ…(function closures)åˆç§°è¯æ³•é—­åŒ…(Lexical Closure)</p>
<h3 id="ä¸‹é¢æä¾›å¤šç§è§£é‡Šæ¥å¸®åŠ©ç†è§£é—­åŒ…"><a class="header" href="#ä¸‹é¢æä¾›å¤šç§è§£é‡Šæ¥å¸®åŠ©ç†è§£é—­åŒ…">ä¸‹é¢æä¾›å¤šç§è§£é‡Šæ¥å¸®åŠ©ç†è§£é—­åŒ…:</a></h3>
<p>åœ¨<a href="https://doc.rust-lang.org/book/ch13-01-closures.html">rust book</a>ä¸­é—­åŒ…å®šä¹‰: å¯ä»¥æ•è·ç¯å¢ƒçš„åŒ¿åå‡½æ•°</p>
<p>é—­åŒ…ä¹Ÿå¯ç§°ä¸ºå¼•ç”¨äº†è‡ªç”±å˜é‡çš„å‡½æ•°. è¿™ä¸ªè¢«å¼•ç”¨çš„è‡ªç”±å˜é‡å°†å’Œè¿™ä¸ªå‡½æ•°ä¸€åŒå­˜åœ¨ï¼Œå³ä½¿å·²ç»ç¦»å¼€äº†åˆ›é€ å®ƒçš„ç¯å¢ƒä¹Ÿä¸ä¾‹å¤–.</p>
<p>é—­åŒ…æ˜¯ç”±å‡½æ•°å’Œä¸å…¶ç›¸å…³çš„å¼•ç”¨ç¯å¢ƒç»„åˆè€Œæˆçš„å®ä½“</p>
<p>é—­åŒ…å°±æ˜¯ä¸€ä¸ªæ•è·äº†å½“å‰ä¸Šä¸‹æ–‡å˜é‡çš„ç»“æ„ä½“(å¤–åŠ ä¸€æ®µä»£ç  lambda function)</p>
<p>ç›´æ¥ç†è§£rustä¸­çš„é—­åŒ…æœ‰ç‚¹å›°éš¾,æˆ‘ä»¬å…ˆä»pythonçš„ä¾‹å­æ¥çœ‹</p>
<h3 id="pythonä¸­çš„é—­åŒ…"><a class="header" href="#pythonä¸­çš„é—­åŒ…">pythonä¸­çš„é—­åŒ…</a></h3>
<p><strong>ä¾‹ä¸€:</strong></p>
<blockquote>
<p>ä¸€ä¸ªå‡½æ•°å†…éƒ¨å®šä¹‰å¦ä¸€ä¸ªå‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å°±ç§°ä¸ºåµŒå¥—å‡½æ•°<br />
åœ¨displayå†…éƒ¨, å¯ä»¥é€šè¿‡å®ƒçš„å±€éƒ¨ä½œç”¨åŸŸè®¿é—®greeting<br />
Python å°†è¯¥greetingå˜é‡ç§°ä¸ºè‡ªç”±å˜é‡ã€‚<br />
å½“æ‚¨æŸ¥çœ‹displayå‡½æ•°æ—¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨æŸ¥çœ‹ï¼šdisplayå‡½æ•°æœ¬èº«ã€‚ä»¥åŠå€¼ä¸º'Hello'çš„è‡ªç”±å˜é‡greetingã€‚</p>
</blockquote>
<pre><code class="language-python">def say():
    greeting = 'Hello'

    def display():
        print(greeting)

    display()
</code></pre>
<p><strong>ä¾‹äºŒ:</strong></p>
<blockquote>
<p>say()å‡½æ•°è¿”å›display()å‡½æ•°,è€Œä¸æ˜¯æ‰§è¡Œå®ƒ<br />
å½“è¿”å›display()å‡½æ•°æ—¶,å®ƒä¹Ÿè¿”å›äº†é—­åŒ…</p>
</blockquote>
<pre><code class="language-python">def say():
    greeting = 'hello'

    def display():
        print(greeting)
    
    return display

fn = say()
fn()
</code></pre>
<blockquote>
<p><img src="futures_in_rust/./../img/closure_python.png" alt="avatar" /></p>
</blockquote>
<p><strong>è¾“å‡º:</strong></p>
<p><strong>hello</strong></p>
<p>æ—¢ç„¶å˜é‡greetingæ˜¯sayçš„å±€éƒ¨å˜é‡,å‡ºäº†å‡½æ•°ä½“åº”è¯¥æ˜¯ä¸èƒ½è®¿é—®greetingçš„, ä½†ä¾æ—§å¯ä»¥çœ‹åˆ°fn()è¾“å‡ºäº†hello</p>
<pre><code class="language-python">&gt;&gt;print(fn.__closure__)

(&lt;cell at 0x0000017184915C40: str object at 0x0000017186A829B0&gt;,)
</code></pre>
<p>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå•å…ƒçš„å†…å­˜åœ°å€æ˜¯0x0000017184915C40ã€‚å®ƒå¼•ç”¨äº†ä¸€ä¸ªå­—ç¬¦ä¸²å¯¹è±¡0x0000017186A829B0</p>
<p><strong>ä¾‹ä¸‰:</strong></p>
<blockquote>
<p>å¦‚æœåœ¨sayå‡½æ•° å’Œä¸­æ˜¾ç¤ºå­—ç¬¦ä¸²å¯¹è±¡çš„å†…å­˜åœ°å€closureï¼Œæ‚¨åº”è¯¥ä¼šçœ‹åˆ°å®ƒä»¬å¼•ç”¨äº†å†…å­˜ä¸­çš„åŒä¸€ä¸ªå¯¹è±¡ï¼š
è¿™æ—¶å¤šä¸ªä½œç”¨åŸŸå…±äº«åŒä¸€ä¸ªå˜é‡ï¼Œæ‰€ä»¥å¤–éƒ¨å‡½æ•°å’Œå†…éƒ¨å‡½æ•°ä½œç”¨åŸŸä¸­çš„å˜é‡greetingæ˜¯ç›¸åŒçš„</p>
</blockquote>
<pre><code class="language-python">def say():
    greeting = 'Hello'
    print(hex(id(greeting)))

    def display():
        print(hex(id(greeting)))
        print(greeting)

    return display


fn = say()
fn()
</code></pre>
<p><strong>è¾“å‡º:</strong></p>
<p><strong>0x17186a829b0</strong></p>
<p><strong>0x17186a829b0</strong></p>
<h4 id="å‚è€ƒa-hrefhttpswwwpythontutorialnetadvanced-pythonpython-closureshttpswwwpythontutorialnetadvanced-pythonpython-closuresa"><a class="header" href="#å‚è€ƒa-hrefhttpswwwpythontutorialnetadvanced-pythonpython-closureshttpswwwpythontutorialnetadvanced-pythonpython-closuresa">å‚è€ƒ:<a href="https://www.pythontutorial.net/advanced-python/python-closures/">https://www.pythontutorial.net/advanced-python/python-closures/</a></a></h4>
<h2 id="rustä¸­çš„é—­åŒ…"><a class="header" href="#rustä¸­çš„é—­åŒ…">rustä¸­çš„é—­åŒ…</a></h2>
<p>rustä¸­é—­åŒ…ç¨å¾®å¤æ‚ä¸€äº›, å› ä¸ºæ¶‰åŠåˆ°è·å–å‚æ•°çš„æ–¹å¼, åœ¨rustä¸­å‡½æ•°è·å–å‚æ•°çš„æ–¹å¼æœ‰ä¸‰ç§:è·å–æ‰€æœ‰æƒï¼Œå¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>é—­åŒ…æ˜¯<strong>å‡½æ•°æŒ‡é’ˆ(fn)å’Œç¯å¢ƒ</strong>çš„ç»„åˆ</p>
<p>é—­åŒ…<strong>ä¸æ•è·ä»»ä½•ç¯å¢ƒä¸­å˜é‡</strong>æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆã€‚</p>
<p>é—­åŒ…çš„æ–¹æ³•ç§»å‡ºäº†æ‰€æ•è·çš„å˜é‡çš„æ‰€æœ‰æƒï¼Œåˆ™ä¼šå®ç°<code>FnOnce(self)</code></p>
<p>é—­åŒ…çš„æ–¹æ³•<strong>æ²¡æœ‰</strong>ç§»å‡ºæ‰€æ•è·çš„å˜é‡çš„æ‰€æœ‰æƒï¼Œ<strong>å¹¶ä¸”å¯¹å˜é‡è¿›è¡Œäº†ä¿®æ”¹</strong>ï¼Œå³é€šè¿‡å¯å˜å€Ÿç”¨ä½¿ç”¨æ‰€æ•è·çš„å˜é‡ï¼Œåˆ™ä¼šå®ç°<code>FnMut(&amp;mut self)</code></p>
<p>é—­åŒ…çš„æ–¹æ³•<strong>æ²¡æœ‰</strong>ç§»å‡ºæ‰€æ•è·çš„å˜é‡çš„æ‰€æœ‰æƒï¼Œ<strong>å¹¶ä¸”æ²¡æœ‰å¯¹å˜é‡è¿›è¡Œä¿®æ”¹</strong>ï¼Œå³é€šè¿‡ä¸å¯å˜å€Ÿç”¨ä½¿ç”¨æ‰€æ•è·çš„å˜é‡ï¼Œåˆ™ä¼šå®ç°<code>Fn(&amp;self)</code></p>
<p>å¦‚æœä½ å¸Œæœ›å¼ºåˆ¶é—­åŒ…è·å–å…¶ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒï¼Œå¯ä»¥åœ¨å‚æ•°åˆ—è¡¨å‰ä½¿ç”¨ <code>move</code> å…³é”®å­—ã€‚è¿™ä¸ªæŠ€å·§åœ¨å°†é—­åŒ…ä¼ é€’ç»™æ–°çº¿ç¨‹ä»¥ä¾¿å°†æ•°æ®ç§»åŠ¨åˆ°æ–°çº¿ç¨‹ä¸­æ—¶æœ€ä¸ºå®ç”¨ã€‚</p>
<blockquote>
<p><img src="futures_in_rust/./../img/rust-closure2.jpg" alt="avatar" /></p>
</blockquote>
<h3 id="ä¾‹"><a class="header" href="#ä¾‹">ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(unboxed_closures, fn_traits)]
<span class="boring">fn main() {
</span>//å®šä¹‰é—­åŒ…ç»“æ„ä½“
struct Say {
    //æ•è·çš„ç¯å¢ƒå˜é‡
    s: String,
}

//å®ç°FnOnceæ–¹æ³•
impl FnOnce&lt;()&gt; for Say {
    type  Output = ();
    extern &quot;rust-call&quot;  fn call_once(self, args: ()) -&gt; () {
        println!(&quot;{}&quot;, self.s);
    }
}

//å®ç°FnMutæ–¹æ³•
impl FnMut&lt;()&gt; for Say {
    extern &quot;rust-call&quot;  fn call_mut(&amp;mut self, args: ()) -&gt; () {
        self.s.push_str(&quot; world!&quot;);
        println!(&quot;{}&quot;, self.s);
    }
}

//å®ç°Fnæ–¹æ³•
impl Fn&lt;()&gt; for Say {
    extern &quot;rust-call&quot; fn call(&amp;self, args: ()) -&gt; () {
        println!(&quot;{}&quot;, self.s);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut greeting = &quot;hello&quot;.to_string();
    //é—­åŒ…sayæ•è·ç¯å¢ƒå˜é‡greeting
    let mut say = Say { s: greeting};
    
    //ä¸ä¿®æ”¹ç¯å¢ƒå˜é‡ ä¸æ•è·æ‰€æœ‰æƒ
    say.call(());
    //ä¿®æ”¹ç¯å¢ƒå˜é‡, ä¸æ•è·æ‰€æœ‰æƒ
    say.call_mut(());
    //ç§»é™¤æ‰€æœ‰æƒ
    say.call_once(());
    //ä¹‹åå†è°ƒç”¨call call_mut call_onceå°±ä¼šæŠ¥é”™
}
</code></pre></pre>
<h3 id="åœ¨äº†è§£äº†rusté—­åŒ…å†…éƒ¨å®ç°ä¹‹åå†çœ‹ä¸€äº›ä¾‹å­"><a class="header" href="#åœ¨äº†è§£äº†rusté—­åŒ…å†…éƒ¨å®ç°ä¹‹åå†çœ‹ä¸€äº›ä¾‹å­">åœ¨äº†è§£äº†rusté—­åŒ…å†…éƒ¨å®ç°ä¹‹å,å†çœ‹ä¸€äº›ä¾‹å­</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//å®ç°äº†call. ä¸ä¿®æ”¹ç¯å¢ƒå˜é‡,ä¸æ•è·æ‰€æœ‰æƒ,å¯å¤šæ¬¡è°ƒç”¨say,ä½†ä¸èƒ½ä¿®æ”¹greeting
let greeting = &quot;hello&quot;;
let say = || {
    println!(&quot;{}&quot;, greeting);
};
say();

//å®ç°äº†call_mut,ä¿®æ”¹ç¯å¢ƒå˜é‡,ä¸æ•è·æ‰€æœ‰æƒ,å¯å¤šæ¬¡è°ƒç”¨say,å¯ä¿®æ”¹greeting
let mut greeting = &quot;hello&quot;.to_string();
let mut say = || {
    greeting.push_str(&quot; world&quot;);
    println!(&quot;{}&quot;, greeting);
};
say();


//å®ç°äº†call_once,ä¿®æ”¹ç¯å¢ƒå˜é‡(ä¹Ÿå¯ä»¥ä¸ä¿®æ”¹),æ•è·æ‰€æœ‰æƒ,åªèƒ½è°ƒç”¨ä¸€æ¬¡say
let mut greeting = &quot;hello&quot;.to_string();
let mut say = move || {
    greeting.push_str(&quot; world&quot;);
    println!(&quot;{}&quot;, greeting);
};
say();
<span class="boring">}
</span></code></pre></pre>
<p>å›¾ç‰‡æ¥æºäº<a href="https://zhuanlan.zhihu.com/p/341815515">Rustä¸­çš„é—­åŒ…ä¸å…³é”®å­—move</a></p>
<h3 id="å‚è€ƒ"><a class="header" href="#å‚è€ƒ">å‚è€ƒ</a></h3>
<p><a href="https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759">Understanding Closures in Rust.</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/341815515">Rustä¸­çš„é—­åŒ…ä¸å…³é”®å­—move</a></p>
<p><a href="https://time.geekbang.org/course/detail/100060601-294649">rustè¯­è¨€åŸºç¡€(å¼ æ±‰ä¸œ)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é—­åŒ…åˆ°ç”Ÿæˆå™¨"><a class="header" href="#é—­åŒ…åˆ°ç”Ÿæˆå™¨">é—­åŒ…åˆ°ç”Ÿæˆå™¨</a></h1>
<h2 id="ç”Ÿæˆå™¨"><a class="header" href="#ç”Ÿæˆå™¨">ç”Ÿæˆå™¨</a></h2>
<p><strong>ä¸€ä¸ªç®€å•çš„ç”Ÿæˆå™¨</strong></p>
<blockquote>
<p>ä¸‹é¢genæ˜¯ä¸€ä¸ªç”Ÿæˆå™¨. å¯ä»¥çœ‹å¤„å®ƒæ˜¯ä½¿ç”¨é—­åŒ…çš„è¯­æ³•å£°æ˜çš„. 
ä¸é—­åŒ…ä¸åŒçš„æ˜¯. å®ƒå¤šäº†ä¸€ä¸ªyieldå…³é”®å­—, å®ƒå¯ä»¥é€šè¿‡resume()æ–¹æ³•å¤šæ¬¡æ¢å¤.<br />
æ¯æ¬¡resume()è°ƒç”¨æ—¶,é—­åŒ…å†…çš„ä»£ç éƒ½ä¼šè¿è¡Œ, ç›´åˆ°é‡åˆ°yield<br />
resumeè¿”å› yieldçš„å€¼</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#![feature(generators, generator_trait)]
use std::ops::Generator;
use std::pin::Pin;

fn main() {
    // ç”¨é—­åŒ…åˆ›å»ºä¸€ä¸ªç”Ÿæˆå™¨
    let mut gen = || {
        yield 1;
        yield 2;
        yield 3;
        yield 4;
        return 5;
    };

    //ä¸æ–­è°ƒç”¨resumeæ‰§è¡Œ
    for _ in 0..5 {
        let c = Pin::new(&amp;mut gen).resume(());
        println!(&quot;{:?}&quot;, c);
    }

}
</code></pre></pre>
<blockquote>
<p>å‰4ä¸ªè°ƒç”¨resume()å°†è¿”å›GeneratorState::Yielded(x)ï¼Œç„¶åè¿”å›GeneratorState::Complete(x).</p>
</blockquote>
<p><strong>è¾“å‡º</strong></p>
<p>Yielded(1)</p>
<p>Yielded(2) </p>
<p>Yielded(3) </p>
<p>Yielded(4) </p>
<p>Complete(5)</p>
<blockquote>
<p>resume()çœŸæ­£è¿”å›çš„æ˜¯GeneratorState   ,å®šä¹‰å¦‚ä¸‹</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GeneratorState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>æ¥ä¸‹æ¥çœ‹çœ‹ç”Ÿæˆå™¨çš„èƒŒåå…·ä½“åšäº†ä»€ä¹ˆ,ä»¥åŠå®ƒå’Œæˆ‘ä»¬ä¹‹å‰å°†çš„é—­åŒ…çš„å…³ç³»</strong></p>
<p><strong>è¿™æ˜¯ä¸Šé¢ä¾‹å­çš„ç­‰æ•ˆä»£ç </strong></p>
<pre><pre class="playground"><code class="language-rust">use std::pin::Pin;

#[derive(Debug)]
pub enum GeneratorState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}

pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(self: Pin&lt;&amp;mut Self&gt;) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}

//å’Œä¸Šä¸€ç« ä¸­å®šä¹‰çš„é—­åŒ…ç»“æ„ä½“ç±»ä¼¼,åŒ…å«æ•è·çš„ç¯å¢ƒ
struct MyGen {
    i: i32,
}

//ä¸ºMyGenå®ç°Generator trait
impl Generator for MyGen {
    type Yield = i32;
    type Return = i32;
    fn resume(mut self : Pin&lt;&amp;mut Self&gt;) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        self.i += 1;
        if self.i == 5 {
            GeneratorState::Complete(self.i)
        } else {
            GeneratorState::Yielded(self.i)
        }
    }
}

fn main() {
    let mut gen = MyGen { i: 0 };    
    for _ in 0..5 {
        let c = Pin::new(&amp;mut gen).resume();
        println!(&quot;{:?}&quot;, c);
    }
}
</code></pre></pre>
<p><strong>å†çœ‹é—­åŒ…å†…éƒ¨çš„å®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

impl FnOnce&lt;()&gt; for Say {
    type  Output = ();
    extern &quot;rust-call&quot;  fn call_once(self, args: ()) -&gt; () {
        foo();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>å¯è§æ¯æ¬¡ç”Ÿæˆå™¨æ‰§è¡Œresume,ç›¸å½“äºé—­åŒ…æ‰§è¡Œäº†ä¸€æ¬¡call_once(call, call_mut)</p>
<p>ä¸é—­åŒ…ä¸åŒçš„æ˜¯,æ¯æ¬¡resume,ç”Ÿæˆå™¨éƒ½å°†æ‰§è¡Œåˆ°ç»“æœä¸ºGeneratorState::Yielded()å¤„, ç¼–è¯‘å™¨å°†ç”Ÿæˆå™¨ç¼–è¯‘æˆçŠ¶æ€æœºã€‚æ¯å¤„yieldå‡ºå¯¹åº”ä¸€ä¸ªä¸åŒçš„çŠ¶æ€.</p>
<p><strong>å‚è€ƒ</strong></p>
<p><a href="https://cfsamson.github.io/books-futures-explained/introduction.html">Futures Explained in 200 Lines of Rust</a></p>
<p><a href="https://time.geekbang.org/course/detail/100060601-294649">rustè¯­è¨€åŸºç¡€(å¼ æ±‰ä¸œ)</a></p>
<p><a href="https://github.com/rust-lang/rust/issues/43122">Experimentally add coroutines to Rust #43122</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generator---future"><a class="header" href="#generator---future">generator---&gt;future</a></h1>
<h2 id="futureçš„å®šä¹‰"><a class="header" href="#futureçš„å®šä¹‰">Futureçš„å®šä¹‰</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¯è§ä¸ç”Ÿæˆå™¨çš„åŒºåˆ«æ˜¯:</strong></p>
<p>ç”Ÿæˆå™¨ä½¿ç”¨resumeæ¥æ‰§è¡Œè¿›å…¥ä¸‹ä¸€ä¸ªçŠ¶æ€, Futureä½¿ç”¨poll.</p>
<p>ç”Ÿæˆå™¨è¿”å›Yieldedæˆ–è€…Complete, Futureè¿”å›Pendingæˆ–è€…Ready.</p>
<p>Futureä¸­æœ‰Context, waker</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-2021-os-camp"><a class="header" href="#-2021-os-camp">ğŸš§ 2021-os-camp</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="76"><a class="header" href="#76">7.6</a></h1>
<p><strong>å¼€å§‹tutorial!</strong></p>
<p><strong>ä½¿ç”¨é“¾æ¥è„šæœ¬æŒ‡å®šç¨‹åºå†…å­˜å¸ƒå±€</strong></p>
<p>ä¸€èˆ¬æ¥è¯´ï¼Œä¸€ä¸ªç¨‹åºæŒ‰ç…§åŠŸèƒ½ä¸åŒä¼šåˆ†ä¸ºä¸‹é¢è¿™äº›æ®µï¼š</p>
<table><tr><td bgcolor=#EFF5FF>
.text æ®µï¼Œå³ä»£ç æ®µï¼Œå­˜æ”¾ä»£ç  å‡ºé”™æ—¶å€™çš„eipå¾€å¾€åœ¨è¿™ä¸ªæ®µ.æŒ‡å‘æŸä¸€æ¡è¯­å¥.ä»¥æ­¤æ¥å®šä½é—®é¢˜ï¼›
<p>.rodata æ®µï¼Œå³åªè¯»æ•°æ®æ®µï¼Œé¡¾åæ€ä¹‰é‡Œé¢å­˜æ”¾åªè¯»æ•°æ®ï¼Œé€šå¸¸æ˜¯ç¨‹åºä¸­çš„å¸¸é‡ï¼›</p>
<p>.data æ®µï¼Œå­˜æ”¾è¢«åˆå§‹åŒ–çš„å¯è¯»å†™æ•°æ®ï¼Œé€šå¸¸ä¿å­˜ç¨‹åºä¸­çš„å…¨å±€å˜é‡ï¼›</p>
<p>.bss æ®µï¼Œå­˜æ”¾è¢«åˆå§‹åŒ–ä¸º 00 çš„å¯è¯»å†™æ•°æ®ï¼Œä¸ .data æ®µçš„ä¸åŒä¹‹å¤„åœ¨äºæˆ‘ä»¬çŸ¥é“å®ƒè¦è¢«åˆå§‹åŒ–ä¸º 00 ï¼Œå› æ­¤åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­åªéœ€è®°å½•è¿™ä¸ªæ®µçš„å¤§å°ä»¥åŠæ‰€åœ¨ä½ç½®å³å¯ï¼Œè€Œä¸ç”¨è®°å½•é‡Œé¢çš„æ•°æ®ã€‚</p>
<p>stack ï¼Œå³æ ˆï¼Œç”¨æ¥å­˜å‚¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­çš„å±€éƒ¨å˜é‡ï¼Œä»¥åŠè´Ÿè´£å‡½æ•°è°ƒç”¨æ—¶çš„å„ç§æœºåˆ¶ã€‚å®ƒä»é«˜åœ°å€å‘ä½åœ°å€å¢é•¿ï¼›</p>
<p>heap ï¼Œå³å †ï¼Œç”¨æ¥æ”¯æŒç¨‹åº<b><font color=#42ACF4>è¿è¡Œè¿‡ç¨‹</font></b>ä¸­å†…å­˜çš„åŠ¨æ€åˆ†é…ï¼Œæ¯”å¦‚è¯´ä½ è¦è¯»è¿›æ¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåœ¨ä½ å†™ç¨‹åºçš„æ—¶å€™ä½ ä¹Ÿä¸çŸ¥é“å®ƒçš„é•¿åº¦ç©¶ç«Ÿä¸ºå¤šå°‘ï¼Œäºæ˜¯ä½ åªèƒ½åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼ŒçŸ¥é“äº†å­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹åï¼Œå†åœ¨å †ä¸­ç»™è¿™ä¸ªå­—ç¬¦ä¸²åˆ†é…å†…å­˜ã€‚</p>
</td></tr></table>
<p>é“¾æ¥è„šæœ¬ç¤ºä¾‹:</p>
<pre><code class="language-linker">
SECTIONS
{
. = 0x10000;
.text : { *(.text) }
. = 0x8000000;
.data : { *(.data) }
.bss : { *(.bss) }
}
</code></pre>
<p><b></b>
. è¡¨ç¤ºèµ·å§‹åœ°å€ å¦‚æœæ²¡æœ‰è¿™ä¸ªåœ°å€ï¼Œé»˜è®¤è¯¥ç¬¦å·çš„å€¼ä¸º0</p>
<p>.text : { *(.text) } : å°†æ‰€æœ‰(*ç¬¦å·ä»£è¡¨ä»»æ„è¾“å…¥æ–‡ä»¶)æ–‡ä»¶çš„.text sectionåˆå¹¶æˆä¸€ä¸ª.text section,è¯¥sectionçš„åœ°å€ç”±å®šä½å™¨ç¬¦å·çš„å€¼æŒ‡å®š, å³0x10000.</p>
<p>. = 0x8000000 ï¼šæŠŠå®šä½å™¨ç¬¦å·ç½®ä¸º0x8000000</p>
<p>.data : { *(.data) } : åŒä¸Š</p>
<p>.bss : { *(.bss) } :  åŒä¸Š</p>
<p><strong>å…¶ä»–å‘½ä»¤</strong>
ENTRY(SYMBOL) :å°†ç¬¦å·SYMBOLçš„å€¼è®¾ç½®æˆå…¥å£åœ°å€ã€‚</p>
<p>INCLUDE filename : åŒ…å«å…¶ä»–åä¸ºfilenameçš„é“¾æ¥è„šæœ¬</p>
<p>INPUT(files): å°†æ‹¬å·å†…çš„æ–‡ä»¶åšä¸ºé“¾æ¥è¿‡ç¨‹çš„è¾“å…¥æ–‡ä»¶</p>
<p>GROUP(files) : æŒ‡å®šéœ€è¦é‡å¤æœç´¢ç¬¦å·å®šä¹‰çš„å¤šä¸ªè¾“å…¥æ–‡ä»¶</p>
<p>OUTPUT(FILENAME) : å®šä¹‰è¾“å‡ºæ–‡ä»¶çš„åå­—</p>
<p>SEARCH_DIR(PATH) ï¼šå®šä¹‰æœç´¢è·¯å¾„ï¼Œ</p>
<p>OUTPUT_ARCH() : è®¾ç½®è¾“å‡ºæ–‡ä»¶çš„ä½“ç³»ç»“æ„</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>pythonç”Ÿæˆé“¾æ¥è„šæœ¬,ä»¥åŠç”¨æˆ·ç¨‹åºbuild</strong></p>
<p>å¤šä¸ªç”¨æˆ·ç¨‹åºbuild</p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()
for app in apps:
    app = app[:app.find('.')]
    lines = []
    lines_before = []
    with open(linker, 'r') as f:
        for line in f.readlines():
            lines_before.append(line)
            line = line.replace(hex(base_address), hex(base_address+step*app_id))
            lines.append(line)
    with open(linker, 'w+') as f:
        f.writelines(lines)
    os.system('cargo build --bin %s --release' % app)
    print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
    with open(linker, 'w+') as f:
        f.writelines(lines_before)
    app_id = app_id + 1

</code></pre>
<p><strong>ç”Ÿæˆbinæ–‡ä»¶...objcopy</strong></p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()

for app in apps:
    app = app.strip('.rs')
    os.system('rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/%s --strip-all -O binary  target/riscv64gc-unknown-none-elf/release/%s.bin'%(app,app))
</code></pre>
<p><strong>ç”Ÿæˆé“¾æ¥è„šæœ¬link_app.S  ç›®å½•ä¸‹æ‰€æœ‰binæ–‡ä»¶å†™è¿›é“¾æ¥è„šæœ¬</strong></p>
<pre><code class="language-python">import os


f = open('link_app.S', 'w')

f.writelines(&quot;    .align 3\n&quot;)
f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global _num_app\n&quot;)
f.writelines(&quot;_num_app:\n&quot;)
apps = os.listdir('target/riscv64gc-unknown-none-elf/release')
num = 0

bin_list = []
for app in apps:
    if 'bin' in app:
        num += 1
        bin_list.append(app)

f.writelines(&quot;    .quad %s\n&quot; %len(bin_list))

count  = 0
for app in bin_list:
    f.writelines(&quot;    .quad app_%s_start\n&quot; %count)
    count += 1

f.writelines(&quot;\n&quot;)

f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global app_0_start\n&quot;)
f.writelines(&quot;    .global app_0_end\n&quot;)

for i in range(len(bin_list)):
    f.writelines(&quot;app_%s_start:\n&quot; %i)
    f.writelines(&quot;    .incbin \&quot;../test/target/riscv64gc-unknown-none-elf/release/%s\&quot;\n&quot; %bin_list[i])
    f.writelines(&quot;app_%s_end:\n\n&quot; %i)
    
f.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å½©è‰²è¾“å‡º</strong></p>
<p>ç”¨printå®åŒ…è£… info debug error. åŠ ç‚¹å‚æ•°å°±èƒ½æ˜¾ç¤ºå‡ºä¸åŒé¢œè‰²</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! print {
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print(format_args!($($arg)*));
    });
}

#[macro_export]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;{}\n&quot;, format_args!($($arg)*)));
}


#[macro_export]
macro_rules! info {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[31m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}

#[macro_export]
macro_rules! debug {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[32m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}

#[macro_export]
macro_rules! error {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[34m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ"><a class="header" href="#æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ">æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ</a></h1>
<p>åœ¨intelæ‰‹å†Œ8.4 MULTIPLE-PROCESSOR (MP) INITIALIZATION å¯æŸ¥åˆ°å¤šæ ¸å¯åŠ¨ç›¸å…³ä¿¡æ¯.</p>
<font size = 3> 
8.4.1 BSP and AP Processors
The MP initialization protocol defines two classes of processors: the bootstrap processor (BSP) and the application
processors (APs). Following a power-up or RESET of an MP system, system hardware dynamically selects one of the
processors on the system bus as the BSP. The remaining processors are designated as APs.
As part of the BSP selection mechanism, the BSP flag is set in the IA32_APIC_BASE MSR (see Figure 10-5) of the
BSP, indicating that it is the BSP. This flag is cleared for all other processors.
The BSP executes the BIOSâ€™s boot-strap code to configure the APIC environment, sets up system-wide data structures, and starts and initializes the APs. When the BSP and APs are initialized, the BSP then begins executing the
operating-system initialization code.
</font>
<br></br>
<font size = 3> 
Following a power-up or reset, the APs complete a minimal self-configuration, then wait for a startup signal (a SIPI
message) from the BSP processor. Upon receiving a SIPI message, an AP executes the BIOS AP configuration code,
which ends with the AP being placed in halt state.
For Intel 64 and IA-32 processors supporting Intel Hyper-Threading Technology, the MP initialization protocol treats
each of the logical processors on the system bus or coherent link domain as a separate processor (with a unique
APIC ID). During boot-up, one of the logical processors is selected as the BSP and the remainder of the logical
processors are designated as APs.
</font>
<p>åœ¨å¯åŠ¨æ—¶å€™.ä¼šé€‰å‡ºä¸€ä¸ªæ ¸ä½œä¸ºBSP. åŒæ—¶è®¾ç½®å…¶ä»–æ ¸(APs)çš„flagä¿¡æ¯.ç„¶åç”±BSPæ¥æ‰§è¡Œåˆå§‹åŒ–å…¶ä»–æ ¸(APs). å½“BSPå’ŒAPséƒ½åˆå§‹åŒ–å®Œæˆå,ç”±BSPæ¥æ‰§è¡Œç³»ç»Ÿåˆå§‹åŒ–ä»£ç </p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å­¦ä¹ å¤šæ ¸å¯åŠ¨æ”¯æŒ</strong></p>
<p><strong>å‚è€ƒå·²æœ‰çš„å®ç°</strong></p>
<p>ä¸»è¦çœ‹é“¾æ¥è„šæœ¬ä¸­æŒ‡å®šçš„å…¥å£æ±‡ç¼–ä»£ç ,ä»¥åŠæ¥ä¸‹æ¥è·³è½¬åˆ°çš„ä»£ç </p>
<p>1.rcore</p>
<pre><code class="language-x86asm">    .section .text.entry
    .globl _start
_start:
    # a0 == hartid
    # pc == 0x80200000
    # sp == 0x800xxxxx

    # 1. set sp
    # sp = bootstack + (hartid + 1) * 0x10000
    add     t0, a0, 1
    slli    t0, t0, 14
    lui     sp, %hi(bootstack)
    add     sp, sp, t0

....(ç•¥)

    # 3. jump to rust_main (absolute address)
    lui     t0, %hi(rust_main)
    addi    t0, t0, %lo(rust_main)
    jr      t0

    .section .bss.stack
    .align 12   # page align
    .global bootstack
bootstack:
    .space 4096 * 4 * 8
    .global bootstacktop
bootstacktop:

    .section .data
    .align 12   # page align
....(ç•¥)
</code></pre>
<p><strong>åŠ è½½å¸¸é‡åˆ°æŸå¯„å­˜å™¨å¸¸ç”¨çš„æ±‡ç¼–ä»£ç </strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(constant)
addi    t0, t0, %lo(constant)
</code></pre>
<p><strong>åŠ è½½ç»å¯¹åœ°å€åˆ°æŸå¯„å­˜å™¨</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(address)
addi    t0, t0, %lo(address)
</code></pre>
<p><strong>æœ‰äº†è¿™ä¸ªåŸºç¡€è¿™æ®µä»£ç å°±å¥½ç†è§£äº†</strong>
ä¸ºå½“å‰æ ¸å¿ƒè®¾ç½®ä¸€ä¸ªæ ˆ,åœ°å€ä¸º:sp = bootstack + (hartid + 1) * 0x10000
å†è·³è½¬åˆ°rust_main....</p>
<p><strong>next:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn rust_main(hartid: usize, device_tree_paddr: usize) -&gt; ! {
    let device_tree_vaddr = phys_to_virt(device_tree_paddr);

    unsafe {
        cpu::set_cpu_id(hartid);
    }

    if hartid != BOOT_HART_ID {
        while !AP_CAN_INIT.load(Ordering::Relaxed) {}
        others_main(hartid);
    }

    unsafe {
        memory::clear_bss();
    }

    println!(
        &quot;Hello RISCV! in hart {}, device tree @ {:#x}&quot;,
        hartid, device_tree_vaddr
    );

    crate::logging::init();
    unsafe {
        trapframe::init();
    }
    memory::init(device_tree_vaddr);
    timer::init();
    // FIXME: init driver on u540
    #[cfg(not(any(feature = &quot;board_u540&quot;)))]
    board::init(device_tree_vaddr);
    unsafe {
        board::init_external_interrupt();
    }
    crate::process::init();

    AP_CAN_INIT.store(true, Ordering::Relaxed);
    crate::kmain();
}

fn others_main(hartid: usize) -&gt; ! {
    unsafe {
        trapframe::init();
    }
    memory::init_other();
    timer::init();
    info!(&quot;Hello RISCV! in hart {}&quot;, hartid);
    crate::kmain();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>rust_mainçš„å¤šæ ¸å¤„ç†</strong></p>
<p>1.è®¾ç½®thread_pointerä¸ºhartid</p>
<p>2.é¦–å…ˆè®©hartid = BOOT_HART_IDæ‰§è¡Œå®Œrust_main,åŒæ—¶å¦‚æœå…¶ä»–hartè¿›å…¥åˆ°æ­¤å‡½æ•°åˆ™å¾ªç¯ç­‰å¾….ç›´åˆ°BST(boot_hart)æ‰§è¡Œå¯åŠ¨ä»£ç ,å¹¶è®¾ç½®åŸå­æ“ä½œæ“ä½œAP_CAN_INIT.store(true, Ordering::Relaxed)å,å†æ‰§è¡Œå…¶ä»–hartçš„åˆå§‹åŒ–æ“ä½œ.</p>
<p>è¿™é‡Œç”¨åˆ°äº†rustä¸­çš„atomicåŸºæœ¬ç”¨æ³•å¦‚ä¸‹:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicBool, Ordering};
let some_bool = AtomicBool::new(true);
some_bool.store(false, Ordering::Relaxed);
assert_eq!(some_bool.load(Ordering::Relaxed), false);
<span class="boring">}
</span></code></pre></pre>
<table><td bgcolor=#EFF5FF>
ç”³è¯·ä¸€ä¸ªåŸå­å‹boolå˜é‡åˆå§‹åŒ–ä¸ºtrue. AtomicBool::new(true)
<p>load(Ordering::Relaxed)æ¥è·å¾—å˜é‡å€¼</p>
<p>store(false, Ordering::Relaxed)æ¥æ”¹å˜å€¼</p>
</td></table>
<p><strong>å¤šæ ¸å¯åŠ¨æ¦‚æ‹¬</strong></p>
<p>1.è®©ä¸»æ ¸(BST)æ‰§è¡Œå®Œå¯åŠ¨ä»£ç .åŒæ—¶è®¾ç½®åŸå­æ“ä½œè®©å…¶ä»–æ ¸ç­‰å¾….ç„¶åæ‰§è¡Œå…¶ä»–æ ¸(AP)çš„å¯åŠ¨ä»£ç .</p>
<p>2.ä¸ºæ¯ä¸ªæ ¸è®¾ç½®å¥½æ ˆ</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å®ç°ä¸­æ–­æœºåˆ¶</strong></p>
<p>å†…æ ¸æ ˆ:å›ºå®šå¤§å°,æ¯ä¸ªè¿›ç¨‹,çº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªå†…æ ¸æ ˆ.å†…æ ¸æ ˆæ˜¯è¿›ç¨‹,çº¿ç¨‹åœ¨å†…æ ¸æ€ä¸‹æ‰€ä½¿ç”¨çš„æ ˆ.åœ¨ç”¨æˆ·æ€ä¸‹cpuçš„spæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ç”¨æˆ·æ ˆçš„æ ˆé¡¶.å†…æ ¸æ€ä¸‹æŒ‡å®šå†…æ ¸æ ˆçš„æ ˆé¡¶.</p>
<p><strong>ä¸­æ–­å®ç°æ€è·¯</strong></p>
<table><tr><td bgcolor=#EFF5FF>
1.åŒºåˆ†æ˜¯ä»ç”¨æˆ·æ€è¿˜æ˜¯å†…æ ¸æ€ä¸­æ–­, ä¿å­˜32ä¸ªé€šç”¨å¯„å­˜å™¨ä»¥åŠä¸€äº›æ§åˆ¶ä¸çŠ¶æ€å¯„å­˜å™¨csr.ç„¶åè·³è½¬åˆ°ä¸­æ–­å¤„ç†å‡½æ•°  æ­¤éƒ¨åˆ†ç”¨æ±‡ç¼–è¯­è¨€å†™
<p>2.è¿›å…¥ä¸­æ–­å¤„ç†å‡½æ•°,printä¸­æ–­æ¥æº(ç”¨æˆ·æ€orå†…æ ¸æ€) å½“å‰ä¸­æ–­æŒ‡ä»¤(pc) ä¸­æ–­åŸå› (è¯»å–scauseå¯„å­˜å™¨)
# å¦‚æœä»å†…æ ¸æ€è¿›å…¥ä¸­æ–­ï¼Œ sstatus çš„ SPP ä½è¢«ç¡¬ä»¶è®¾ä¸º 1
# å¦‚æœä»ç”¨æˆ·æ€è¿›å…¥ä¸­æ–­ï¼Œ sstatus çš„ SPP ä½è¢«ç¡¬ä»¶è®¾ä¸º 0</p>
<p>3.æ¢å¤ä¸Šä¸‹æ–‡. æ¢å¤32ä¸ªé€šç”¨å¯„å­˜å™¨,ä»¥åŠä¸€äº›csrå¯„å­˜å™¨.</p>
</td></tr></table>
<p>æŒ‰ç…§ TrapContext ç»“æ„ä½“çš„å†…å­˜å¸ƒå±€ï¼Œå®ƒä»ä½åœ°å€åˆ°é«˜åœ°å€åˆ†åˆ«æŒ‰é¡ºåºæ”¾ç½® x0~x31ï¼Œæœ€åæ˜¯ sstatus å’Œ sepc ã€‚å› æ­¤é€šç”¨å¯„å­˜å™¨ xn åº”è¯¥è¢«ä¿å­˜åœ¨åœ°å€åŒºé—´ [sp+8n,sp+8(n+1)) ã€‚ åœ¨è¿™é‡Œæˆ‘ä»¬æ­£æ˜¯è¿™æ ·åŸºäº sp æ¥ä¿å­˜è¿™äº›é€šç”¨å¯„å­˜å™¨çš„ã€‚
(ä¸»è¦ä¿å­˜trapframeä¸­å†…å®¹)ä¿å­˜32ä¸ªé€šç”¨å¯„å­˜å™¨ä»¥åŠä¸€äº›æ§åˆ¶ä¸çŠ¶æ€å¯„å­˜å™¨csr æ­¤éƒ¨åˆ†ä¸trapframeç»“æ„ä½“ä¸€è‡´. æ¢å¤æ—¶åªè¦æŠŠç»“æ„ä½“æŒ‡é’ˆæŒ‡å‘spå°±èƒ½æ¢å¤trapframe</p>
<p>csrrw rd, csr, rs å¯ä»¥å°† CSR å½“å‰çš„å€¼è¯»åˆ°é€šç”¨å¯„å­˜å™¨ rd ä¸­ï¼Œç„¶åå°† é€šç”¨å¯„å­˜å™¨ rs çš„å€¼å†™å…¥è¯¥ CSR ã€‚å› æ­¤è¿™é‡Œèµ·åˆ°çš„æ˜¯äº¤æ¢ sscratch å’Œ sp çš„æ•ˆæœã€‚åœ¨è¿™ä¸€è¡Œä¹‹å‰ sp æŒ‡å‘ç”¨æˆ·æ ˆï¼Œ sscratch æŒ‡å‘å†…æ ¸æ ˆï¼Œç°åœ¨ sp æŒ‡å‘å†…æ ¸æ ˆï¼Œ sscratch æŒ‡å‘ç”¨æˆ·æ ˆã€‚</p>
<hr />
<p>ä»ç”¨æˆ·æ€ä¸­æ–­æ—¶,spæŒ‡å‘å†…æ ¸æ ˆ.ç„¶ååœ¨sp[...]åŒºé—´ä¸­ä¿å­˜trapcontextå†…å®¹</p>
<p><strong>ç–‘é—®</strong>:(ä¸­æ–­å¤„ç†ç¨‹åºç”¨çš„ä¹Ÿæ˜¯å†…æ ¸æ ˆ,éš¾é“æ‰§è¡Œæµä¸ä¼šæ”¹å˜å†…æ ¸æ ˆä¸­çš„å†…å®¹å—? é‚£ä¿å­˜äº†è¿˜æœ‰ä»€ä¹ˆæ„ä¹‰. è¯¥æ‰§è¡Œæµä»…ä¼šæ”¹åŠ¨trapcontextä¸­çš„å†…å®¹å—?)</p>
<p><strong>åˆ†æ</strong>:spæ°¸è¿œæŒ‡å‘æ‰§è¡Œæµä¸­çš„æ ˆ.æ‰€ä»¥ä¸­æ–­å¤„ç†ç¨‹åºè¿è¡Œæ—¶å€™å¹¶ä¸ä¼šå¹²æ‰°åˆ°åŸæœ¬ä¿æŒçš„å†…å®¹</p>
<p>more:å†…æ ¸æ ˆå¯ä»¥ç†è§£ä¸ºæ˜¯ä¸€ä¸ªä¸­æ–­å‘ç”Ÿæ—¶ä¸´æ—¶å­˜æ”¾é€šç”¨å¯„å­˜å™¨ä»¥åŠæŒ‡ä»¤ä¸çŠ¶æ€å¯„å­˜å™¨ä¿¡æ¯çš„æ ˆ. å®é™…å†…æ ¸åœ¨æ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°æ—¶å¹¶ä¸ä¼šç”¨åˆ°è¯¥æ ˆ(æŒ‡çš„æ˜¯ä¸ä¿®æ”¹.è¿˜æ˜¯å¯ä»¥ä»ä¸­è¯»å–ä¸€äº›ä¿¡æ¯),å†…æ ¸æ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°æ—¶æ‰€ä½¿ç”¨çš„æ ˆæ˜¯sp.(åœ¨ä»»ä½•æ‰§è¡Œæµä¸­ä½¿ç”¨çš„æ ˆéƒ½åº”è¯¥æ˜¯sp)</p>
<hr />
<p><strong>addi sp, sp, -34*8</strong>ä¸ºä»€ä¹ˆè¿™æ¡æŒ‡ä»¤å¯ä»¥è¡¨ç¤ºåˆ†é…äº†æ ˆå¸§. spæŒ‡å‘çš„æ˜¯æ ˆé¡¶. æ ˆå‘ä½åœ°å€å¢é•¿,ç°åœ¨å‡å°‘spçš„å€¼æ„å‘³ç€æ ˆé¡¶çš„æé«˜.ç›¸å½“äºåˆ†é…äº†ç©ºé—´</p>
<hr />
<p><strong>æ—¶é’Ÿä¸­æ–­</strong></p>
<p>ç›¸å…³å¯„å­˜å™¨ mtime  â€‹mtimecmp   mie  sie sip</p>
<p>SI(Software Interrupt)ï¼Œè½¯ä»¶ä¸­æ–­
TI(Timer Interrupt)ï¼Œæ—¶é’Ÿä¸­æ–­
EI(External Interrupt)ï¼Œå¤–éƒ¨ä¸­æ–­</p>
<p>â€‹mtimecmp â€‹= â€‹mtime â€‹+ â€‹Xâ€‹
A timer interrupt (if enabled) is generated whenever â€‹mtime â€‹is greater than or equal to the valuein the â€‹mtimecmp â€‹register. Therefore, to generate a timer interrupt after â€‹X â€‹cycles, one can updatemtimecmp â€‹register as follows: â€‹mtimecmp â€‹= â€‹mtime â€‹+ â€‹Xâ€‹.</p>
<p>// æ ¹æ®ä¸­æ–­åŸå› åˆ†ç±»è®¨è®º</p>
<pre><code>// åªèƒ½å½“æ¯ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­è§¦å‘æ—¶
// è®¾ç½®ä¸‹ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­çš„è§¦å‘æ—¶é—´
// è®¾ç½®ä¸ºå½“å‰æ—¶é—´åŠ ä¸Š TIMEBASE
// è¿™æ¬¡è°ƒç”¨ç”¨æ¥é¢„å¤„ç†
</code></pre>
<p>æ ¹ç»scause åŒºåˆ†ä¸­æ–­ç±»åˆ«.   è¯¥æœ‰ä¸åŒçš„å¤„ç†äº†   ä»¥åŠè®¾ç½®å¤šå°‘cycleè§¦å‘ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ä¸­æ–­å…·ä½“å®ç°</strong></p>
<p><strong>æ•´ç†ä¸‹ä¸­æ–­æ“ä½œç›¸å…³çš„csrå¯„å­˜å™¨</strong></p>
<blockquote>
<p><strong>sepc</strong>:å‘ç”Ÿå¼‚å¸¸çš„æŒ‡ä»¤çš„pcè¢«å­˜å…¥sepc. æˆ‘ä»¬éœ€è¦è¯»å–ä»–æ¥è·å¾—bugä¿¡æ¯.</p>
<p><strong>stvec</strong>:riscvå¤„ç†å™¨trapåè·³å…¥çš„PCåœ°å€ç”±ä¸€ä¸ªå«åšæœºå™¨æ¨¡å¼å¼‚å¸¸å…¥å£åŸºåœ°å€å¯„å­˜å™¨mtvecçš„csrå¯„å­˜å™¨æŒ‡å®š. mtvecæ˜¯ä¸€ä¸ªå¯è¯»å¯å†™çš„å¯„å­˜å™¨, è½¯ä»¶å¯ä»¥ç¼–ç¨‹è®¾å®šå®ƒçš„å€¼.åœ¨Sæ¨¡å¼ä¸‹ç”¨åˆ°çš„å¯„å­˜å™¨å³ä¸ºstvec.æˆ‘ä»¬éœ€è¦ç”¨å†™stvecæ¥è·³è½¬åˆ°ä¸­æ–­å¤„ç†ä»£ç .trap.asmä¸­çš„__alltrapså¤„</p>
<p><strong>scaues</strong>:å®ƒä¼šè®°å½•ä¸­æ–­å‘ç”Ÿçš„åŸå› , éœ€è¦ç”¨è¯»å–è¯¥å¯„å­˜å™¨æ¥æ ¹æ®ä¸åŒç±»å‹ä¸­æ–­æ‰§è¡Œä¸åŒå¤„ç†ä»£ç </p>
<p><strong>sstatus</strong>:éœ€è¦è®¾ç½®å®ƒçš„sieä½æ¥ä½¿èƒ½ä¸­æ–­</p>
</blockquote>
<p><strong>å¦‚ä½•è¯»å†™csrå¯„å­˜å™¨</strong></p>
<p>è¯»å†™satpå¯„å­˜å™¨ä¸ºä¾‹:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, satp&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn write(x: usize) {
    llvm_asm!(&quot;csrw satp, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆå§‹åŒ–ä¸­æ–­</strong></p>
<p>åœ¨å¤„ç†å™¨çš„ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­,ä¸€æ—¦å‘ç”Ÿå¼‚å¸¸,åˆ™ç»ˆæ­¢å½“å‰çš„ç¨‹åºæµ,å¤„ç†å™¨è¢«å¼ºè¡Œè·³è½¬åˆ°ä¸€ä¸ªæ–°çš„PCåœ°å€ã€‚</p>
<p>åœ¨riscvä¸­Sæ€è¯¥åœ°å€ç”±stvecæŒ‡å®šstvecä½2ä½ä½modeåŸŸ,é«˜30ä½æ˜¯baseåŸŸ.</p>
<p>å½“<strong>MODE</strong>=0ï¼Œè®¾ç½®ä¸º Direct æ¨¡å¼æ—¶ï¼Œåˆ™æ‰€æœ‰çš„å¼‚å¸¸å“åº”æ—¶å¤„ç†å™¨å‡è·³è½¬åˆ°baseå€¼æŒ‡ç¤ºçš„pcåœ°å€ã€‚</p>
<p>å½“<strong>MODE=1</strong>æ—¶ï¼Œè®¾ç½®ä¸º Vectored æ¨¡å¼æ—¶ï¼Œé‡åˆ°ä¸­æ–­æˆ‘ä»¬ä¼šè¿›è¡Œè·³è½¬å¦‚ä¸‹ï¼šPC-&gt;BASE + 4 x causeã€‚è€Œè¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€å°†å„ä¸­æ–­å¤„ç†ç¨‹åºæ”¾åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œå¹¶è®¾ç½®å¥½ stvec ï¼Œé‡åˆ°ä¸­æ–­çš„æ—¶å€™ç¡¬ä»¶æ ¹æ®ä¸­æ–­åŸå› å°±ä¼šè‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”çš„ä¸­æ–­å¤„ç†ç¨‹åºäº†</p>
<p>åœ¨æ­¤æˆ‘ä»¬é€‰æ‹©Directæ¨¡å¼.è·³è½¬åˆ°ç»Ÿä¸€åœ°å€è¿›è¡Œå¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init() {
    unsafe {
        extern &quot;C&quot; {
            fn __alltraps();
        }
        //è®¾ç½®trapè·³è½¬åˆ°ç»Ÿä¸€åœ°å€ __alltrapså¤„
        println!(&quot;trap init--------------&quot;);
        stvec::write(__alltraps as usize);
        sstatus::set_sie();
    }
    println!(&quot;++++ setup interrupt! ++++&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>stvec</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub unsafe fn _write(x: usize) {
    llvm_asm!(&quot;csrw stvec, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
//0ä¸ºè®¾ç½®æˆDirectæ¨¡å¼
#[inline]
pub unsafe fn write(addr: usize) {
    _write(addr + 0 as usize);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>sstatus</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIE: usize = 1 &lt;&lt; 1;  // supervisor interrupt enable
#[inline]
pub fn write(x: usize) {
    unsafe {llvm_asm!(&quot;csrw sstatus, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);}
}

#[inline]
pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, sstatus&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}

#[inline]
pub fn set_sie() {
    write(read() | SIE);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>__alltrap</strong></p>
<pre><code class="language-x86asm">__alltraps:
    csrrw sp, sscratch, sp       äº¤æ¢ç”¨æˆ·æ ˆå’Œå†…æ ¸æ ˆ
    addi sp, sp, -34*8           åœ¨å†…æ ¸æ ˆä¸Šåˆ†é…ä¸€ä¸ªtrapcontextå¤§å°çš„æ ˆå¸§
    
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct TrapContext {
    // 32ä¸ªé€šç”¨å¯„å­˜å™¨ 
    pub x: [usize; 32], 
    // å‡ ä¸ªç›¸å…³csrå¯„å­˜å™¨
    pub sstatus: usize,
    pub sepc: usize,
    pub stval: usize,
    pub scause: usize,
    //å…±éœ€(32+4)*8çš„æ ˆç©ºé—´
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>trap.asm</strong></p>
<pre><code class="language-x86asm">	.section .text
	.globl __alltraps
__alltraps:
	SAVE_ALL
	mv a0, sp
	jal trap_handler

	.globl __trapret
__trapret:
	RESTORE_ALL
	sret

.equ XLENB, 8
.macro LOAD a1, a2
	ld \a1, \a2*XLENB(sp)
.endm

.macro STORE a1, a2
	sd \a1, \a2*XLENB(sp)
.endm
</code></pre>
<p><strong>save_allå’Œrestore_all</strong></p>
<pre><code class="language-x86asm">
.macro SAVE_ALL
	csrrw sp, sscratch, sp
	addi sp, sp, -36*XLENB
	STORE x1, 1
	STORE x3, 3
...
    STORE x30, 30
    STORE x31, 31

	csrrw s0, sscratch, x0
	csrr s1, sstatus
	csrr s2, sepc
	csrr s3, stval
	csrr s4, scause
	
	STORE s0, 2
	STORE s1, 32
	STORE s2, 33
	STORE s3, 34
	STORE s4, 35
.endm
</code></pre>
<pre><code class="language-x86asm">.macro RESTORE_ALL
	LOAD s1, 32
	LOAD s2, 33
	andi s0, s1, 1 &lt;&lt; 8
    csrw sstatus, s1
    csrw sepc, s2
	LOAD x1, 1
	LOAD x3, 3
...
    LOAD x30, 30
    LOAD x31, 31

	LOAD x2, 2
.endm
</code></pre>
<p>åˆ†åˆ«ç”¨ldå’Œsdæ¥ä¿å­˜é€šç”¨å¯„å­˜å™¨.64ä½æ•°æ®éœ€è¦8å­—èŠ‚ç©ºé—´å­˜å‚¨.ç”¨å¯„å­˜å™¨ç¼–å·*8(sp)æ¥å­˜æ”¾åˆ°trapcontextä¸­ç›¸åº”ä½ç½®å»
åŒºåˆ†æ˜¯ä»ç”¨æˆ·æ€ä¸­æ–­è¿˜æ˜¯ä»å†…æ ¸æ€ä¸­æ–­.åªéœ€åˆ¤æ–­spæ˜¯å¦ä¸º0.sp!=0åˆ™æ˜¯ä»ç”¨æˆ·æ€è¿›å…¥ä¸­æ–­.sp=0åˆ™æ˜¯ä»å†…æ ¸æ€è¿›å…¥ä¸­æ–­.æ— éœ€åˆ‡æ¢æ ˆ</p>
<p>å®ç°ä¸­æ–­å¤„ç†å‡½æ•°trap_handler</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    match cause {

        3 =&gt; breakpoint(&amp;mut tf.sepc),
        5 =&gt; super_timer(),
        12 =&gt; page_fault(tf),
        13 =&gt; page_fault(tf),
        15 =&gt; page_fault(tf),
        _ =&gt; println!(&quot;undefined trap!&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>1.æ‰“å°å‡ºä¸­æ–­ç±»å‹,ä»¥åŠè§¦å‘ä¸­æ–­æŒ‡å®šçš„pcå€¼.ä»¥ä¾¿ä»¥åè°ƒè¯•</p>
<p>2.æ ¹æ®causeä¸åŒåˆ†åˆ«è¿›è¡Œä¸åŒçš„å¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>å¦‚æœæ˜¯æ–­ç‚¹åˆ™æ‰“å°æ–­ç‚¹pc. ç„¶åpc+2.æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ (riscv64æŒ‡å®šé•¿åº¦ä¸º4å­—èŠ‚.åŸæ¥åº”è¯¥æ˜¯sepc+4.ä½†æ˜¯ç¼–è¯‘å™¨çš„è¡Œä¸ºä¼šå‹ç¼©.æ‰€ä»¥ä¿®æ­£ä¸ºsepc+2)
fn breakpoint(sepc: &amp;mut usize) {
    println!(&quot;a breakpoint epc:0x{:x}&quot;, sepc);
    *sepc += 2;
}

æ¯æ¬¡è§¦å‘æ—¶é’Ÿä¸­æ–­TICKS+1.è§¦å‘100æ¬¡æ‰“å°ä¸€æ¬¡.
fn super_timer() {
    clock_set_next_event();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}

//page_fault
fn page_fault(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    println!(&quot;{:?} va = {:#x} instruction = {:#x}&quot;, cause, tf.stval, tf.sepc);
    panic!(&quot;page fault!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>è‡³æ­¤trapå¯ä»¥å¯ä»¥æ­£å¸¸å·¥ä½œ</strong></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è¿è¡Œåº”ç”¨ç¨‹åº</strong></p>
<p><strong>å°†åº”ç”¨ç¨‹åºé“¾æ¥åˆ°å†…æ ¸</strong></p>
<p>link_app.S</p>
<pre><code class="language-x86asm">    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 3
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_2_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;
app_1_end:

    .section .data
    .global app_2_start
    .global app_2_end
app_2_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;
app_2_end:

</code></pre>
<p><strong>.incbin</strong></p>
<table><tr><td bgcolor=#EFF5FF>
The incbin directive includes file verbatim at the current location. You can control the search paths used with the -I command-line option (refer to Chapter 3 Command-Line Options). Quotation marks are required around file.
<p>The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user's responsibility to make sure that proper alignment is provided both before and after the incbin directive.</p>
</td></tr></table>
<p><strong>.quad</strong></p>
<p>ç”¨æ¥å®šä¹‰ä¸€ä¸ª8å­—èŠ‚. åœ°å€ä¸ºå„ä¸ªåº”ç”¨ç¨‹åºèµ·å§‹åœ°å€</p>
<p>num_app_ptr[x] æ¥å¾—åˆ°_num_appä¸­å®šä¹‰çš„åº”ç”¨ç¨‹åºèµ·å§‹åœ°å€</p>
<p>ç„¶åç”¨copy_from_sliceæ¥å®ç°ç±»ä¼¼memcpyçš„åŠŸèƒ½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_MANAGER: AppManager = AppManager {
        inner: RefCell::new({
            extern &quot;C&quot; { fn _num_app(); }
            let num_app_ptr = _num_app as usize as *const usize;
            let num_app = unsafe { num_app_ptr.read_volatile() };
            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];
            let app_start_raw: &amp;[usize] = unsafe {
                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
            };
            app_start[..=num_app].copy_from_slice(app_start_raw);
            AppManagerInner {
                num_app,
                current_app: 0,
                app_start,
            }
        }),
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>æŠŠåº”ç”¨ç¨‹åºçš„ä»£ç å’Œæ•°æ®å­˜åœ¨äº†app_startçš„æ•°ç»„ä¹‹å.ç„¶ååˆ©ç”¨trapè¿”å›åœ¨å†…æ ¸æ ˆä¸Šå‹å…¥è®¾ç½®å¥½çš„æ ˆ
riscvå‡½æ•°è°ƒç”¨è§„å®šç¬¬ä¸€ä¸ªå‚æ•°æ”¾åœ¨a0ä¸­. åˆ©ç”¨è¿™ç‚¹trap.asm ä¸­ __trapret mv sp, a0  å¯ä»¥è®©æˆ‘ä»¬å‹å…¥æˆ‘ä»¬è®¾ç½®å¥½çš„æ ˆ
æ ˆè®¾ç½®:</p>
<p>1.sspè®¾ç½®ä¸ºuser</p>
<p>2.sepcè®¾ç½®ä¸ºåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TrapContext {
    pub fn set_sp(&amp;mut self, sp: usize) { self.x[2] = sp; }
    pub fn app_init_context(entry: usize, sp: usize) -&gt; Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
        };
        cx.set_sp(sp);
        cx
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ç”±äºåœ¨ RISC-V ä¸­æ ˆæ˜¯å‘ä¸‹å¢é•¿çš„, æ ˆé¡¶åœ°å€ = èµ·å§‹åœ°å€+æ ˆå¤§å°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl KernelStack {
    fn get_sp(&amp;self) -&gt; usize {
        self.data.as_ptr() as usize + KERNEL_STACK_SIZE
    }
    pub fn push_context(&amp;self, cx: TrapContext) -&gt; &amp;'static mut TrapContext {
        let cx_ptr = (self.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) as *mut TrapContext;
        unsafe { *cx_ptr = cx; }
        unsafe { cx_ptr.as_mut().unwrap() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¤„ç†ç³»ç»Ÿè°ƒç”¨</strong></p>
<p>ç³»ç»Ÿè°ƒç”¨:é€šè¿‡æŸ¥riscvæ‰‹å†Œ Environment call from U-mode ä¸ºå¼‚å¸¸.å¼‚å¸¸å·ä¸º8</p>
<p>åœ¨traphandlerä¸­åŠ å…¥å¯¹ç³»ç»Ÿè°ƒç”¨å¤„ç†</p>
<p>é€šè¿‡è¯»å–scauseçš„ç¬¬64ä½æ¥åŒºåˆ†æ˜¯ä¸­æ–­è¿˜æ˜¯å¼‚å¸¸, ç„¶åè§†ä¸åŒæƒ…å†µè¿›è¡Œå¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    let tmp = scause::read().get_bit(63);
    //tmp  åŒºåˆ†ä¸­æ–­è¿˜æ˜¯å¼‚å¸¸
    if tmp == true {
        match cause {
            _ =&gt; println!(&quot;undefined trap!&quot;)
        }
        tf
    }else{
        match cause {
            2 =&gt; {
                println!(&quot;[kernel] IllegalInstruction in application, core dumped.&quot;);
                run_next_app();
            }
            3 =&gt; breakpoint(&amp;mut tf.sepc),
            5 =&gt; super_timer(),
            // 12 =&gt; page_fault(tf),
            // 13 =&gt; page_fault(tf),
            7 | 15 =&gt; {
                println!(&quot;[kernel] PageFault in application, core dumped.&quot;);
                run_next_app();
            }   
            8 =&gt; user_syscall(tf),
            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æœ€ç»ˆå¾—åˆ°é¢„å–ç»“æœ~~</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>++++ setup interrupt! ++++
[kernel] num_app = 3
[kernel] app_0 [0x80210654, 0x802119e4)
[kernel] app_1 [0x802119e4, 0x80212e14)
[kernel] app_2 [0x80212e14, 0x802143ac)
[kernel] Loading app_0
[kernel] Loading app_0 finished
Hello, world!
[kernel] IllegalInstruction in application, core dumped.
[kernel] Loading app_1
[kernel] Loading app_1 finished
Into Test store_fault, we will insert an invalid store operation...
Kernel should kill this application!
[kernel] PageFault in application, core dumped.
[kernel] Loading app_2
[kernel] Loading app_2 finished
3^10000=5079
3^20000=8202
3^30000=8824
3^40000=5750
3^50000=3824
3^60000=8516
3^70000=2510
3^80000=9379
3^90000=2621
3^100000=2749
Test power OK!
[kernel] Application exited with code 0
panicked at 'All applications completed!', src\batch.rs:61:13
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è¿è¡Œåº”ç”¨ç¨‹åºæ€»ç»“</strong></p>
<p><strong>1.ç¼–å†™åº”ç”¨ç¨‹åº</strong></p>
<p>ç¼–å†™ç”¨æˆ·æ€syscall. å°±å¦‚åŒosè°ƒç”¨sbicallç±»ä¼¼!</p>
<p>é€šè¿‡linkeré“¾æ¥è„šæœ¬.æ¥æŒ‡å®šåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<p><strong>2.é“¾æ¥åº”ç”¨ç¨‹åº</strong></p>
<p>.quad æ¥æŒ‡å®šä¸€ä¸ª8å­—èŠ‚åœ°å€</p>
<p>.incbin æ¥è½½å…¥ä¸€ä¸ªæ–‡ä»¶</p>
<p><strong>3.åœ¨å†…æ ¸ä¸­è½½å…¥åº”ç”¨ç¨‹åº</strong></p>
<p>é€šè¿‡from_raw_parts_mut å’Œ copy_from_slice æ¥å®ç°ç±»ä¼¼memcpyåŠŸèƒ½</p>
<p><strong>4.ä¸ºåº”ç”¨ç¨‹åºè®¾ç½®å¥½TrapContext</strong></p>
<p>1.sspè®¾ç½®ä¸ºuser</p>
<p>2.sepcè®¾ç½®ä¸ºåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<p><strong>5.åˆ©ç”¨trapretæ¥æŠŠè®¾ç½®å¥½çš„TrapContextå‹å…¥åˆ°å†…æ ¸æ ˆä¸­</strong></p>
<p><strong>6.ä¸­æ–­ä¸­åŠ å…¥å¯¹ç³»ç»Ÿè°ƒç”¨æ”¯æŒ</strong></p>
<p>1.Environment call from U-mode</p>
<p><strong>7.é€‰æ‹©ä½•æ—¶è¿è¡Œåº”ç”¨ç¨‹åº</strong></p>
<p>è°ƒåº¦å™¨ç›¸å…³.å®éªŒæš‚æ—¶æœªæ¶‰åŠ.åªæ˜¯é€šè¿‡äººä¸ºè§¦å‘å¼‚å¸¸æŒ‡ä»¤æ¥è¿›å…¥ä¸­æ–­,ç„¶ååœ¨ä¸­æ–­å¤„ç†ä¸­è¿è¡Œä¸‹ä¸€ä¸ªåº”ç”¨ç¨‹åº</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ç¬¬ä¸‰ç« </strong></p>
<p><strong>å¤šé“ç¨‹åºæ”¾ç½®ä¸åŠ è½½</strong></p>
<p>å’Œä¸Šä¸€ç« ä¸åŒçš„æ˜¯appå…¶å®åœ°å€è¢«åŠ è½½åˆ°äº†APP_BASE_ADDRESS + app_id * APP_SIZE_LIMITä½ç½®ä¸Š</p>
<p><strong>ä»»åŠ¡åˆ‡æ¢</strong></p>
<p>åœ¨å¤„ç†trapæ—¶.æˆ‘ä»¬éœ€è¦åˆ‡æ¢æˆå†…æ ¸æ ˆ.è€Œåœ¨ç”¨æˆ·ç¨‹åºåˆ‡æ¢æ—¶,æˆ‘ä»¬éœ€è¦åˆ‡æ¢çš„å¦ä¸€ä¸ªç¨‹åºçš„æ ˆ.</p>
<p>å½“å‰ä»»åŠ¡åˆ‡æ¢çš„æœ¬è´¨æ˜¯å‡½æ•°è°ƒç”¨,æˆ‘ä»¬éœ€è¦ä¿å­˜çš„æ˜¯riscvå‡½æ•°è°ƒç”¨è§„å®šä¸­caller-savedçš„å¯„å­˜å™¨.s0~s11</p>
<p>ä¿å­˜å¥½å½“å‰ä»»åŠ¡çš„ä¿¡æ¯å.å¦‚ä½•è¿”å›å½“å‰ä»»åŠ¡ç»§ç»­æ‰§è¡Œ?. åœ¨åšå‡½æ•°åˆ‡æ¢å‰,ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬å§raå¯„å­˜å™¨çš„å€¼æ”¹ä¸º</p>
<p>å‡½æ•°è°ƒç”¨è¿”å›åç¬¬ä¸€æ¡æŒ‡ä»¤çš„åœ°å€. å› æ­¤éœ€è¦ä¿å­˜ra</p>
<p>åˆ‡æ¢åˆ°ç›®æ ‡ä»»åŠ¡. riscvå‡½æ•°è°ƒç”¨ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°åˆ†åˆ«ä¿å­˜åœ¨a0/a1.å› æ­¤ld sp, 0(a1)å³å¯æ¢æ ˆ.</p>
<p>ç„¶åè¯»å–ra s0~s11. </p>
<p><strong>åä½œå¼è°ƒåº¦</strong></p>
<p>æœ‰äº†ä»»åŠ¡åˆ‡æ¢,é‚£ä¹ˆä½•æ—¶è¿›è¡Œåˆ‡æ¢?</p>
<p>ç°åœ¨çš„åšæ³•æ˜¯åº”ç”¨ç¨‹åºä¸»åŠ¨æš‚åœsys_yield ä»¥åŠä¸»åŠ¨é€€å‡ºsys_exit</p>
<p><strong>ä»»åŠ¡ç®¡ç†å™¨</strong></p>
<p>ä¿å­˜äº†å„ä¸ªç¨‹åºåˆ‡æ¢æ—¶æè¿°è‡ªèº«çš„æ ˆä¿¡æ¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskManager {
    num_app: usize,
    inner: RefCell&lt;TaskManagerInner&gt;,
}

struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    current_task: usize,
}

unsafe impl Sync for TaskManager {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆ‡æ¢ä»»åŠ¡</strong></p>
<p>__switchç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è‡ªèº«æ ˆ,ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç›®æ ‡ä»»åŠ¡çš„æ ˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_next_task(&amp;self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.borrow_mut();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr2 = inner.tasks[current].get_task_cx_ptr2();
        let next_task_cx_ptr2 = inner.tasks[next].get_task_cx_ptr2();
        core::mem::drop(inner);
        unsafe {
            __switch(
                current_task_cx_ptr2,
                next_task_cx_ptr2,
            );
        }
    } else {
        panic!(&quot;All applications completed!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>find_next_task.æ‰¾åˆ°çŠ¶æ€ä¸ºTaskStatus::Readyçš„ä»»åŠ¡</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    let inner = self.inner.borrow();
    let current = inner.current_task;
    (current + 1..current + self.num_app + 1)
        .map(|id| id % self.num_app)
        .find(|id| {
            inner.tasks[*id].task_status == TaskStatus::Ready
        })
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆ†æ—¶å¤šä»»åŠ¡ç³»ç»Ÿä¸æŠ¢å å¼è°ƒåº¦</strong></p>
<p>æ¯”è¾ƒç®€å•.è®¾ç½®å¥½æ—¶é’Ÿä¸­æ–­, å¹¶åœ¨æ—¶é’Ÿä¸­æ–­å‘ç”Ÿæ—¶run_next_task(),åœ¨trap_handlerä¸­åŠ å…¥ç›¸åº”å¤„ç†å³å¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
.........
        match cause {
.........
            5 =&gt; super_timer(),

            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}


fn super_timer() {
    clock_set_next_event();
    suspend_current_and_run_next();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>chapter3ç»ƒä¹ </strong></p>
<p><strong>stride è°ƒåº¦ç®—æ³•</strong></p>
<p>ä¹‹å‰æ˜¯åœ¨å‘ç”Ÿæ—¶é’Ÿä¸­æ–­æ—¶,é€‰æ‹©ä¸‹ä¸€ä¸ªReadyçŠ¶æ€çš„ç¨‹åºè¿è¡Œ,strideè°ƒåº¦ç®—æ³•å³,ç¨‹åºåˆå§‹strideä¸º0.ä¸ºæ¯ä¸ªç¨‹åºè®¾ç½®ä¸€ä¸ªpass.æ¯æ¬¡ç¨‹åºè¿è¡Œstride+pass. 
å¹¶æ€»æ˜¯é€‰æ‹©strideæœ€å°çš„ç¨‹åºè¿è¡Œ.</p>
<p><strong>å¢åŠ æ•°æ®ç»“æ„</strong></p>
<p>task_pass </p>
<p>task_stride</p>
<p>task_priority </p>
<p>task_time</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    pub current_task: usize,
    pub task_pass:[usize; MAX_APP_NUM],
    pub task_stride:[usize; MAX_APP_NUM],
    pub task_priority:[usize; MAX_APP_NUM],
    pub task_time:[usize; MAX_APP_NUM],
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¯»æ‰¾ä¸‹ä¸€ä¸ªæ‰§è¡Œç¨‹åº</strong></p>
<p>1.æ›´æ–°å½“å‰è¿›ç¨‹stride</p>
<p>2.å¯»æ‰¾ä¸‹ä¸€ä¸ªstrideå€¼æœ€å°çš„è¿›ç¨‹</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    //update
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    let priority = inner.task_priority[current];
    if inner.tasks[current].task_status == TaskStatus::Ready {
        inner.task_stride[current] = inner.task_stride[current] + 127 / priority
    }

    let num_app = get_num_app();
    let mut max_stride = 10000000;
    let mut next = 0 as usize;
    for i in 0..num_app{
        let stride_i  = inner.task_stride[i];
        if stride_i &lt;= max_stride  &amp;&amp; inner.tasks[i].task_status != TaskStatus::Exited{
            next = i;
            max_stride =  stride_i;
        }
    }
    let mut  exited_count = 0 as usize;
    for i in 0..num_app{
        
        if inner.tasks[i].task_status == TaskStatus::Exited{
            exited_count += 1;
        }
    }
    if exited_count == num_app{
        println!(&quot;all exited&quot;);
        None
    }else{
        println!(&quot; next min stride  app id{}&quot;, next);
        Some(next)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æ ‡è®°é€€å‡ºè¿›ç¨‹</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mark_current_suspended(&amp;self) {
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.task_time[current] += 1;
    inner.tasks[current].task_status = if inner.task_time[current] &gt;= 500 {
        inner.task_stride[current] = 10000000;
        println!(&quot;app id {}  exited  run out of time&quot;, current);
        TaskStatus::Exited
    } else {
        TaskStatus::Ready
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>é¦–å…ˆæ˜¯id0è¿è¡Œ.id0 exit åˆ‡æ¢åˆ°id3</p>
<p>id3æ‰§è¡Œçš„æ˜¯ä¸»åŠ¨yeildæ‰€ä»¥ç«‹é©¬è¿›è¡Œäº†åˆ‡æ¢</p>
<p>....</p>
<p>all exitedæ‰€ä»¥ç¨‹åºæ‰§è¡Œå®Œæ¯•</p>
<p>ç¨‹åºå¦‚æœŸè¿è¡Œ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OpenSBI v0.7
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 128 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
stext 80200000 etext 8020a000
srodata 8020a000 erodata 80236000
sdata 8023663c edata 8023be49
sbss 8024be50 ebss 8024c058
Hello, world!
base i 0x80400000
base i 0x80420000
base i 0x80440000
base i 0x80460000
load app done
++++ setup timer!     ++++
power_3 [10000/200000]
power_3 [20000/200000]
power_3 [30000/200000]
power_3 [40000/200000]
power_3 [50000/200000]
power_3 [60000/200000]
power_3 [70000/200000]
power_3 [80000/200000]
power_3 [90000/200000]
power_3 [100000/200000]
power_3 [110000/200000]
power_3 [120000/200000]
power_3 [130000/200000]
power_3 [140000/200000]
power_3 [150000/200000]
power_3 [160000/200000]
power_3 [170000/200000]
power_3 [180000/200000]
power_3 [190000/200000]
power_3 [200000/200000]
3^200000 = 871008973
Test power_3 OK!
[kernel] Application exited with code 0
app id 0  exited 
 next min stride  app id3
current 0 start switch to  3
 next min stride  app id2
current 3 start switch to  2
 next min stride  app id1
current 2 start switch to  1
power_5 [10000/140000]
power_5 [20000/140000]
power_5 [30000/140000]
power_5 [40000/140000]
power_5 [50000/140000]
power_5 [60000/140000]
power_5 [70000/140000]
power_5 [80000/140000]
power_5 [90000/140000]
power_5 [100000/140000]
power_5 [110000/140000]
power_5 [120000/140000]
power_5 [130000/140000]
power_5 [140000/140000]
5^140000 = 386471875
Test power_5 OK!
[kernel] Application exited with code 0
app id 1  exited 
 next min stride  app id3
current 1 start switch to  3
Test sleep OK!
[kernel] Application exited with code 0
app id 3  exited 
 next min stride  app id2
current 3 start switch to  2
power_7 [10000/160000]
power_7 [20000/160000]
power_7 [30000/160000]
power_7 [40000/160000]
power_7 [50000/160000]
power_7 [60000/160000]
power_7 [70000/160000]
power_7 [80000/160000]
power_7 [90000/160000]
power_7 [100000/160000]
power_7 [110000/160000]
power_7 [120000/160000]
power_7 [130000/160000]
power_7 [140000/160000]
power_7 [150000/160000]
power_7 [160000/160000]
7^160000 = 667897727
Test power_7 OK!
[kernel] Application exited with code 0
app id 2  exited 
all exited
panicked at 'All applications completed!', src\task\mod.rs:149:13
93
panicked at 'It should shutdown!', src\sbi.rs:45:5

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>åœ°å€ç©ºé—´</strong></p>
<p><strong>ç‰©ç†å†…å­˜</strong></p>
<p>ç‰©ç†å†…å­˜é¡µå¼ç®¡ç†</p>
<p>å¯¹äºç‰©ç†å†…å­˜çš„é¡µå¼ç®¡ç†è€Œè¨€ï¼Œæˆ‘ä»¬æ‰€è¦æ”¯æŒçš„æ“ä½œæ˜¯ï¼š</p>
<p>åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œè¿”å›å…¶ç‰©ç†é¡µå·ï¼›</p>
<p>ç»™å®šä¸€ä¸ªç‰©ç†é¡µå·ï¼Œå›æ”¶å…¶å¯¹åº”çš„ç‰©ç†é¡µã€‚</p>
<p>ç»™å®šä¸€ä¸ªé¡µå·åŒºé—´è¿›è¡Œåˆå§‹åŒ–ã€‚</p>
<p>è¿™é‡Œç”¨æœ€ç®€å•çš„æ–¹å¼å®ç°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Allocator {
    a: [u8; MAX_PHYSICAL_PAGES],
    offset: usize,
    total:usize
}

impl Allocator {
    // ç»™å®šä¸€ä¸ªé¡µå·åŒºé—´è¿›è¡Œåˆå§‹åŒ–ã€‚
    pub fn init(&amp;mut self, l:usize, r:usize) {
        self.offset = l - 1;
        self.total = r - l;
        // let size = r - l;

        //0è¡¨ç¤ºç©ºé—²
        for i in 0..self.total {
            self.a[i] = 0;
        }
    }

    // // ç»™å®šç‰©ç†åœ°å€ åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œè¿”å›å…¶ç‰©ç†é¡µå·ï¼›
    pub fn alloc(&amp;mut self) -&gt; usize {
        //è®¾ç½®ä¸€ä¸ªåˆ†é…æˆåŠŸæ ‡å¿—
        let mut flag = 0;

        //è¿”å›åˆ†é…çš„ç‰©ç†é¡µå·
        let mut result = 0;
        for i in 0..MAX_PHYSICAL_PAGES-1 {
            if self.a[i] == 0 {
                self.a[i] = 1;
                flag = 1;
                result = i;
                return result;
            }
        }
        if flag == 0 {
            panic!(&quot;physical memory depleted!&quot;);
        }
        result
    }

    //å›æ”¶ç‰©ç†é¡µå·ä¸ºnçš„ç‰©ç†é¡µ
    pub fn dealloc(&amp;mut self, n: usize) {

        let p = n;
        if p &gt;= MAX_PHYSICAL_PAGES {
            panic!(&quot;éæ³•ç‰©ç†é¡µå·&quot;)
        }
        self.a[p] = 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åŠ¨æ€å†…å­˜åˆ†é…</strong></p>
<p>å®ç° Trait GlobalAlloc</p>
<p>ç”¨å†™å¥½çš„åº“ å¹¶æŠŠå®ƒæ ‡è®°ä¸º #[global_allocator]</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use buddy_system_allocator::LockedHeap;

#[global_allocator]
static DYNAMIC_ALLOCATOR: LockedHeap = LockedHeap::empty();

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>rv39é¡µè¡¨</strong></p>
<p><strong>åˆ†æé¡µè¡¨éœ€è¦æ”¯æŒçš„æ“ä½œ</strong></p>
<p>1.æ–°å»ºä¸€ä¸ªé¡µè¡¨(åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå¸§,å¹¶æŠŠè¯¥é¡µå¸§ä½œä¸ºé¡µè¡¨çš„åŸºå€)</p>
<p>2.map unmap ä¸ºä¸€å¯¹va å’Œ pa å»ºç«‹æ˜ å°„</p>
<p>3.æ‰¾åˆ°é¡µè¡¨é¡¹</p>
<p><strong>ç»™å®šæŸvaå»ºç«‹æ˜ å°„çš„è¿‡ç¨‹:</strong></p>
<p><strong>1.æ‰¾åˆ°root_table</strong></p>
<p><strong>2.åœ¨ä¸‰çº§é¡µè¡¨ä¸­æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„é¡µè¡¨é¡¹.æ ¹æ®é¡µè¡¨é¡¹æ¥æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„åœ°å€</strong></p>
<p>å¦‚æœé¡µè¡¨é¡¹æœªè¢«è®¾ç½®. åˆ™åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå¸§, å¹¶æŠŠè¯¥ç‰©ç†é¡µå¸§å¡«å†™åˆ°é¡µè¡¨é¡¹å¹¶è®¾ç½®æ ‡è®°ä½(å³ä»¥åèƒ½é€šè¿‡æ­¤é¡µè¡¨é¡¹æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„åœ°å€äº†)</p>
<p>åªéœ€å¡«å†™validä½.å› ä¸ºå®ƒæŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨</p>
<p>å…¶ä¸­p1_index  p2_index p3_index åˆ†åˆ«ä¸º </p>
<p>è™šæ‹Ÿåœ°å€vaçš„12..21    21 .. 30  30..39 ä½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p3_index = page.p3_index();
let p2_index = page.p2_index();
let p1_index = page.p1_index();

let p2_table = if self.root_table.entries[p3_index].is_unused() {
    let frame = alloc_frame().unwrap();
    self.root_table.entries[p3_index].set(frame, EF::VALID);
    let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
    p2_table.zero();
    p2_table
} else {
    let frame = self.root_table.entries[p3_index].frame();
    unsafe { frame.as_kernel_mut() }
};
<span class="boring">}
</span></code></pre></pre>
<p>è¿™é‡Œéœ€è¦ä¸€ä¸ªæŠŠé¡µè¡¨é¡¹ä¸­çš„åœ°å€è§£æå‡ºæ¥å¹¶å½“æˆé¡µè¡¨çš„æ“ä½œ</p>
<p>(pte &gt;&gt; 10 )  &lt;&lt; 12  +  PHYSICAL_MEMORY_OFFSET</p>
<p>é¡µè¡¨é¡¹å³ç§»10ä½æ¥å¾—åˆ°ç‰©ç†é¡µå·. ä¸€ä¸ªç‰©ç†é¡µå¸§ä¸º4k. å†å·¦ç§»12ä½æ¥å¾—åˆ°ç‰©ç†åœ°å€</p>
<p>å¦‚æœæœ‰è®¾ç½®åç§»åˆ™åŠ ä¸ŠPHYSICAL_MEMORY_OFFSET</p>
<p>è¿™æ ·å°±å¾—åˆ°äº†é¡µè¡¨æ‰€åœ¨çš„ç‰©ç†åœ°å€</p>
<p>rustå†™æ³•æœ‰ä¸¤ç§</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_page_table(&amp;self) -&gt; *mut PageTable {
    ((self.data &gt;&gt; 10) &lt;&lt; 12) as *mut PageTable
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame = self.root_table.entries[p3_index].frame();
pub unsafe fn as_page_table&lt;'a, 'b, T&gt;(&amp;'a self) -&gt; &amp;'b mut T {
    &amp;mut *(    ((self.0).0 + PHYSICAL_MEMORY_OFFSET)   as *mut T  )
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>3.ç„¶åå°±æ˜¯é‡å¤ä¸Šè¿°æ“ä½œ</strong></p>
<p><strong>åœ¨äºŒçº§é¡µè¡¨ä¸­æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹, æ ¹æ®é¡µè¡¨é¡¹æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„åœ°å€</strong></p>
<p>å¦‚æœä¸å­˜åœ¨åˆ™åˆ†é…ç‰©ç†é¡µå¸§,å¡«å†™æ ‡å¿—</p>
<p><strong>æœ€ç»ˆåœ¨ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„é¡µè¡¨é¡¹,æŠŠå¯¹åº”çš„ç‰©ç†é¡µå·å¡«å†™è¿›å»å°±å®Œæˆäº†æ˜ å°„</strong></p>
<p><strong>é‚£ä¹ˆæˆ‘ä»¬è¯¥å¡«å†™ä»€ä¹ˆç‰©ç†é¡µå·è¿›å»å‘¢?</strong> è¿™é‡Œå°±æ¯”è¾ƒéšæ„äº†</p>
<ol>
<li>
<p>å¯ä»¥é‡‡ç”¨ä¸€ä¸ªå›ºå®šçš„åç§» pa = va +  PHYSICAL_MEMORY_OFFSET</p>
</li>
<li>
<p>å¯ä»¥é‡‡ç”¨ä¹‹å‰å†™å¥½çš„ç‰©ç†å†…å­˜åˆ†é…å™¨åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå·</p>
</li>
<li>
<p>...</p>
</li>
</ol>
<p>å®Œæ•´ç‰ˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_pte_create(&amp;mut self, va:usize) -&gt; Option&lt;&amp;mut PageTableEntry&gt; {
    let page = Page::of_addr(VirtAddr::new(va));
    let p3_index = page.p3_index();
    let p2_index = page.p2_index();
    let p1_index = page.p1_index();
    //æ‰¾åˆ°äºŒçº§é¡µè¡¨
    let p2_table = if self.root_table.entries[p3_index].is_unused() {
        let frame = alloc_frame().unwrap();
        self.root_table.entries[p3_index].set(frame, EF::VALID);
        let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p2_table.zero();
        p2_table
    } else {
        let frame = self.root_table.entries[p3_index].frame();
        unsafe { frame.as_kernel_mut() }
    };
    //æ‰¾åˆ°ä¸€çº§é¡µè¡¨
    let p1_table = if p2_table.entries[p2_index].is_unused() {
        let frame = alloc_frame().unwrap();
        p2_table.entries[p2_index].set(frame, EF::VALID);
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table.zero();
        p1_table
    } else {
        let frame = p2_table.entries[p2_index].frame();
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table
    };
    //åœ¨ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”é¡µè¡¨é¡¹
    let p1_entry = Some (&amp;mut p1_table.entries[p1_index]);
    p1_entry
}
<span class="boring">}
</span></code></pre></pre>
<p>å»ºç«‹æ˜ å°„</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map(&amp;mut self, va:usize, frame: Frame, ptflags: PageTableFlags) {
    let pte = self.find_pte_create(va).unwrap();
    if !pte.is_unused(){
        println!(&quot;pte {:?} already mapped&quot;, pte);
    }
    pte.set(frame, ptflags);
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
}

pub fn unmap(&amp;mut self, va:usize) {
    let pte = self.find_pte(va).unwrap();
    pte.set_unused();
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
    MapperFlush::flush(page);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>debug</strong></p>
<p>pa = va - 0xffffffff40000000</p>
<p>å…¶ä¸­p1_index p2_index p3_index åˆ†åˆ«ä¸º è™šæ‹Ÿåœ°å€vaçš„  12..21  å’Œ 21..30 å’Œ 30..39 ä½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>satp :0x8000000000080a2b                 å¯¹åº”ç‰©ç†åœ°å€:0x80a2b000
p3_indexä¸º511                       ç¬¬511é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2bff8
0x80a2bff8å¤„å†…å­˜æ˜¾ç¤º 0x000000002028b0c5(é¡µè¡¨é¡¹)
(0x000000002028b0c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2c000
                                             ç‰©ç†åœ°å€ = 0x80a2c000


å¾—åˆ°äºŒçº§é¡µè¡¨è™šæ‹Ÿåœ°å€ 0xffffffffc0a2c000   å¯¹åº”ç‰©ç†åœ°å€:0x80a2c000
p2_indexä¸º1                            ç¬¬1é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2c008
0x80a2c008å¤„å†…å­˜æ˜¾ç¤º 0x000000002028b4c5(é¡µè¡¨é¡¹)
(0x000000002028b4c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2d000
                                             ç‰©ç†åœ°å€ = 0x80a2d000


å¾—åˆ°ä¸€çº§é¡µè¡¨è™šæ‹Ÿåœ°å€ 0xffffffffc0a2d000   å¯¹åº”ç‰©ç†åœ°å€:0x80a2d000
p1_indexä¸º2                            ç¬¬2é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2d010
0x80a2d010å¤„å†…å­˜æ˜¾ç¤º 0x00000000200808cf(é¡µè¡¨é¡¹)
(0x00000000200808cf &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0202000
                                             ç‰©ç†åœ°å€ = 0x80202000
<span class="boring">}
</span></code></pre></pre>
<p>gdbæ˜¾ç¤ºç‰©ç†å†…å­˜  maintenance packet Qqemu.PhyMemMode:1</p>
<p>x/10xg $addr  ä»¥64ä½ä¸€ä¸ªå•å…ƒæ¥æ˜¾ç¤ºæŸåœ°å€å†…å­˜ä¸­å†…å®¹.</p>
<p><strong>é¡µè¡¨å»ºç«‹è¿‡ç¨‹ä¸­æœ‰å¯èƒ½å‡ºé”™çš„åœ°æ–¹:</strong></p>
<p>1.æŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹æ ‡å¿—ä½è®¾ç½®é”™! (åº”ä¸¥æ ¼æŒ‰ç…§riscvæ‰‹å†Œä¸­æŒ‡ç¤ºçš„æŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨çš„æ ‡å¿—ä½è®¾ç½®æ–¹å¼...å¦åˆ™è¯¥é¡µå°±ä¼šè¢«å½“åˆæ™®é€šé¡µ)..è¿™æ—¶debugä¼šå‘ç°ç»™å®švaæ‰‹åŠ¨ç®—æ€»èƒ½åœ¨æœ€åæ‰¾åˆ°ç›¸åº”çš„ç‰©ç†é¡µå¸§! ä½†æ˜¯ç¨‹åºæ²¡æ³•è¿è¡Œ</p>
<p><strong>rustå°ç¨‹åºè¾…åŠ©è®¡ç®—é¡µè¡¨ç›¸å…³ä¿¡æ¯</strong></p>
<p>å‡è®¾ pa = va - 0xffffffff40000000</p>
<pre><pre class="playground"><code class="language-rust">use bit_field::*;

pub fn next_level(pte:usize)  -&gt; usize {
    let next_level_va = ((pte &gt;&gt;10)&lt;&lt;12) + 0xffffffff40000000 as usize;
    println!(&quot;next level va 0x{:x}&quot;, next_level_va);
    println!(&quot;next level pa level 0x{:x}&quot;, next_level_va - 0xffffffff40000000 as usize);

    next_level_va
}

pub fn va_to_pa(va:usize){
    println!(&quot;pa {:x}&quot;, va - 0xffffffff40000000);
}

pub fn page_index(va:usize){
    println!(&quot;p1_index {:?}  p2_index {:?}  p3_index {:?}&quot;, va.get_bits(12..21), va.get_bits(21..30), va.get_bits(30..39) );
}

pub fn p1_entry(va:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p2_entry = (satp + 8*va.get_bits(12..21)) as usize ;
    println!(&quot;p1_entry {:x}&quot;, p1_entry);
    p2_entry
}

pub fn p2_entry(va:usize, p1_table:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p2_entry = (p1_table + 8*va.get_bits(21..30)) as usize ;
    println!(&quot;p2_entry {:x}&quot;, p2_entry);

    p2_entry
}


pub fn p3_entry(va:usize: p2_table:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p3_entry = (p2_table + 8*va.get_bits(30..39)) as usize ;
    println!(&quot;p3_entry {:x}&quot;, p3_entry);

    p3_entry
}

fn main() {
    let va = 0xffffffffc02058de;
    page_index(va);
    

    p1_entry = p1_entry(0xffffffffc02058de);
    p2_table = next_level(p1_entry);

    p2_entry = p2_entry(0xffffffffc02058de, p2_table);
    p3_table = next_level(p2_entry);

    p3_entry = p1_entry(0xffffffffc02058de, p3_table);

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch4</strong></p>
<p><strong>å®ç°mmap</strong></p>
<p>å¾ˆç®€å•...åŒ…è£…ä¸€ä¸‹memory_setä¸­insert_framed_area...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_mmap(start: usize, len: usize, port: usize) -&gt; isize {
    let mut permission = MapPermission::U;
    if port &amp; 0x1 != 0 {
        permission |= MapPermission::R;
    }
    if port &amp; 0x2 != 0 {
        permission |= MapPermission::W;
    }
    if port &amp; 0x4 != 0 {
        permission |= MapPermission::X;
    }

    let end = VirtAddr::from(VirtAddr(start + len));
    match insert_framed_area(start.into(), end, permission) {
        Ok(_) =&gt; (end.0 - start) as isize,
        Err(_) =&gt; -1,
    }
}

pub fn insert_framed_area(start: VirtAddr, end: VirtAddr, permission: MapPermission,){
    TASK_MANAGER.mmap(start, end, permission);
}

fn mmap(&amp;self, start: VirtAddr, end: VirtAddr,permission: MapPermission ){
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.tasks[current].memory_set.insert_framed_area(start, end, permission);
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å®ç°sys_spawn</strong></p>
<p><strong>ç”±äºtutoriä¸­æ²¡æœ‰å®ç°å†…æ ¸çº¿ç¨‹(è¿›ç¨‹). æ‰€ä»¥åªèƒ½ä»å½“å‰è¿›ç¨‹ä¸­forkå‡ºæ¥.å†æ‰§è¡Œ.</strong></p>
<p>æ‹¿åˆ°åº”ç”¨ç¨‹åºåå­— -&gt; ä»app_nameè·å–åº”ç”¨ç¨‹åºåœ°å€ -&gt; get_app_data_by_name æ¥å£ä¸­æ‰¾åˆ°å¯¹åº”çš„ELFæ•°æ®</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_spawn(path: *const u8) -&gt; isize {
    let path = translated_str(current_user_token(), path);
    if let Some(data) = get_app_data_by_name(path.as_str()) {
        let new_task = current_task().unwrap().fork();
        new_task.exec(data);
        let new_pid = new_task.pid.0;
        add_task(new_task);
        new_pid as isize
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>æ•´ç†ä¹‹å‰ä»£ç </strong></p>
<p>æŠŠç”¨æˆ·ç¨‹åºå’Œosæ”¾ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸‹ç®¡ç†. é…ç½®vscode. ç¼–å†™pythonè„šæœ¬</p>
<p>åœ¨ä¸»ç›®å½•ä¸‹è¿è¡Œpython app_build.py æ¥ç”Ÿæˆç”¨æˆ·ç¨‹åº,é“¾æ¥è„šæœ¬</p>
<p><strong>app_build.py</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import os
os.system('cd user &amp;&amp; cargo clean')
os.system('cd user &amp;&amp; python ./build.py')
os.system('cd user &amp;&amp; python ./objdump.py')
os.system('cd user &amp;&amp; python ./linker.py')
<span class="boring">}
</span></code></pre></pre>
<p><strong>build.py</strong></p>
<pre><code>import os
os.system('cd os &amp;&amp; cargo build')
os.system('cd os &amp;&amp; rust-objcopy target/riscv64gc-unknown-none-elf/debug/os --strip-all -O binary target/riscv64gc-unknown-none-elf/debug/kernel.bin')
</code></pre>
<p>é…åˆvscode</p>
<p><strong>launch.json</strong></p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;launch&quot;,
            &quot;type&quot;: &quot;cppvsdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;qemu-system-riscv64.exe&quot;,
            &quot;args&quot;: [
                &quot;-machine&quot;,
                &quot;virt&quot;,
                &quot;-nographic&quot;,
                &quot;-no-reboot&quot;,
                &quot;-bios&quot;,
                &quot;default&quot;,
                &quot;-device&quot;,
                &quot;loader,file=${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/kernel.bin,addr=0x80200000&quot;,
            ],
            &quot;preLaunchTask&quot;: &quot;python&quot;,
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
        },        
        {
            &quot;name&quot;: &quot;launch-qemu&quot;,
            &quot;type&quot;: &quot;cppvsdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;qemu-system-riscv64.exe&quot;,
            &quot;args&quot;: [
                &quot;-machine&quot;,
                &quot;virt&quot;,
                &quot;-nographic&quot;,
                &quot;-no-reboot&quot;,
                &quot;-bios&quot;,
                &quot;default&quot;,
                &quot;-device&quot;,
                &quot;loader,file=${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/kernel.bin,addr=0x80200000&quot;,
                &quot;-s&quot;,
                &quot;-S&quot;
            ],
            &quot;preLaunchTask&quot;: &quot;copy&quot;,
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,
        },
        {
            &quot;name&quot;: &quot;qemu&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;miDebuggerServerAddress&quot;: &quot;127.0.0.1:1234&quot;,
            &quot;miDebuggerPath&quot;: &quot;D:/riscv64-unknown-elf-gcc-w64/bin/riscv64-unknown-elf-gdb.exe&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/os&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;logging&quot;: {
                &quot;engineLogging&quot;: false
            },
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Add gdbinit&quot;,
                    &quot;text&quot;: &quot;-interpreter-exec console \&quot;source -v D:/os/os/.gdbinit\&quot;&quot;
                }
            ]
        },

    ]
}
</code></pre>
<p><strong>tasks.json</strong></p>
<pre><code class="language-json">{
	&quot;version&quot;: &quot;2.0.0&quot;,
	&quot;tasks&quot;: [
		{
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;python&quot;,
			&quot;command&quot;:&quot;python ./build.py&quot;,
		},
        {
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;build&quot;,
			&quot;command&quot;:&quot;cargo build&quot;
		},
		{
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;copy&quot;,
			&quot;command&quot;:&quot;rust-objcopy target/riscv64gc-unknown-none-elf/debug/os --strip-all -O binary target/riscv64gc-unknown-none-elf/debug/kernel.bin&quot;,
			&quot;dependsOn&quot;:[&quot;build&quot;]
		}
	]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch6</strong></p>
<p>è®¾è®¡mail. ç°åœ¨éœ€è¦ä¸€ä¸ªæ‰€æœ‰è¿›ç¨‹å…±äº«çš„æ•°æ®ç»“æ„.å‚è€ƒKERNEL_STACK.è®¾ç½®ä¸€ä¸ªå…¨å±€çš„æ•°æ®ç»“æ„æ¥æ¥ç®¡ç†é‚®ç®±</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mails(pub VecDeque&lt;Vec&lt;u8&gt;&gt;);

åœ¨æ²¡æœ‰å¤šæ ¸çš„æƒ…å†µä¸‹.ä¸éœ€è¦æä¾›äº’æ–¥è®¿é—®.æ‰€ä»¥ä¸éœ€è¦ç”¨ç±»ä¼¼Arc&lt;Mutex&lt;T&gt;&gt;çš„æ–¹æ³•

å’ŒKernelStackä¸€æ ·æŠŠMailsæ”¾åœ¨TaskControlBlockä¸­

<span class="boring">}
</span></code></pre></pre>
<p>è¯»</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn readable(&amp;self) -&gt; bool {
    self.0.len() &gt; 0
}

pub fn read(&amp;mut self, buf: UserBuffer) -&gt; usize {
    let mut buf_iter = buf.into_iter();
    let mut read_size = 0usize;
    let mail = self.0.pop_front().unwrap();
    for c in mail {
        if let Some(byte_ref) = buf_iter.next() {
            unsafe { *byte_ref = c; }
            read_size += 1;
        } else {
            break;
        }
    }
    read_size
}
<span class="boring">}
</span></code></pre></pre>
<p>å†™</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn writable(&amp;self) -&gt; bool {
    self.0.len() &lt; MAX_MAILS_NUM
}

pub fn write(&amp;mut self, buf: UserBuffer) -&gt; usize {
    let mut write_size = 0usize;
    let mut mail: Vec&lt;u8&gt; = Vec::new();
    for c in buf {
        unsafe{ mail.push(*c); }
        write_size += 1;
    }
    self.0.push_back(mail);
    write_size
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ch7</strong></p>
<p><strong>æ–‡ä»¶ç³»ç»Ÿ</strong></p>
<p>æ–‡ä»¶ç³»ç»Ÿçš„å‡ ä¸ªç»„è¦éƒ¨åˆ†:</p>
<p>1.ç£ç›˜ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿ</p>
<p>2.ç£ç›˜å—,åœ¨bufferä¸­çš„ç£ç›˜å—</p>
<p>3.å†…å­˜ä¸­çš„buffer</p>
<p>(è¯»å†™æ–‡ä»¶ç³»ç»Ÿ: å¦‚æœç£ç›˜å—åœ¨å†…å­˜bufferä¸­,å°±æ˜¯ç›´æ¥è¯»å†™å†…å­˜, å¦‚æœç£ç›˜å—ä¸åœ¨bufferä¸­åˆ™éœ€è°ƒç”¨é©±åŠ¨ç›´æ¥è¯»å†™ç£ç›˜å¹¶å¡«å…¥bufferä¸­.)</p>
<p>4.osä¸Šçš„å…·ä½“æ–‡ä»¶ç³»ç»Ÿ</p>
<p>5.osä¸­çš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ. åŒ…è£…å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿ</p>
<p>6.æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨.  å¯é‡‡ç”¨ramdisk.ç”¨å†…å­˜ä¸­çš„ä¸€æ®µåŒºé—´æ¥æ¨¡æ‹Ÿç£ç›˜.</p>
<p><strong>sys_open</strong></p>
<p>è°ƒç”¨ä¸€ä¸‹open_file.è®¾ç½®æ ‡è®°ä½.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_open(path: *const u8, flags: u32) -&gt; isize {
    let task = current_task().unwrap();
    let token = current_user_token();
    let path = translated_str(token, path);
    if let Some(inode) = open_file(
        path.as_str(),
        OpenFlags::from_bits(flags).unwrap()
    ) {
        let mut inner = task.acquire_inner_lock();
        let fd = inner.alloc_fd();
        inner.fd_table[fd] = Some(inode);
        fd as isize
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>linkat</strong></p>
<p>åŸºæœ¬å’Œcreateä¸€æ ·,åªä¸è¿‡createéœ€è¦allocä¸€ä¸ªinode.è¿™é‡Œéœ€è¦æ‰¾åˆ°inode</p>
<p>è°ƒç”¨find_inode_idæ‰¾åˆ°inode_id.</p>
<p>æ¥ä¸‹æ¥å‚è€ƒInode::create()ä¸­çš„å†™æ³•. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.modify_disk_inode(|root_inode| {
    // append file in the dirent
    let file_count = (root_inode.size as usize) / DIRENT_SZ;
    let new_size = (file_count + 1) * DIRENT_SZ;
    // increase size
    self.increase_size(new_size as u32, root_inode, &amp;mut fs);
    // write dirent
    let dirent = DirEntry::new(name, new_inode_id);
    root_inode.write_at(
        file_count * DIRENT_SZ,
        dirent.as_bytes(),
        &amp;self.block_device,
    );
});
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.linkat(|root_inode| {
    let file_count = (root_inode.size as usize) / DIRENT_SZ;
    let new_size = (file_count + 1) * DIRENT_SZ;
    self.increase_size(new_size as u32, root_inode, &amp;mut fs);
    let dirent = DirEntry::new(new_name, inode_id);
    root_inode.write_at(
        file_count * DIRENT_SZ,
        dirent.as_bytes(),
        &amp;self.block_device,
    );
});
<span class="boring">}
</span></code></pre></pre>
<p><strong>unlinkat</strong></p>
<p>å’Œlså¾ˆåƒ.lséœ€è¦åˆ—ä¸¾ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶. unlinkatä¹Ÿéœ€è¦éå†ç›®å½•æ¥æ‰¾åˆ°æŒ‡å®šæ–‡ä»¶</p>
<p>ls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ls(&amp;self) -&gt; Vec&lt;String&gt; {
    let _fs_lock = self.fs.lock();
    self.read_disk_inode(|disk_inode| {
        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
        let mut v: Vec&lt;String&gt; = Vec::new();
        for i in 0..file_count {
            let mut dirent = DirEntry::empty();
            assert_eq!(
                disk_inode.read_at(
                    i * DIRENT_SZ,
                    dirent.as_bytes_mut(),
                    &amp;self.block_device,
                ),
                DIRENT_SZ,
            );
            if dirent.inode_number() != 0 {
                v.push(String::from(dirent.name()));
            }
        }
        v
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>unlinkat</p>
<p>å¦‚æœæ–‡ä»¶å==name,åˆ™æŠŠå½“å‰æ–‡ä»¶å†™ç©º.æ¥å®ç°unlink....</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn unlinkat(&amp;self, name: &amp;str) -&gt; isize {
    let file_remove = |disk_inode: &amp;mut DiskInode| {
        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
        let mut dirent = DirEntry::empty();
        for i in 0..file_count {

            disk_inode.read_at(DIRENT_SZ * i, dirent.as_bytes_mut(), &amp;self.block_device);

            if dirent.name() == name {
                disk_inode.write_at(
                    DIRENT_SZ * i,
                    DirEntry::empty().as_bytes_mut(),
                    &amp;self.block_device,
                );
                return 0;
            }
        }
        -1
    };
    self.modify_disk_inode(file_remove)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>æ•´ç†</strong></p>
<p>user-shell</p>
<p>æˆ‘ä»¬é¦–å…ˆè¦èƒ½å¤Ÿé€šè¿‡é”®ç›˜å‘ç»ˆç«¯ç¨‹åºä¸­è¾“å…¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦å®ç°ä¸€ä¸ªç”¨æˆ·ç¨‹åºï¼Œå®ƒèƒ½å¤Ÿæ¥å—é”®ç›˜çš„è¾“å…¥ï¼Œå¹¶å°†é”®ç›˜è¾“å…¥çš„å­—ç¬¦æ˜¾ç¤ºåœ¨å±å¹•ä¸Š</p>
<p>è¿™ä¸ªç”¨æˆ·ç¨‹åºéœ€è¦çš„åŠŸèƒ½æ˜¯ï¼šæ¥å—é”®ç›˜è¾“å…¥ï¼ˆå¯ä»¥è¢«ç§°ä¸ºâ€œæ ‡å‡†è¾“å…¥â€ï¼‰çš„ä¸€ä¸ªå­—ç¬¦ã€‚</p>
<p>éœ€è¦ sys_read    ä»¥åŠç”¨æˆ·ç¨‹åºèƒ½è°ƒç”¨çš„getchar()</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// usr/rust/src/syscall.rs

enum SyscallId {
    Read = 63,
}

pub fn sys_read(fd: usize, base: *const u8, len: usize) -&gt; i64 {
    sys_call(SyscallId::Read, fd, base as usize, len, 0)
}

åŒ…è£…ä¸‹sys_read

pub fn getchar() -&gt; u8 {
    let mut c = [0u8; 1];
    read(STDIN, &amp;mut c);
    c[0]
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>æœ‰äº†getchar()æ”¯æŒ æˆ‘ä»¬å°±å¯ä»¥ç”¨ä¸€ä¸ªloopæ¥å¾ªç¯è·å¾—è¾“å…¥</strong></p>
<p>è¿™ä¸ªè¾“å…¥å­˜åœ¨å“ªé‡Œ?</p>
<p>è¿™æ—¶å°±éœ€è¦ç”¨æˆ·ç¨‹åºçš„åŠ¨æ€å†…å­˜åˆ†é…. å’Œoså†…æ ¸ä¸­ä½¿ç”¨çš„ä¸€æ ·,ä½¿ç”¨å·²ç»å†™å¥½çš„åº“buddy_system_allocator</p>
<p>è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç”¨Stringæ•°æ®ç»“æ„æ¥å­˜è·å¾—çš„è¾“å…¥</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut line: String = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><strong>åœ¨æœ‰äº†ä¸Šé¢çš„æ”¯æŒå,éœ€è¦åšçš„å°±æ˜¯åŒ¹é…è¾“å…¥,ç„¶åè°ƒç”¨execæ¥è¿è¡Œä¸åŒçš„ç¨‹åº</strong></p>
<p>é‡‡ç”¨matchæ¥åŒ¹é…</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() -&gt; i32 {
    println!(&quot;Rust user shell&quot;);
    let mut line: String = String::new();
    print!(&quot;&gt;&gt; &quot;);
    loop {
        let c = getchar();
        match c {

        }
    }
}
</code></pre></pre>
<table><tr><td bgcolor=#EFF5FF>
æ¥ä¸‹æ¥è¦åšçš„å°±æ˜¯ä½¿ç”¨exec("ç”¨æˆ·ç¨‹åºå")æ¥è¿è¡Œä¸åŒç¨‹åº
<p>è¿™è¦æ±‚execèƒ½å¤Ÿæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²,å¹¶è½½å…¥æŒ‡å®šåº”ç”¨ç¨‹åºå¹¶è¿è¡Œ</p>
<p>ç”±äºç³»ç»Ÿè°ƒç”¨ä¸æ”¯æŒä¼ å…¥æ•´ä¸ªå­—ç¬¦ä¸².åªèƒ½ä¼ å…¥å­—ç¬¦ä¸²çš„åœ°å€,ä½†æ˜¯è¿™ä¸ªåœ°å€åˆæ˜¯åœ¨ç”¨æˆ·ç¨‹åºçš„é¡µè¡¨ä¸‹çš„(é‡‡ç”¨äº†åŒé¡µè¡¨è®¾è®¡,å†…æ ¸ç©ºé—´æ— æ³•è®¿é—®ç”¨æˆ·ç©ºé—´,å¦‚æœæ˜¯å•é¡µè¡¨ä¸‹å†…æ ¸å’Œç”¨æˆ·ä½¿ç”¨åŒä¸€ä¸ªé¡µè¡¨,å¯ä»¥ç›´æ¥è·å¾—å­—ç¬¦ä¸²).æ‰€ä»¥éœ€è¦åœ¨å†…æ ¸ä¸­è·å–ç”¨æˆ·ç¨‹åºçš„satp,å¹¶ä¸”æ‰‹åŠ¨æŸ¥é¡µè¡¨æ¥è·å–å­—ç¬¦ä¸².</p>
<p>è·å–åº”ç”¨åä¹‹å,å¦‚ä½•åœ¨å†…æ ¸ç©ºé—´è½½å…¥app_dataå‘¢? ç›¸æ¯”ä¹‹å‰è¿™é‡Œåˆå¤šäº†ä¸€ä¸ªç±»ä¼¼TaskControlBlock ä»¥åŠ Kernel_stackçš„æ•°æ®ç»“æ„APP_NAMES,é‡Œé¢ä¿å­˜äº†åº”ç”¨åå­—å’Œæ•°æ®çš„ä¿¡æ¯</p>
</td></tr></table>
<p><strong>æ•´ä¸ªsys_execå¤§æ¦‚åŒ…æ‹¬å‡ ä¸ªä¸»è¦å‡½æ•°</strong></p>
<p><strong>1:è·å–å½“å‰ç”¨æˆ·é¡µè¡¨åŸºåœ°å€</strong></p>
<p><strong>2:æ‰‹åŠ¨æŸ¥è¯¥é¡µè¡¨è·å–å­—ç¬¦ä¸²</strong></p>
<p><strong>3:ç”¨å­—ç¬¦ä¸²æ‰¾åˆ°åº”ç”¨æ•°æ®,å¹¶è½½å…¥è¿è¡Œ</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_exec(path: *const u8) -&gt; isize {
    let token = current_user_token();
    let path = translated_str(token, path);
    if let Some(data) = get_app_data_by_name(path.as_str()) {
        let task = current_task().unwrap();
        task.exec(data);
        0
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>app linker ç¼–å†™</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_app_names:
    .string &quot;exit&quot;
    .string &quot;user_shell&quot;
<span class="boring">}
</span></code></pre></pre>
<p>start = _app_names. ç›´åˆ°è¯»å–åˆ°'\0' (æœ‰å¾…ç¡®è®¤è¿™é‡Œæ˜¯å¦æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨åŠ ä¸Šäº†'\0')  ä¹‹åç”¨ç±»ä¼¼memcpyä¿å­˜åˆ°&amp;strä¸­</p>
<p>_app_namesæŒ‰é¡ºåºä¿å­˜åœ¨äº†ä¸€ä¸ªvecä¸­, ä¹‹åå°±å¯ä»¥ç”¨idæ¥å¾—åˆ°åº”ç”¨æ•°æ®äº†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_NAMES: Vec&lt;&amp;'static str&gt; = {
        let num_app = get_num_app();
        extern &quot;C&quot; { fn _app_names(); }
        let mut start = _app_names as usize as *const u8;
        let mut v = Vec::new();
        unsafe {
            for _ in 0..num_app {
                let mut end = start;
                while end.read_volatile() != '\0' as u8 {
                    end = end.add(1);
                }
                let slice = core::slice::from_raw_parts(start, end as usize - start as usize);
                let str = core::str::from_utf8(slice).unwrap();
                v.push(str);
                start = end.add(1);
            }
        }
        v
    };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è™šæ‹ŸåŒ–</strong></p>
<p>æ²¡æœ‰å¤´ç»ª.æ‰¾äº†ä¸€ç¯‡æœ‰ä»£ç çš„è®ºæ–‡çœ‹çœ‹å…ˆ.</p>
<p><a href="https://arxiv.org/pdf/2103.14951">A First Look at RISC-V Virtualization from anEmbedded Systems Perspective</a></p>
<p>è®ºæ–‡ä»“åº“:<a href="https://github.com/mit-pdos/RVirt">https://github.com/mit-pdos/RVirt</a></p>
<p><strong>What Needs to be Virtualized?</strong></p>
<p>1.Supervisor architectural state (i.e. CSRs)</p>
<p>2.Memory</p>
<p>3.I/O and Interrupts</p>
<p><strong>Virtualizing Memory</strong></p>
<p>Two-Level Address Translation</p>
<p>-Original virtual addresses translated to guest physical addresses by VS-level page table</p>
<p>-Guest physical addresses translated to machine physical addresses by HS-level page table</p>
<p>Same page-table entry format as S-mode</p>
<p>Same page-table layouts as S-mode (Sv32, 39, 48, ...)</p>
<p><strong>Virtualizing I/O and Interrupts</strong></p>
<p>Software &amp; Timer interrupts use SBI (=&gt; trivial)</p>
<p>Use two-level paging scheme to trap MMIO accesses </p>
<p>-Sufficient to emulate PLIC and other MMIO devices</p>
<p>Could avoid extra traps into hypervisor with virtualization</p>
<p>-aware PLIC-Platform issue, outside scope of hypervisor ISA</p>
<p>Need I/O MMU to initiate DMAs without trap into hypervisor</p>
<p>-Platform issue, outside scope of hypervisor ISA</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è™šæ‹ŸåŒ–å±‚æ¬¡</strong>
<img src="camp-daliy/./../Virtualization.png" alt="avatar" /></p>
<p>linux namespace cgroup</p>
<p>namesapce: å®‰å…¨éš”ç¦»  (MNT, UTS, IPC, PID, NET, User, Cgroup)</p>
<p>cgroup: æ€§èƒ½éš”ç¦» (task, cgroup, subsystem, hierarchy)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustç¬”è®°"><a class="header" href="#rustç¬”è®°">rustç¬”è®°</a></h1>
<h2 id="æ‰€æœ‰æƒ"><a class="header" href="#æ‰€æœ‰æƒ">æ‰€æœ‰æƒ</a></h2>
<h4 id="åŠ¨æ€å†…å­˜åˆ†é…"><a class="header" href="#åŠ¨æ€å†…å­˜åˆ†é…">åŠ¨æ€å†…å­˜åˆ†é…</a></h4>
<blockquote>
<p>1.åœ¨å †çš„æŸå¤„æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºä½,æŠŠå®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨,å¹¶è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥ä½ç½®åœ°å€çš„æŒ‡é’ˆ.
2.è·Ÿè¸ªå“ªéƒ¨åˆ†ä»£ç æ­£åœ¨ä½¿ç”¨å †ä¸Šçš„å“ªäº›æ•°æ®ï¼Œæœ€å¤§é™åº¦çš„å‡å°‘å †ä¸Šçš„é‡å¤æ•°æ®çš„æ•°é‡ï¼Œä»¥åŠæ¸…ç†å †ä¸Šä¸å†ä½¿ç”¨çš„æ•°æ®ç¡®ä¿ä¸ä¼šè€—å°½ç©ºé—´ï¼Œè¿™äº›é—®é¢˜æ­£æ˜¯æ‰€æœ‰æƒç³»ç»Ÿè¦å¤„ç†çš„</p>
</blockquote>
<h3 id="æ‰€æœ‰æƒè§„åˆ™"><a class="header" href="#æ‰€æœ‰æƒè§„åˆ™">æ‰€æœ‰æƒè§„åˆ™</a></h3>
<blockquote>
<ol>
<li>Rust ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªè¢«ç§°ä¸ºå…¶ <strong>æ‰€æœ‰è€…</strong>ï¼ˆ<em>owner</em>ï¼‰çš„å˜é‡ã€‚</li>
<li>å€¼åœ¨ä»»ä¸€æ—¶åˆ»æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚</li>
<li>å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒã€‚</li>
</ol>
</blockquote>
<h3 id="ç§»åŠ¨å’Œå…‹éš†"><a class="header" href="#ç§»åŠ¨å’Œå…‹éš†">ç§»åŠ¨å’Œå…‹éš†</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1; ---- å˜é‡ç§»åŠ¨åˆ°äº†s2ä¸­, s1å¤±æ•ˆ
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();  ---- å°†å †ä¸­çš„'helle'å¤åˆ¶äº†ä¸€ä»½, s1,s2åˆ†åˆ«æŒ‡å‘äº†ä¸åŒçš„å †ç©ºé—´,
                           ä½†æ˜¯å€¼éƒ½ä¸º'hello',é‡Šæ”¾çš„æ—¶å€™ä¹Ÿè¢«å½“æˆä¸¤ä¸ªç‹¬ç«‹çš„èµ„æº
<span class="boring">}
</span></code></pre></pre>
<p>Rust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€,ä¹Ÿå°±æ˜¯clone</p>
<h2 id="ç”Ÿå‘½å‘¨æœŸ"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸ">ç”Ÿå‘½å‘¨æœŸ</a></h2>
<h3 id="å¼•ç”¨"><a class="header" href="#å¼•ç”¨">å¼•ç”¨ &amp;</a></h3>
<p>å®ƒä»¬å…è®¸ä½ ä½¿ç”¨å€¼ä½†ä¸è·å–å…¶æ‰€æœ‰æƒã€‚</p>
<p>å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šåœ¨åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯¹æŸä¸€ç‰¹å®šæ•°æ®çš„å¯å˜å¼•ç”¨</p>
<p>&amp;s1 è¯­æ³•è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª æŒ‡å‘ å€¼ s1 çš„å¼•ç”¨ï¼Œä½†æ˜¯å¹¶ä¸æ‹¥æœ‰å®ƒã€‚å› ä¸ºå¹¶ä¸æ‹¥æœ‰è¿™ä¸ªå€¼ï¼Œæ‰€ä»¥å½“å¼•ç”¨åœæ­¢ä½¿ç”¨æ—¶ï¼Œå®ƒæ‰€æŒ‡å‘çš„å€¼ä¹Ÿä¸ä¼šè¢«ä¸¢å¼ƒã€‚</p>
<p>å˜é‡å…è®¸æ‹¥æœ‰å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œåªæ˜¯ä¸èƒ½åŒæ—¶æ‹¥æœ‰ï¼š
åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚</p>
<p>æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿåœ¨ç¨‹åºçš„ä¸€ä¸ªä½ç½®æŒ‡å®šæŸäº›ä»£ç ï¼Œå¹¶åªåœ¨ç¨‹åºçš„æŸå¤„å®é™…éœ€è¦ç»“æœçš„æ—¶å€™æ‰§è¡Œè¿™äº›ä»£ç ã€‚è¿™æ­£æ˜¯é—­åŒ…çš„ç”¨æ­¦ä¹‹åœ°ï¼</p>
<p>ç”Ÿå‘½å‘¨æœŸé¿å…äº†æ‚¬å‚å¼•ç”¨</p>
<p>è¢«å¼•ç”¨çš„å¯¹è±¡æ¯”å®ƒçš„å¼•ç”¨è€…å­˜åœ¨çš„æ—¶é—´æ›´çŸ­å¯èƒ½é€ æˆæ‚¬å‚å¼•ç”¨</p>
<h2 id="é—­åŒ…"><a class="header" href="#é—­åŒ…">é—­åŒ…</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//å®ç°äº†FnMut
let mut x = 5;
{
    let mut square_x = || x *= x;
    square_x();
}
assert_eq!(x, 25);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;hello&quot;;

//xçš„æ‰€æœ‰æƒäº¤ç»™äº†é—­åŒ… equal_to_x
let equal_to_x = move |z| z == x;
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>Fn</code>ç±»å‹é—­åŒ…</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let square = |x| x * x;
assert_eq!(square(5), 25);

//ä½¿ç”¨Fnå‚æ•°  
fn call_with_one&lt;F&gt;(func: F) -&gt; usize
    where F: Fn(usize) -&gt; usize {
    func(1)
}
let double = |x| x * 2;
assert_eq!(call_with_one(double), 2);
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>FnMut</code>ç±»å‹é—­åŒ…</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
{
    let mut square_x = || x *= x;
    square_x();
}
assert_eq!(x, 25);

//ä½¿ç”¨FnMutå‚æ•°
fn do_twice&lt;F&gt;(mut func: F)
    where F: FnMut()
{
    func();
    func();
}

let mut x: usize = 1;
{
    let add_two_to_x = || x += 2;
    do_twice(add_two_to_x);
}
assert_eq!(x, 5);
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>FnOnce</code>ç±»å‹é—­åŒ…</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//ä½¿ç”¨FnONceå‚æ•°
fn consume_with_relish&lt;F&gt;(func: F)
    where F: FnOnce() -&gt; String
{
    // `func` consumes its captured variables, so it cannot be run more
    // than once.
    println!(&quot;Consumed: {}&quot;, func());
///
    println!(&quot;Delicious!&quot;);
///
    // Attempting to invoke `func()` again will throw a `use of moved
    // value` error for `func`.
}
///
let x = String::from(&quot;x&quot;);
let consume_and_return_x = move || x;
consume_with_relish(consume_and_return_x);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•"><a class="header" href="#-rustå­¦ä¹ è®°å½•">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-foo"><a class="header" href="#-foo">ğŸš§ foo</a></h1>
<p><strong>è®°å½•ä¸€äº›æ–°æŠ€èƒ½</strong></p>
<p><strong>docker</strong>
åœ¨é…ç½®github+gitpodä¸­å­¦ä¹ äº†dockerçš„åŸºæœ¬ç”¨æ³•åŒ…æ‹¬imageç”Ÿæˆ.containerä½¿ç”¨</p>
<p><br/> </br></p>
<p><strong>è·å–åŸºç¡€é•œåƒ</strong></p>
<p>å¦‚æœæˆ‘ä»¬æœ¬åœ°æ²¡æœ‰ ubuntu é•œåƒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ docker pull å‘½ä»¤æ¥è½½å…¥ ubuntu é•œåƒ</p>
<pre><code class="language-shell">$ docker pull ubuntu
</code></pre>
<p><strong>å¯åŠ¨å®¹å™¨</strong></p>
<pre><code>$ docker run -it ubuntu /bin/bash
</code></pre>
<p><strong>å®‰è£…ç¯å¢ƒ(ç•¥)</strong></p>
<p><strong>æ¨é€é•œåƒåˆ°Docker Hub</strong></p>
<p>éœ€è¦åœ¨docker hubä¸Šæ³¨å†Œè´¦æˆ·,åˆ›å»ºä»“åº“</p>
<p>ç™»å…¥docker</p>
<pre><code class="language-shell">$ docker login 
</code></pre>
<p>ä¿®æ”¹æ ‡ç­¾</p>
<pre><code class="language-shell">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
</code></pre>
<p>æ¨é€</p>
<pre><code class="language-shell">$ docker push username/repository:[tag]
</code></pre>
<p><strong>æŸ¥çœ‹æœ¬åœ°å®¹å™¨,é•œåƒ</strong></p>
<pre><code class="language-shell">$ docker images
$ docker ps -a
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

                <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
