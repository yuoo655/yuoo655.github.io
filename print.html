<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ÂºÄÂßã‰πãÂâç</a></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">1.</strong> üöß rustÂ≠¶‰π†ËÆ∞ÂΩï</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="daliy/7-2.html"><strong aria-hidden="true">1.1.</strong> 7.2</a></li><li class="chapter-item expanded "><a href="daliy/7-3.html"><strong aria-hidden="true">1.2.</strong> 7.3</a></li><li class="chapter-item expanded "><a href="daliy/7-4.html"><strong aria-hidden="true">1.3.</strong> 7.4</a></li><li class="chapter-item expanded "><a href="daliy/7-5.html"><strong aria-hidden="true">1.4.</strong> 7.5</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">2.</strong> üöß tutorialÂ≠¶‰π†</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="daliy/7-6.html"><strong aria-hidden="true">2.1.</strong> 7.6</a></li><li class="chapter-item expanded "><a href="daliy/7-7.html"><strong aria-hidden="true">2.2.</strong> 7.7</a></li><li class="chapter-item expanded "><a href="daliy/7-8.html"><strong aria-hidden="true">2.3.</strong> 7.8</a></li><li class="chapter-item expanded "><a href="daliy/7-10.html"><strong aria-hidden="true">2.4.</strong> 7.9-7.10 Â§öÊ†∏ÊîØÊåÅ</a></li><li class="chapter-item expanded "><a href="daliy/7-11.html"><strong aria-hidden="true">2.5.</strong> 7.11</a></li><li class="chapter-item expanded "><a href="daliy/7-13.html"><strong aria-hidden="true">2.6.</strong> 7.13</a></li><li class="chapter-item expanded "><a href="daliy/7-14.html"><strong aria-hidden="true">2.7.</strong> 7.14</a></li><li class="chapter-item expanded "><a href="daliy/7-15.html"><strong aria-hidden="true">2.8.</strong> 7.15</a></li><li class="chapter-item expanded "><a href="daliy/7-16.html"><strong aria-hidden="true">2.9.</strong> 7.16</a></li><li class="chapter-item expanded "><a href="daliy/7-17.html"><strong aria-hidden="true">2.10.</strong> 7.17</a></li><li class="chapter-item expanded "><a href="daliy/7-18.html"><strong aria-hidden="true">2.11.</strong> 7.18</a></li><li class="chapter-item expanded "><a href="daliy/7-19.html"><strong aria-hidden="true">2.12.</strong> 7.19</a></li><li class="chapter-item expanded "><a href="daliy/7-20.html"><strong aria-hidden="true">2.13.</strong> 7.20</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">3.</strong> üöß c2rust</a></li><li class="chapter-item expanded "><a href="foo.html"><strong aria-hidden="true">4.</strong> üöß foo</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="os-camp-2021-ÊØèÊó•Â≠¶‰π†ÂÆûË∑µËøáÁ®ãËÆ∞ÂΩï"><a class="header" href="#os-camp-2021-ÊØèÊó•Â≠¶‰π†ÂÆûË∑µËøáÁ®ãËÆ∞ÂΩï">OS Camp 2021 ÊØèÊó•Â≠¶‰π†ÂÆûË∑µËøáÁ®ãËÆ∞ÂΩï</a></h2>
<p>‰ªìÂ∫ìÈìæÊé•:<a href="https://codechina.csdn.net/weixin_49256325/os_camp">https://codechina.csdn.net/weixin_49256325/os_camp</a></p>
<p><strong>‰∏ÉÊúà</strong></p>
<table><thead><tr><th>Mon</th><th>Tues</th><th>Wed</th><th>Thur</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody>
<tr><td></td><td></td><td>1 <br>(<a href="c2rust.html">C2RUST</a>)</td><td>2 <br>(<a href="daliy/7-2.html">D1</a>)</td><td>3 <br>(<a href="daliy/7-3.html">D2</a>)</td><td>4 <br>(<a href="daliy/7-4.html">D3</a>)</td><td>5 <br>(<a href="daliy/7-5.html">D4</a>)</td></tr>
<tr><td>6<br>(<a href="daliy/7-6.html">D5</a>)</td><td>7 <br>(<a href="daliy/7-7.html">D6</a>)</td><td>8 <br>(<a href="daliy/7-8.html">D7</a>)</td><td>9  <br>(<a href="daliy/7-10.html">D9</a>)</td><td>10 <br> (<a href="daliy/7-10.html">D9</a>)</td><td>11 <br></td><td>12 <br></td></tr>
<tr><td>13<br>(<a href="daliy/7-13.html">D12</a>)</td><td>14 <br>(<a href="daliy/7-14.html">D13</a>)</td><td>15 <br>(<a href="daliy/7-15.html">D14</a>)</td><td>16 <br>(<a href="daliy/7-16.html">D15</a>)</td><td>17 <br>(<a href="daliy/7-17.html">D16</a>)</td><td>18 <br>(<a href="daliy/7-18.html">D17</a>)</td><td>19<br>(<a href="daliy/7-18.html">D18</a>)</td></tr>
<tr><td>20<br>(<a href="daliy/7-19.html">D19</a>)</td><td>21 <br></td><td>22 <br></td><td>23 <br></td><td>24 <br></td><td>25 <br></td><td>26 <br></td></tr>
<tr><td>27 <br></td><td>28 <br></td><td>29 <br></td><td>30 <br></td><td>31 <br></td><td></td><td></td></tr>
</tbody></table>
<p><strong>ÂÖ´Êúà</strong></p>
<table><thead><tr><th>Mon</th><th>Tues</th><th>Wed</th><th>Thur</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td></td><td></td><td>1  <br></td><td>2  <br></td></tr>
<tr><td>3  <br></td><td>4  <br></td><td>5  <br></td><td>6  <br></td><td>7  <br></td><td>8  <br></td><td>9  <br></td></tr>
<tr><td>10 <br></td><td>11 <br></td><td>12 <br></td><td>13 <br></td><td>14 <br></td><td>15 <br></td><td>16 <br></td></tr>
<tr><td>17 <br></td><td>18 <br></td><td>19 <br></td><td>20 <br></td><td>21 <br></td><td>22 <br></td><td>23 <br></td></tr>
<tr><td>24 <br></td><td>25 <br></td><td>26 <br></td><td>27 <br></td><td>28 <br></td><td>29 <br></td><td>30 <br></td></tr>
<tr><td>31 <br></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h2 id="a-hrefdaliy5c7-1htmlc2rusta‰∏ªË¶ÅËÆ∞ÂΩïÁßªÊ§çfilex‰∏≠‰∏Ä‰∫õcËØ≠Ë®Ä‰ª£Á†ÅËΩ¨Êç¢‰∏∫rust‰ª£Á†ÅÁöÑ‰∏Ä‰∫õÂ∞ùËØï"><a class="header" href="#a-hrefdaliy5c7-1htmlc2rusta‰∏ªË¶ÅËÆ∞ÂΩïÁßªÊ§çfilex‰∏≠‰∏Ä‰∫õcËØ≠Ë®Ä‰ª£Á†ÅËΩ¨Êç¢‰∏∫rust‰ª£Á†ÅÁöÑ‰∏Ä‰∫õÂ∞ùËØï"><a href="daliy%5C7-1.html">c2rust</a>‰∏ªË¶ÅËÆ∞ÂΩïÁßªÊ§çfilex‰∏≠‰∏Ä‰∫õcËØ≠Ë®Ä‰ª£Á†ÅËΩ¨Êç¢‰∏∫rust‰ª£Á†ÅÁöÑ‰∏Ä‰∫õÂ∞ùËØï</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustÂ≠¶‰π†ËÆ∞ÂΩï"><a class="header" href="#-rustÂ≠¶‰π†ËÆ∞ÂΩï">üöß rustÂ≠¶‰π†ËÆ∞ÂΩï</a></h1>
<h2 id="ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞"><a class="header" href="#ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞">ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞</a></h2>
<p><strong>Áúã‰∏Ä‰∏™cËØ≠Ë®Ä‰æãÂ≠ê</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>‰ª•‰∏ãÊòØrustÂÆûÁé∞</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setp0------rustÁªÉ‰π†---a-hrefhttpsgithubcomrust-langrustlingsrustlingsafont"><a class="header" href="#setp0------rustÁªÉ‰π†---a-hrefhttpsgithubcomrust-langrustlingsrustlingsafont">setp0 ---- rustÁªÉ‰π† -&gt; <a href="https://github.com/rust-lang/rustlings">rustlings</a></font></a></h1>
<hr />
<p><strong>AsRef&lt;T&gt;</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
   assert_eq!(&quot;hello&quot;, s.as_ref());
}
let s = &quot;hello&quot;;
is_hello(s);
<span class="boring">}
</span></code></pre></pre>
<p><strong>as_ref()</strong> ‰∏çËÉΩÂá∫Èîô, Âê¶ÂàôÂ∞±ÈúÄË¶ÅÁî® <strong>Option<T> or a Result&lt;T,E&gt;</strong> ÂΩ¢Âºè</p>
<p></br> <br/>
<strong>enmu match ÁªÑÂêà</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Move(Point),
    Echo(String),
    ChangeColor((u8, u8, u8)),
    Quit,
}
fn process(&amp;mut self, message: Message) {
    match message {
        Message::Move(value) =&gt; {
            self.move_position(value) 
        }
        Message::ChangeColor(value) =&gt; {
            self.change_color(value) 
        }
        Message::Echo(value) =&gt;{
            self.echo(value)
        }
        Message::Quit =&gt;{self.quit()}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ÂÖ∂‰∏≠<strong>value</strong>ÊòØÊûö‰∏æÊàêÂëò‰∏≠ÂåÖÂê´ÁöÑ‰ªªÊÑèÁ±ªÂûãÂÄº, Â¶ÇÊûúÊûö‰∏æÊàêÂëò‰∏≠Êúâ2‰∏™‰ª•‰∏äÂèòÈáèÂèØÁî® <strong>( _, _, value)</strong> ÂΩ¢ÂºèÊèêÂèñ‰ªªÊÑèÂèòÈáè</p>
<p></br><br>
<strong>mainÂáΩÊï∞‰πüÂèØËøîÂõû'Result'</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt;Result&lt;(), E&gt;{
    let cost = xxxxxxxxxxxxxx?;
    Ok(())
}
</code></pre></pre>
<p></br> <br/></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ÂÆåÊàê‰∫ÜrustlingsÁªÉ‰π†,ÈÄâÂá†‰∏™È¢òÁõÆËÆ∞ÂΩï‰∏Ä‰∏ã,ÁÑ∂ÂêéÊâìÁÆóÂºÑ‰∏Ä‰∏ãgithub+gitpod</strong></p>
<p></br><br>
<strong>Âêå‰∏Ä‰∏™ÂÆè‰∏≠‰πüÂèØÁî® ;  ÈöîÂºÄÊù•ÂåπÈÖç‰∏çÂêåÁöÑËæìÂÖ•</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
    ($val:expr) =&gt; {
        println!(&quot;Look at this other macro: {}&quot;, $val);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p></br><br>
<strong>Áî®foldÊñπÊ≥ïÂÆûÁé∞Èò∂‰πò</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1..num + 1).fold(1, |acc, x| acc * x)
<span class="boring">}
</span></code></pre></pre>
<p></br><br>
<strong>Arc&lt;Mutex&lt;&gt;&gt;</strong>
</br><br>
ÂçïÁã¨Arc-&gt;‰∏çÂèØÂèòÂºïÁî®...‰ΩÜÊòØ‰øùËØÅ‰∫íÊñ•ËÆøÈóÆÂ§öÂçäÊòØÈúÄË¶Å‰øÆÊîπÂèòÈáèÁöÑ.Âèà‰∏çÂæó‰∏çÂä†‰∏äMutex.ÂΩ¢Êàê‰∫ÜËøô‰∏ÄÁªèÂÖ∏ÁªÑÂêà</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
let status_shared = status.clone();
thread::spawn(move || {
    for _ in 0..10 {
        thread::sleep(Duration::from_millis(250));
        status_shared.lock().unwrap().jobs_completed += 1;
    }
});
<span class="boring">}
</span></code></pre></pre>
<p><br></br></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>setp0-3.2</strong></p>
<p>3.2Ë¶ÅÊ±Ç:Áî®rustÂÆûÁé∞cËØ≠Ë®Ä‰æãÂ≠ê</p>
<p><strong>ÊÄªÁªì</strong>:cËØ≠Ë®Ä‰∏≠ÊåáÈíàÁöÑ‰∏Ä‰∫õ‰ΩøÁî®ÂæÄÂæÄÂú®rust‰∏≠Ê≤°ÊúâÁâπÂà´Â•ΩÁöÑÂØπÂ∫î,ËøôÊó∂ÂÄôÊúÄÂ•ΩÊõ¥ÊîπÊï∞ÊçÆÁªìÊûÑ,Êìç‰ΩúÊñπÂºèÊù•ËææÂà∞Áõ∏ÂêåÂäüËÉΩ.</p>
<p>‰∏çËÉΩÂæàÂ•ΩÂØπÂ∫îÁöÑÊÉÖÂΩ¢Êúâ:</p>
<p>1.Áî®ÊåáÈíàÂÅöÁ¥¢Âºï</p>
<p>2.if (ÊüêÊåáÈíà) Á≠âÂÅöÂà§Êñ≠</p>
<p><strong>‰æã:</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    // create two arrays we care about
    int ages[] = {23, 43, 12, 89, 2};
    char *names[] = {
        &quot;Alan&quot;, &quot;Frank&quot;,
        &quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;
    };
    // safely get the size of ages
    int count = sizeof(ages) / sizeof(int);
    int i = 0;
    // first way using indexing
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s has %d years alive.\n&quot;,
                names[i], ages[i]);
    }
    // setup the pointers to the start of the arrays
    int *cur_age = ages;
    char **cur_name = names;
    // second way using pointers
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old.\n&quot;,
                *(cur_name+i), *(cur_age+i));
    }
    // third way, pointers are just arrays
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old again.\n&quot;,
                cur_name[i], cur_age[i]);
    }
    // fourth way with pointers in a stupid complex way
    for(cur_name = names, cur_age = ages;
            (cur_age - ages) &lt; count;
            cur_name++, cur_age++)
    {
        printf(&quot;%s lived %d years so far.\n&quot;,
                *cur_name, *cur_age);
    }
    return 0;
}
</code></pre>
<p>Â¶ÇÊûúÁîüÁ°¨ÁøªËØëÊàêrust</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::*;

fn main() {

    let mut ages = [23,43,12,89,2];
    let mut names = [&quot;Alan&quot;, &quot;Frank&quot;,&quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;];

    let count = size_of_val(&amp;ages) / size_of::&lt;i32&gt;();
    // let count = ages.len();

    for i in 0..count {
        println!(&quot;{} has {} years alive.&quot;,names[i], ages[i]);
    }
    println!(&quot;----\n&quot;);
    let cur_age = ages.as_mut_ptr();
    let cur_name = names.as_mut_ptr();
    
    for i in 0..count{
        unsafe {
            println!(&quot;{} is {} years old.&quot;, 
            *cur_name.offset(i as isize), 
            *cur_age.offset(i as isize));
        }
    }
    println!(&quot;----\n&quot;);

    unsafe { 
        let cur_age1 = core::slice::from_raw_parts_mut(ages.as_ptr() as *mut i32, count);
        for i in 0..count{
            println!(&quot;xxxx is {} years old.&quot;,  cur_age1[i])
        }
    }
    
}
</code></pre></pre>
<p>ÁõÆÂâçÊî∂ÈõÜÂà∞ÁöÑÊñπÊ≥ïÊúâ:</p>
<p>1.ÂæóÂà∞‰∏Ä‰∏™ÂèØÂØπÊï∞ÊçÆËøõË°å‰øÆÊîπÁöÑÊåáÈíà  ÁÑ∂Âêé‰ª•Â≠óËäÇÂçï‰ΩçËÆ°ÁÆóÂÅèÁßªÈáè.‰∏çËÉΩË∂ÖËøáisizeÂ§ßÂ∞è.Êù•ËææÂà∞Á¥¢Âºï</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cur_age = ages.as_mut_ptr()   
*cur_name.offset(i as isize)      
<span class="boring">}
</span></code></pre></pre>
<p>2.ÂæóÂà∞‰∏Ä‰∏™i32Á±ªÂûãÈïøÂ∫¶‰∏∫countÁ±ªÂûãÁöÑslice.ÂèØ‰ª•ÁêÜËß£‰∏∫Âõ∫ÂÆöÂ§ßÂ∞èÊï∞ÁªÑ.</p>
<p>Ê≠§ÊñπÊ≥ïÂØπÂ≠óÁ¨¶‰∏≤Êï∞ÁªÑÊó†Êïà...ÂèØËÉΩÂéüÂõ†:Â≠óÁ¨¶‰∏≤Â§ßÂ∞è‰∏çÂõ∫ÂÆö.Êó†Ê≥ïÂáÜÁ°ÆËÆ°ÁÆóÂ§ßÂ∞è??</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>from_raw_parts_mut(ages.as_ptr() as *mut i32, count)
<span class="boring">}
</span></code></pre></pre>
<p><strong>Êõ¥Â§öÊúâÂÖ≥ÂéüÂßãÊåáÈíàÂèØÊü•ÈòÖÂÆòÊñπÊñáÊ°£</strong>:<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset">https://doc.rust-lang.org/std/primitive.pointer.html#method.offset</a></p>
<p>ËØ•ÊñáÊ°£Á¨¨‰∏ÄÂè•ËØù<strong>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</strong></p>
<p>Âú®ÊúâÊõø‰ª£ÊñπÊ≥ïÊó∂ÂÄôËøòÊòØÂª∫ËÆÆÈÅøÂÖç‰ΩøÁî®.</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>leetcode</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//ÂêàÂπ∂‰∏§‰∏™ÊúâÂ∫èÈìæË°®:https://leetcode-cn.com/problems/merge-two-sorted-lists/
pub fn merge_two_lists(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        match (l1, l2) {
            (Some(n1), None) =&gt; Some(n1),
            (None, Some(n2)) =&gt; Some(n2),

            (Some(mut n1), Some(mut n2)) =&gt; {
                if n1.val &lt; n2.val {
                    let n = n1.next.take();
                    n1.next = merge_two_lists(n, Some(n2));
                    Some(n1)
                } else {
                    let n = n2.next.take();
                    n2.next = merge_two_lists(Some(n1), n);
                    Some(n2)
                }
            },
            _ =&gt; None,
        }
}
<span class="boring">}
</span></code></pre></pre>
<p>matchÂèØ‰ª•Êé•ÂèóÂ§ö‰∏™ÂÄº.‰ª•ÂÖÉÁªÑÂΩ¢ÂºèÂ≠òÂú®</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustÂ≠¶‰π†ËÆ∞ÂΩï-1"><a class="header" href="#-rustÂ≠¶‰π†ËÆ∞ÂΩï-1">üöß rustÂ≠¶‰π†ËÆ∞ÂΩï</a></h1>
<h2 id="ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞-1"><a class="header" href="#ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞-1">ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞</a></h2>
<p><strong>Áúã‰∏Ä‰∏™cËØ≠Ë®Ä‰æãÂ≠ê</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>‰ª•‰∏ãÊòØrustÂÆûÁé∞</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="76"><a class="header" href="#76">7.6</a></h1>
<p><strong>ÂºÄÂßãtutorial!</strong></p>
<p><strong>‰ΩøÁî®ÈìæÊé•ËÑöÊú¨ÊåáÂÆöÁ®ãÂ∫èÂÜÖÂ≠òÂ∏ÉÂ±Ä</strong></p>
<p>‰∏ÄËà¨Êù•ËØ¥Ôºå‰∏Ä‰∏™Á®ãÂ∫èÊåâÁÖßÂäüËÉΩ‰∏çÂêå‰ºöÂàÜ‰∏∫‰∏ãÈù¢Ëøô‰∫õÊÆµÔºö</p>
<table><tr><td bgcolor=#EFF5FF>
.text ÊÆµÔºåÂç≥‰ª£Á†ÅÊÆµÔºåÂ≠òÊîæ‰ª£Á†Å Âá∫ÈîôÊó∂ÂÄôÁöÑeipÂæÄÂæÄÂú®Ëøô‰∏™ÊÆµ.ÊåáÂêëÊüê‰∏ÄÊù°ËØ≠Âè•.‰ª•Ê≠§Êù•ÂÆö‰ΩçÈóÆÈ¢òÔºõ
<p>.rodata ÊÆµÔºåÂç≥Âè™ËØªÊï∞ÊçÆÊÆµÔºåÈ°æÂêçÊÄù‰πâÈáåÈù¢Â≠òÊîæÂè™ËØªÊï∞ÊçÆÔºåÈÄöÂ∏∏ÊòØÁ®ãÂ∫è‰∏≠ÁöÑÂ∏∏ÈáèÔºõ</p>
<p>.data ÊÆµÔºåÂ≠òÊîæË¢´ÂàùÂßãÂåñÁöÑÂèØËØªÂÜôÊï∞ÊçÆÔºåÈÄöÂ∏∏‰øùÂ≠òÁ®ãÂ∫è‰∏≠ÁöÑÂÖ®Â±ÄÂèòÈáèÔºõ</p>
<p>.bss ÊÆµÔºåÂ≠òÊîæË¢´ÂàùÂßãÂåñ‰∏∫ 00 ÁöÑÂèØËØªÂÜôÊï∞ÊçÆÔºå‰∏é .data ÊÆµÁöÑ‰∏çÂêå‰πãÂ§ÑÂú®‰∫éÊàë‰ª¨Áü•ÈÅìÂÆÉË¶ÅË¢´ÂàùÂßãÂåñ‰∏∫ 00 ÔºåÂõ†Ê≠§Âú®ÂèØÊâßË°åÊñá‰ª∂‰∏≠Âè™ÈúÄËÆ∞ÂΩïËøô‰∏™ÊÆµÁöÑÂ§ßÂ∞è‰ª•ÂèäÊâÄÂú®‰ΩçÁΩÆÂç≥ÂèØÔºåËÄå‰∏çÁî®ËÆ∞ÂΩïÈáåÈù¢ÁöÑÊï∞ÊçÆ„ÄÇ</p>
<p>stack ÔºåÂç≥Ê†àÔºåÁî®Êù•Â≠òÂÇ®Á®ãÂ∫èËøêË°åËøáÁ®ã‰∏≠ÁöÑÂ±ÄÈÉ®ÂèòÈáèÔºå‰ª•ÂèäË¥üË¥£ÂáΩÊï∞Ë∞ÉÁî®Êó∂ÁöÑÂêÑÁßçÊú∫Âà∂„ÄÇÂÆÉ‰ªéÈ´òÂú∞ÂùÄÂêë‰ΩéÂú∞ÂùÄÂ¢ûÈïøÔºõ</p>
<p>heap ÔºåÂç≥Â†ÜÔºåÁî®Êù•ÊîØÊåÅÁ®ãÂ∫è<b><font color=#42ACF4>ËøêË°åËøáÁ®ã</font></b>‰∏≠ÂÜÖÂ≠òÁöÑÂä®ÊÄÅÂàÜÈÖçÔºåÊØîÂ¶ÇËØ¥‰Ω†Ë¶ÅËØªËøõÊù•‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÔºåÂú®‰Ω†ÂÜôÁ®ãÂ∫èÁöÑÊó∂ÂÄô‰Ω†‰πü‰∏çÁü•ÈÅìÂÆÉÁöÑÈïøÂ∫¶Á©∂Á´ü‰∏∫Â§öÂ∞ëÔºå‰∫éÊòØ‰Ω†Âè™ËÉΩÂú®ËøêË°åËøáÁ®ã‰∏≠ÔºåÁü•ÈÅì‰∫ÜÂ≠óÁ¨¶‰∏≤ÁöÑÈïøÂ∫¶‰πãÂêéÔºåÂÜçÂú®Â†Ü‰∏≠ÁªôËøô‰∏™Â≠óÁ¨¶‰∏≤ÂàÜÈÖçÂÜÖÂ≠ò„ÄÇ</p>
</td></tr></table>
<p>ÈìæÊé•ËÑöÊú¨Á§∫‰æã:</p>
<pre><code class="language-linker">
SECTIONS
{
. = 0x10000;
.text : { *(.text) }
. = 0x8000000;
.data : { *(.data) }
.bss : { *(.bss) }
}
</code></pre>
<p><b></b>
. Ë°®Á§∫Ëµ∑ÂßãÂú∞ÂùÄ Â¶ÇÊûúÊ≤°ÊúâËøô‰∏™Âú∞ÂùÄÔºåÈªòËÆ§ËØ•Á¨¶Âè∑ÁöÑÂÄº‰∏∫0</p>
<p>.text : { *(.text) } : Â∞ÜÊâÄÊúâ(*Á¨¶Âè∑‰ª£Ë°®‰ªªÊÑèËæìÂÖ•Êñá‰ª∂)Êñá‰ª∂ÁöÑ.text sectionÂêàÂπ∂Êàê‰∏Ä‰∏™.text section,ËØ•sectionÁöÑÂú∞ÂùÄÁî±ÂÆö‰ΩçÂô®Á¨¶Âè∑ÁöÑÂÄºÊåáÂÆö, Âç≥0x10000.</p>
<p>. = 0x8000000 ÔºöÊääÂÆö‰ΩçÂô®Á¨¶Âè∑ÁΩÆ‰∏∫0x8000000</p>
<p>.data : { *(.data) } : Âêå‰∏ä</p>
<p>.bss : { *(.bss) } :  Âêå‰∏ä</p>
<p><strong>ÂÖ∂‰ªñÂëΩ‰ª§</strong>
ENTRY(SYMBOL) :Â∞ÜÁ¨¶Âè∑SYMBOLÁöÑÂÄºËÆæÁΩÆÊàêÂÖ•Âè£Âú∞ÂùÄ„ÄÇ</p>
<p>INCLUDE filename : ÂåÖÂê´ÂÖ∂‰ªñÂêç‰∏∫filenameÁöÑÈìæÊé•ËÑöÊú¨</p>
<p>INPUT(files): Â∞ÜÊã¨Âè∑ÂÜÖÁöÑÊñá‰ª∂ÂÅö‰∏∫ÈìæÊé•ËøáÁ®ãÁöÑËæìÂÖ•Êñá‰ª∂</p>
<p>GROUP(files) : ÊåáÂÆöÈúÄË¶ÅÈáçÂ§çÊêúÁ¥¢Á¨¶Âè∑ÂÆö‰πâÁöÑÂ§ö‰∏™ËæìÂÖ•Êñá‰ª∂</p>
<p>OUTPUT(FILENAME) : ÂÆö‰πâËæìÂá∫Êñá‰ª∂ÁöÑÂêçÂ≠ó</p>
<p>SEARCH_DIR(PATH) ÔºöÂÆö‰πâÊêúÁ¥¢Ë∑ØÂæÑÔºå</p>
<p>OUTPUT_ARCH() : ËÆæÁΩÆËæìÂá∫Êñá‰ª∂ÁöÑ‰ΩìÁ≥ªÁªìÊûÑ</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>pythonÁîüÊàêÈìæÊé•ËÑöÊú¨,‰ª•ÂèäÁî®Êà∑Á®ãÂ∫èbuild</strong></p>
<p>Â§ö‰∏™Áî®Êà∑Á®ãÂ∫èbuild</p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()
for app in apps:
    app = app[:app.find('.')]
    lines = []
    lines_before = []
    with open(linker, 'r') as f:
        for line in f.readlines():
            lines_before.append(line)
            line = line.replace(hex(base_address), hex(base_address+step*app_id))
            lines.append(line)
    with open(linker, 'w+') as f:
        f.writelines(lines)
    os.system('cargo build --bin %s --release' % app)
    print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
    with open(linker, 'w+') as f:
        f.writelines(lines_before)
    app_id = app_id + 1

</code></pre>
<p><strong>ÁîüÊàêbinÊñá‰ª∂...objcopy</strong></p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()

for app in apps:
    app = app.strip('.rs')
    os.system('rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/%s --strip-all -O binary  target/riscv64gc-unknown-none-elf/release/%s.bin'%(app,app))
</code></pre>
<p><strong>ÁîüÊàêÈìæÊé•ËÑöÊú¨link_app.S  ÁõÆÂΩï‰∏ãÊâÄÊúâbinÊñá‰ª∂ÂÜôËøõÈìæÊé•ËÑöÊú¨</strong></p>
<pre><code class="language-python">import os


f = open('link_app.S', 'w')

f.writelines(&quot;    .align 3\n&quot;)
f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global _num_app\n&quot;)
f.writelines(&quot;_num_app:\n&quot;)
apps = os.listdir('target/riscv64gc-unknown-none-elf/release')
num = 0

bin_list = []
for app in apps:
    if 'bin' in app:
        num += 1
        bin_list.append(app)

f.writelines(&quot;    .quad %s\n&quot; %len(bin_list))

count  = 0
for app in bin_list:
    f.writelines(&quot;    .quad app_%s_start\n&quot; %count)
    count += 1

f.writelines(&quot;\n&quot;)

f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global app_0_start\n&quot;)
f.writelines(&quot;    .global app_0_end\n&quot;)

for i in range(len(bin_list)):
    f.writelines(&quot;app_%s_start:\n&quot; %i)
    f.writelines(&quot;    .incbin \&quot;../test/target/riscv64gc-unknown-none-elf/release/%s\&quot;\n&quot; %bin_list[i])
    f.writelines(&quot;app_%s_end:\n\n&quot; %i)
    
f.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Êìç‰ΩúÁ≥ªÁªüÂ§öÊ†∏ÊîØÊåÅ"><a class="header" href="#Êìç‰ΩúÁ≥ªÁªüÂ§öÊ†∏ÊîØÊåÅ">Êìç‰ΩúÁ≥ªÁªüÂ§öÊ†∏ÊîØÊåÅ</a></h1>
<p>Âú®intelÊâãÂÜå8.4 MULTIPLE-PROCESSOR (MP) INITIALIZATION ÂèØÊü•Âà∞Â§öÊ†∏ÂêØÂä®Áõ∏ÂÖ≥‰ø°ÊÅØ.</p>
<font size = 3> 
8.4.1 BSP and AP Processors
The MP initialization protocol defines two classes of processors: the bootstrap processor (BSP) and the application
processors (APs). Following a power-up or RESET of an MP system, system hardware dynamically selects one of the
processors on the system bus as the BSP. The remaining processors are designated as APs.
As part of the BSP selection mechanism, the BSP flag is set in the IA32_APIC_BASE MSR (see Figure 10-5) of the
BSP, indicating that it is the BSP. This flag is cleared for all other processors.
The BSP executes the BIOS‚Äôs boot-strap code to configure the APIC environment, sets up system-wide data structures, and starts and initializes the APs. When the BSP and APs are initialized, the BSP then begins executing the
operating-system initialization code.
</font>
<br></br>
<font size = 3> 
Following a power-up or reset, the APs complete a minimal self-configuration, then wait for a startup signal (a SIPI
message) from the BSP processor. Upon receiving a SIPI message, an AP executes the BIOS AP configuration code,
which ends with the AP being placed in halt state.
For Intel 64 and IA-32 processors supporting Intel Hyper-Threading Technology, the MP initialization protocol treats
each of the logical processors on the system bus or coherent link domain as a separate processor (with a unique
APIC ID). During boot-up, one of the logical processors is selected as the BSP and the remainder of the logical
processors are designated as APs.
</font>
<p>Âú®ÂêØÂä®Êó∂ÂÄô.‰ºöÈÄâÂá∫‰∏Ä‰∏™Ê†∏‰Ωú‰∏∫BSP. ÂêåÊó∂ËÆæÁΩÆÂÖ∂‰ªñÊ†∏(APs)ÁöÑflag‰ø°ÊÅØ.ÁÑ∂ÂêéÁî±BSPÊù•ÊâßË°åÂàùÂßãÂåñÂÖ∂‰ªñÊ†∏(APs). ÂΩìBSPÂíåAPsÈÉΩÂàùÂßãÂåñÂÆåÊàêÂêé,Áî±BSPÊù•ÊâßË°åÁ≥ªÁªüÂàùÂßãÂåñ‰ª£Á†Å</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Â≠¶‰π†Â§öÊ†∏ÂêØÂä®ÊîØÊåÅ</strong></p>
<p><strong>ÂèÇËÄÉÂ∑≤ÊúâÁöÑÂÆûÁé∞</strong></p>
<p>‰∏ªË¶ÅÁúãÈìæÊé•ËÑöÊú¨‰∏≠ÊåáÂÆöÁöÑÂÖ•Âè£Ê±áÁºñ‰ª£Á†Å,‰ª•ÂèäÊé•‰∏ãÊù•Ë∑≥ËΩ¨Âà∞ÁöÑ‰ª£Á†Å</p>
<p>1.rcore</p>
<pre><code class="language-x86asm">    .section .text.entry
    .globl _start
_start:
    # a0 == hartid
    # pc == 0x80200000
    # sp == 0x800xxxxx

    # 1. set sp
    # sp = bootstack + (hartid + 1) * 0x10000
    add     t0, a0, 1
    slli    t0, t0, 14
    lui     sp, %hi(bootstack)
    add     sp, sp, t0

....(Áï•)

    # 3. jump to rust_main (absolute address)
    lui     t0, %hi(rust_main)
    addi    t0, t0, %lo(rust_main)
    jr      t0

    .section .bss.stack
    .align 12   # page align
    .global bootstack
bootstack:
    .space 4096 * 4 * 8
    .global bootstacktop
bootstacktop:

    .section .data
    .align 12   # page align
....(Áï•)
</code></pre>
<p><strong>Âä†ËΩΩÂ∏∏ÈáèÂà∞ÊüêÂØÑÂ≠òÂô®Â∏∏Áî®ÁöÑÊ±áÁºñ‰ª£Á†Å</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(constant)
addi    t0, t0, %lo(constant)
</code></pre>
<p><strong>Âä†ËΩΩÁªùÂØπÂú∞ÂùÄÂà∞ÊüêÂØÑÂ≠òÂô®</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(address)
addi    t0, t0, %lo(address)
</code></pre>
<p>Êúâ‰∫ÜËøô‰∏™Âü∫Á°ÄËøôÊÆµ‰ª£Á†ÅÂ∞±Â•ΩÁêÜËß£‰∫Ü
‰∏∫ÂΩìÂâçÊ†∏ÂøÉËÆæÁΩÆ‰∏Ä‰∏™Ê†à,Âú∞ÂùÄ‰∏∫:sp = bootstack + (hartid + 1) * 0x10000
ÂÜçË∑≥ËΩ¨Âà∞rust_main....</p>
<p><strong>next:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn rust_main(hartid: usize, device_tree_paddr: usize) -&gt; ! {
    let device_tree_vaddr = phys_to_virt(device_tree_paddr);

    unsafe {
        cpu::set_cpu_id(hartid);
    }

    if hartid != BOOT_HART_ID {
        while !AP_CAN_INIT.load(Ordering::Relaxed) {}
        others_main(hartid);
    }

    unsafe {
        memory::clear_bss();
    }

    println!(
        &quot;Hello RISCV! in hart {}, device tree @ {:#x}&quot;,
        hartid, device_tree_vaddr
    );

    crate::logging::init();
    unsafe {
        trapframe::init();
    }
    memory::init(device_tree_vaddr);
    timer::init();
    // FIXME: init driver on u540
    #[cfg(not(any(feature = &quot;board_u540&quot;)))]
    board::init(device_tree_vaddr);
    unsafe {
        board::init_external_interrupt();
    }
    crate::process::init();

    AP_CAN_INIT.store(true, Ordering::Relaxed);
    crate::kmain();
}

fn others_main(hartid: usize) -&gt; ! {
    unsafe {
        trapframe::init();
    }
    memory::init_other();
    timer::init();
    info!(&quot;Hello RISCV! in hart {}&quot;, hartid);
    crate::kmain();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>rust_mainÁöÑÂ§öÊ†∏Â§ÑÁêÜ</strong></p>
<p>1.ËÆæÁΩÆthread_pointer‰∏∫hartid</p>
<p>2.È¶ñÂÖàËÆ©hartid = BOOT_HART_IDÊâßË°åÂÆårust_main,ÂêåÊó∂Â¶ÇÊûúÂÖ∂‰ªñhartËøõÂÖ•Âà∞Ê≠§ÂáΩÊï∞ÂàôÂæ™ÁéØÁ≠âÂæÖ.Áõ¥Âà∞BST(boot_hart)ÊâßË°åÂêØÂä®‰ª£Á†Å,Âπ∂ËÆæÁΩÆÂéüÂ≠êÊìç‰ΩúÊìç‰ΩúAP_CAN_INIT.store(true, Ordering::Relaxed)Âêé,ÂÜçÊâßË°åÂÖ∂‰ªñhartÁöÑÂàùÂßãÂåñÊìç‰Ωú.</p>
<p>ËøôÈáåÁî®Âà∞‰∫Ürust‰∏≠ÁöÑatomicÂü∫Êú¨Áî®Ê≥ïÂ¶Ç‰∏ã:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicBool, Ordering};
let some_bool = AtomicBool::new(true);
some_bool.store(false, Ordering::Relaxed);
assert_eq!(some_bool.load(Ordering::Relaxed), false);
<span class="boring">}
</span></code></pre></pre>
<table><td bgcolor=#EFF5FF>
Áî≥ËØ∑‰∏Ä‰∏™ÂéüÂ≠êÂûãboolÂèòÈáèÂàùÂßãÂåñ‰∏∫true. AtomicBool::new(true)
<p>load(Ordering::Relaxed)Êù•Ëé∑ÂæóÂèòÈáèÂÄº</p>
<p>store(false, Ordering::Relaxed)Êù•ÊîπÂèòÂÄº</p>
</td></table>
<p><strong>Â§öÊ†∏ÂêØÂä®Ê¶ÇÊã¨</strong></p>
<p>1.ËÆ©‰∏ªÊ†∏(BST)ÊâßË°åÂÆåÂêØÂä®‰ª£Á†Å.ÂêåÊó∂ËÆæÁΩÆÂéüÂ≠êÊìç‰ΩúËÆ©ÂÖ∂‰ªñÊ†∏Á≠âÂæÖ.ÁÑ∂ÂêéÊâßË°åÂÖ∂‰ªñÊ†∏(AP)ÁöÑÂêØÂä®‰ª£Á†Å.</p>
<p>2.‰∏∫ÊØè‰∏™Ê†∏ËÆæÁΩÆÂ•ΩÊ†à</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ÂÆûÁé∞‰∏≠Êñ≠Êú∫Âà∂</strong></p>
<p>ÂÜÖÊ†∏Ê†à:Âõ∫ÂÆöÂ§ßÂ∞è,ÊØè‰∏™ËøõÁ®ã,Á∫øÁ®ãÈÉΩÊúâ‰∏Ä‰∏™ÂÜÖÊ†∏Ê†à.ÂÜÖÊ†∏Ê†àÊòØËøõÁ®ã,Á∫øÁ®ãÂú®ÂÜÖÊ†∏ÊÄÅ‰∏ãÊâÄ‰ΩøÁî®ÁöÑÊ†à.Âú®Áî®Êà∑ÊÄÅ‰∏ãcpuÁöÑspÊåáÈíàÊåáÂêëÁöÑÊòØÁî®Êà∑Ê†àÁöÑÊ†àÈ°∂.ÂÜÖÊ†∏ÊÄÅ‰∏ãÊåáÂÆöÂÜÖÊ†∏Ê†àÁöÑÊ†àÈ°∂.</p>
<p><strong>‰∏≠Êñ≠ÂÆûÁé∞ÊÄùË∑Ø</strong></p>
<table><tr><td bgcolor=#EFF5FF>
1.Âå∫ÂàÜÊòØ‰ªéÁî®Êà∑ÊÄÅËøòÊòØÂÜÖÊ†∏ÊÄÅ‰∏≠Êñ≠, ‰øùÂ≠ò32‰∏™ÈÄöÁî®ÂØÑÂ≠òÂô®‰ª•Âèä‰∏Ä‰∫õÊéßÂà∂‰∏éÁä∂ÊÄÅÂØÑÂ≠òÂô®csr.ÁÑ∂ÂêéË∑≥ËΩ¨Âà∞‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞  Ê≠§ÈÉ®ÂàÜÁî®Ê±áÁºñËØ≠Ë®ÄÂÜô
<p>2.ËøõÂÖ•‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞,print‰∏≠Êñ≠Êù•Ê∫ê(Áî®Êà∑ÊÄÅorÂÜÖÊ†∏ÊÄÅ) ÂΩìÂâç‰∏≠Êñ≠Êåá‰ª§(pc) ‰∏≠Êñ≠ÂéüÂõ†(ËØªÂèñscauseÂØÑÂ≠òÂô®)
# Â¶ÇÊûú‰ªéÂÜÖÊ†∏ÊÄÅËøõÂÖ•‰∏≠Êñ≠Ôºå sstatus ÁöÑ SPP ‰ΩçË¢´Á°¨‰ª∂ËÆæ‰∏∫ 1
# Â¶ÇÊûú‰ªéÁî®Êà∑ÊÄÅËøõÂÖ•‰∏≠Êñ≠Ôºå sstatus ÁöÑ SPP ‰ΩçË¢´Á°¨‰ª∂ËÆæ‰∏∫ 0</p>
<p>3.ÊÅ¢Â§ç‰∏ä‰∏ãÊñá. ÊÅ¢Â§ç32‰∏™ÈÄöÁî®ÂØÑÂ≠òÂô®,‰ª•Âèä‰∏Ä‰∫õcsrÂØÑÂ≠òÂô®.</p>
</td></tr></table>
<p>ÊåâÁÖß TrapContext ÁªìÊûÑ‰ΩìÁöÑÂÜÖÂ≠òÂ∏ÉÂ±ÄÔºåÂÆÉ‰ªé‰ΩéÂú∞ÂùÄÂà∞È´òÂú∞ÂùÄÂàÜÂà´ÊåâÈ°∫Â∫èÊîæÁΩÆ x0~x31ÔºåÊúÄÂêéÊòØ sstatus Âíå sepc „ÄÇÂõ†Ê≠§ÈÄöÁî®ÂØÑÂ≠òÂô® xn Â∫îËØ•Ë¢´‰øùÂ≠òÂú®Âú∞ÂùÄÂå∫Èó¥ [sp+8n,sp+8(n+1)) „ÄÇ Âú®ËøôÈáåÊàë‰ª¨Ê≠£ÊòØËøôÊ†∑Âü∫‰∫é sp Êù•‰øùÂ≠òËøô‰∫õÈÄöÁî®ÂØÑÂ≠òÂô®ÁöÑ„ÄÇ
(‰∏ªË¶Å‰øùÂ≠òtrapframe‰∏≠ÂÜÖÂÆπ)‰øùÂ≠ò32‰∏™ÈÄöÁî®ÂØÑÂ≠òÂô®‰ª•Âèä‰∏Ä‰∫õÊéßÂà∂‰∏éÁä∂ÊÄÅÂØÑÂ≠òÂô®csr Ê≠§ÈÉ®ÂàÜ‰∏étrapframeÁªìÊûÑ‰Ωì‰∏ÄËá¥. ÊÅ¢Â§çÊó∂Âè™Ë¶ÅÊääÁªìÊûÑ‰ΩìÊåáÈíàÊåáÂêëspÂ∞±ËÉΩÊÅ¢Â§çtrapframe</p>
<p>csrrw rd, csr, rs ÂèØ‰ª•Â∞Ü CSR ÂΩìÂâçÁöÑÂÄºËØªÂà∞ÈÄöÁî®ÂØÑÂ≠òÂô® rd ‰∏≠ÔºåÁÑ∂ÂêéÂ∞Ü ÈÄöÁî®ÂØÑÂ≠òÂô® rs ÁöÑÂÄºÂÜôÂÖ•ËØ• CSR „ÄÇÂõ†Ê≠§ËøôÈáåËµ∑Âà∞ÁöÑÊòØ‰∫§Êç¢ sscratch Âíå sp ÁöÑÊïàÊûú„ÄÇÂú®Ëøô‰∏ÄË°å‰πãÂâç sp ÊåáÂêëÁî®Êà∑Ê†àÔºå sscratch ÊåáÂêëÂÜÖÊ†∏Ê†àÔºåÁé∞Âú® sp ÊåáÂêëÂÜÖÊ†∏Ê†àÔºå sscratch ÊåáÂêëÁî®Êà∑Ê†à„ÄÇ</p>
<hr />
<p>‰ªéÁî®Êà∑ÊÄÅ‰∏≠Êñ≠Êó∂,spÊåáÂêëÂÜÖÊ†∏Ê†à.ÁÑ∂ÂêéÂú®sp[...]Âå∫Èó¥‰∏≠‰øùÂ≠òtrapcontextÂÜÖÂÆπ</p>
<p><strong>ÁñëÈóÆ</strong>:(‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÁî®ÁöÑ‰πüÊòØÂÜÖÊ†∏Ê†à,ÈöæÈÅìÊâßË°åÊµÅ‰∏ç‰ºöÊîπÂèòÂÜÖÊ†∏Ê†à‰∏≠ÁöÑÂÜÖÂÆπÂêó? ÈÇ£‰øùÂ≠ò‰∫ÜËøòÊúâ‰ªÄ‰πàÊÑè‰πâ. ËØ•ÊâßË°åÊµÅ‰ªÖ‰ºöÊîπÂä®trapcontext‰∏≠ÁöÑÂÜÖÂÆπÂêó?)</p>
<p><strong>ÂàÜÊûê</strong>:spÊ∞∏ËøúÊåáÂêëÊâßË°åÊµÅ‰∏≠ÁöÑÊ†à.ÊâÄ‰ª•‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èËøêË°åÊó∂ÂÄôÂπ∂‰∏ç‰ºöÂπ≤Êâ∞Âà∞ÂéüÊú¨‰øùÊåÅÁöÑÂÜÖÂÆπ</p>
<p>more:ÂÜÖÊ†∏Ê†àÂèØ‰ª•ÁêÜËß£‰∏∫ÊòØ‰∏Ä‰∏™‰∏≠Êñ≠ÂèëÁîüÊó∂‰∏¥Êó∂Â≠òÊîæÈÄöÁî®ÂØÑÂ≠òÂô®‰ª•ÂèäÊåá‰ª§‰∏éÁä∂ÊÄÅÂØÑÂ≠òÂô®‰ø°ÊÅØÁöÑÊ†à. ÂÆûÈôÖÂÜÖÊ†∏Âú®ÊâßË°å‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞Êó∂Âπ∂‰∏ç‰ºöÁî®Âà∞ËØ•Ê†à(ÊåáÁöÑÊòØ‰∏ç‰øÆÊîπ.ËøòÊòØÂèØ‰ª•‰ªé‰∏≠ËØªÂèñ‰∏Ä‰∫õ‰ø°ÊÅØ),ÂÜÖÊ†∏ÊâßË°å‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞Êó∂ÊâÄ‰ΩøÁî®ÁöÑÊ†àÊòØsp.(Âú®‰ªª‰ΩïÊâßË°åÊµÅ‰∏≠‰ΩøÁî®ÁöÑÊ†àÈÉΩÂ∫îËØ•ÊòØsp)</p>
<hr />
<p><strong>addi sp, sp, -34*8</strong>‰∏∫‰ªÄ‰πàËøôÊù°Êåá‰ª§ÂèØ‰ª•Ë°®Á§∫ÂàÜÈÖç‰∫ÜÊ†àÂ∏ß. ÂèØ‰ª•ÁêÜËß£‰∏∫spÊåáÂêëÁöÑÊòØÊ†àÈ°∂.Áé∞Âú®Â¢ûÂä†spÁöÑÂÄºÊÑèÂë≥ÁùÄÊ†àÈ°∂ÁöÑÊèêÈ´ò.Áõ∏ÂΩì‰∫éÂàÜÈÖç‰∫ÜÁ©∫Èó¥</p>
<hr />
<p><strong>Êó∂Èíü‰∏≠Êñ≠</strong></p>
<p>Áõ∏ÂÖ≥ÂØÑÂ≠òÂô® mtime  ‚Äãmtimecmp   mie  sie sip</p>
<p>SI(Software Interrupt)ÔºåËΩØ‰ª∂‰∏≠Êñ≠
TI(Timer Interrupt)ÔºåÊó∂Èíü‰∏≠Êñ≠
EI(External Interrupt)ÔºåÂ§ñÈÉ®‰∏≠Êñ≠</p>
<p>‚Äãmtimecmp ‚Äã= ‚Äãmtime ‚Äã+ ‚ÄãX‚Äã
A timer interrupt (if enabled) is generated whenever ‚Äãmtime ‚Äãis greater than or equal to the valuein the ‚Äãmtimecmp ‚Äãregister. Therefore, to generate a timer interrupt after ‚ÄãX ‚Äãcycles, one can updatemtimecmp ‚Äãregister as follows: ‚Äãmtimecmp ‚Äã= ‚Äãmtime ‚Äã+ ‚ÄãX‚Äã.</p>
<p>// Ê†πÊçÆ‰∏≠Êñ≠ÂéüÂõ†ÂàÜÁ±ªËÆ®ËÆ∫</p>
<pre><code>// Âè™ËÉΩÂΩìÊØè‰∏ÄÊ¨°Êó∂Èíü‰∏≠Êñ≠Ëß¶ÂèëÊó∂
// ËÆæÁΩÆ‰∏ã‰∏ÄÊ¨°Êó∂Èíü‰∏≠Êñ≠ÁöÑËß¶ÂèëÊó∂Èó¥
// ËÆæÁΩÆ‰∏∫ÂΩìÂâçÊó∂Èó¥Âä†‰∏ä TIMEBASE
// ËøôÊ¨°Ë∞ÉÁî®Áî®Êù•È¢ÑÂ§ÑÁêÜ
</code></pre>
<p>Ê†πÁªùscause Âå∫ÂàÜ‰∏≠Êñ≠Á±ªÂà´.   ËØ•Êúâ‰∏çÂêåÁöÑÂ§ÑÁêÜ‰∫Ü   ‰ª•ÂèäËÆæÁΩÆÂ§öÂ∞ëcycleËß¶Âèë‰∏ÄÊ¨°Êó∂Èíü‰∏≠Êñ≠</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>‰∏≠Êñ≠ÂÖ∑‰ΩìÂÆûÁé∞</strong></p>
<p><strong>Êï¥ÁêÜ‰∏ã‰∏≠Êñ≠Êìç‰ΩúÁõ∏ÂÖ≥ÁöÑcsrÂØÑÂ≠òÂô®</strong></p>
<blockquote>
<p><strong>sepc</strong>:ÂèëÁîüÂºÇÂ∏∏ÁöÑÊåá‰ª§ÁöÑpcË¢´Â≠òÂÖ•sepc. Êàë‰ª¨ÈúÄË¶ÅËØªÂèñ‰ªñÊù•Ëé∑Âæóbug‰ø°ÊÅØ.</p>
<p><strong>stvec</strong>:riscvÂ§ÑÁêÜÂô®trapÂêéË∑≥ÂÖ•ÁöÑPCÂú∞ÂùÄÁî±‰∏Ä‰∏™Âè´ÂÅöÊú∫Âô®Ê®°ÂºèÂºÇÂ∏∏ÂÖ•Âè£Âü∫Âú∞ÂùÄÂØÑÂ≠òÂô®mtvecÁöÑcsrÂØÑÂ≠òÂô®ÊåáÂÆö. mtvecÊòØ‰∏Ä‰∏™ÂèØËØªÂèØÂÜôÁöÑÂØÑÂ≠òÂô®, ËΩØ‰ª∂ÂèØ‰ª•ÁºñÁ®ãËÆæÂÆöÂÆÉÁöÑÂÄº.Âú®SÊ®°Âºè‰∏ãÁî®Âà∞ÁöÑÂØÑÂ≠òÂô®Âç≥‰∏∫stvec.Êàë‰ª¨ÈúÄË¶ÅÁî®ÂÜôstvecÊù•Ë∑≥ËΩ¨Âà∞‰∏≠Êñ≠Â§ÑÁêÜ‰ª£Á†Å.trap.asm‰∏≠ÁöÑ__alltrapsÂ§Ñ</p>
<p><strong>scaues</strong>:ÂÆÉ‰ºöËÆ∞ÂΩï‰∏≠Êñ≠ÂèëÁîüÁöÑÂéüÂõ†, ÈúÄË¶ÅÁî®ËØªÂèñËØ•ÂØÑÂ≠òÂô®Êù•Ê†πÊçÆ‰∏çÂêåÁ±ªÂûã‰∏≠Êñ≠ÊâßË°å‰∏çÂêåÂ§ÑÁêÜ‰ª£Á†Å</p>
<p><strong>sstatus</strong>:ÈúÄË¶ÅËÆæÁΩÆÂÆÉÁöÑsie‰ΩçÊù•‰ΩøËÉΩ‰∏≠Êñ≠</p>
</blockquote>
<p><strong>Â¶Ç‰ΩïËØªÂÜôcsrÂØÑÂ≠òÂô®</strong></p>
<p>ËØªÂÜôsatpÂØÑÂ≠òÂô®‰∏∫‰æã:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, satp&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn write(x: usize) {
    llvm_asm!(&quot;csrw satp, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ÂàùÂßãÂåñ‰∏≠Êñ≠</strong></p>
<p>Âú®Â§ÑÁêÜÂô®ÁöÑÁ®ãÂ∫èÊâßË°åËøáÁ®ã‰∏≠,‰∏ÄÊó¶ÂèëÁîüÂºÇÂ∏∏,ÂàôÁªàÊ≠¢ÂΩìÂâçÁöÑÁ®ãÂ∫èÊµÅ,Â§ÑÁêÜÂô®Ë¢´Âº∫Ë°åË∑≥ËΩ¨Âà∞‰∏Ä‰∏™Êñ∞ÁöÑPCÂú∞ÂùÄ„ÄÇ</p>
<p>Âú®riscv‰∏≠SÊÄÅËØ•Âú∞ÂùÄÁî±stvecÊåáÂÆöstvec‰Ωé2‰Ωç‰ΩçmodeÂüü,È´ò30‰ΩçÊòØbaseÂüü.</p>
<p>ÂΩì<strong>MODE</strong>=0ÔºåËÆæÁΩÆ‰∏∫ Direct Ê®°ÂºèÊó∂ÔºåÂàôÊâÄÊúâÁöÑÂºÇÂ∏∏ÂìçÂ∫îÊó∂Â§ÑÁêÜÂô®ÂùáË∑≥ËΩ¨Âà∞baseÂÄºÊåáÁ§∫ÁöÑpcÂú∞ÂùÄ„ÄÇ</p>
<p>ÂΩì<strong>MODE=1</strong>Êó∂ÔºåËÆæÁΩÆ‰∏∫ Vectored Ê®°ÂºèÊó∂ÔºåÈÅáÂà∞‰∏≠Êñ≠Êàë‰ª¨‰ºöËøõË°åË∑≥ËΩ¨Â¶Ç‰∏ãÔºöPC-&gt;BASE + 4 x cause„ÄÇËÄåËøôÊ†∑ÔºåÊàë‰ª¨Âè™ÈúÄÂ∞ÜÂêÑ‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÊîæÂú®Ê≠£Á°ÆÁöÑ‰ΩçÁΩÆÔºåÂπ∂ËÆæÁΩÆÂ•Ω stvec ÔºåÈÅáÂà∞‰∏≠Êñ≠ÁöÑÊó∂ÂÄôÁ°¨‰ª∂Ê†πÊçÆ‰∏≠Êñ≠ÂéüÂõ†Â∞±‰ºöËá™Âä®Ë∑≥ËΩ¨Âà∞ÂØπÂ∫îÁöÑ‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫è‰∫Ü</p>
<p>Âú®Ê≠§Êàë‰ª¨ÈÄâÊã©DirectÊ®°Âºè.Ë∑≥ËΩ¨Âà∞Áªü‰∏ÄÂú∞ÂùÄËøõË°åÂ§ÑÁêÜ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init() {
    unsafe {
        extern &quot;C&quot; {
            fn __alltraps();
        }
        //ËÆæÁΩÆtrapË∑≥ËΩ¨Âà∞Áªü‰∏ÄÂú∞ÂùÄ __alltrapsÂ§Ñ
        println!(&quot;trap init--------------&quot;);
        stvec::write(__alltraps as usize);
        sstatus::set_sie();
    }
    println!(&quot;++++ setup interrupt! ++++&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>stvec</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub unsafe fn _write(x: usize) {
    llvm_asm!(&quot;csrw stvec, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
//0‰∏∫ËÆæÁΩÆÊàêDirectÊ®°Âºè
#[inline]
pub unsafe fn write(addr: usize) {
    _write(addr + 0 as usize);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>sstatus</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIE: usize = 1 &lt;&lt; 1;  // supervisor interrupt enable
#[inline]
pub fn write(x: usize) {
    unsafe {llvm_asm!(&quot;csrw sstatus, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);}
}

#[inline]
pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, sstatus&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}

#[inline]
pub fn set_sie() {
    write(read() | SIE);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>__alltrap</strong></p>
<pre><code class="language-x86asm">__alltraps:
    csrrw sp, sscratch, sp       ‰∫§Êç¢Áî®Êà∑Ê†àÂíåÂÜÖÊ†∏Ê†à
    addi sp, sp, -34*8           Âú®ÂÜÖÊ†∏Ê†à‰∏äÂàÜÈÖç‰∏Ä‰∏™trapcontextÂ§ßÂ∞èÁöÑÊ†àÂ∏ß
    
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct TrapContext {
    // 32‰∏™ÈÄöÁî®ÂØÑÂ≠òÂô® 
    pub x: [usize; 32], 
    // Âá†‰∏™Áõ∏ÂÖ≥csrÂØÑÂ≠òÂô®
    pub sstatus: usize,
    pub sepc: usize,
    pub stval: usize,
    pub scause: usize,
    //ÂÖ±ÈúÄ(32+4)*8ÁöÑÊ†àÁ©∫Èó¥
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>trap.asm</strong></p>
<pre><code class="language-x86asm">	.section .text
	.globl __alltraps
__alltraps:
	SAVE_ALL
	mv a0, sp
	jal trap_handler

	.globl __trapret
__trapret:
	RESTORE_ALL
	sret

.equ XLENB, 8
.macro LOAD a1, a2
	ld \a1, \a2*XLENB(sp)
.endm

.macro STORE a1, a2
	sd \a1, \a2*XLENB(sp)
.endm
</code></pre>
<p><strong>save_allÂíårestore_all</strong></p>
<pre><code class="language-x86asm">
.macro SAVE_ALL
	csrrw sp, sscratch, sp
	addi sp, sp, -36*XLENB
	STORE x1, 1
	STORE x3, 3
...
    STORE x30, 30
    STORE x31, 31

	csrrw s0, sscratch, x0
	csrr s1, sstatus
	csrr s2, sepc
	csrr s3, stval
	csrr s4, scause
	
	STORE s0, 2
	STORE s1, 32
	STORE s2, 33
	STORE s3, 34
	STORE s4, 35
.endm
</code></pre>
<pre><code class="language-x86asm">.macro RESTORE_ALL
	LOAD s1, 32
	LOAD s2, 33
	andi s0, s1, 1 &lt;&lt; 8
    csrw sstatus, s1
    csrw sepc, s2
	LOAD x1, 1
	LOAD x3, 3
...
    LOAD x30, 30
    LOAD x31, 31

	LOAD x2, 2
.endm
</code></pre>
<p>ÂàÜÂà´Áî®ldÂíåsdÊù•‰øùÂ≠òÈÄöÁî®ÂØÑÂ≠òÂô®.64‰ΩçÊï∞ÊçÆÈúÄË¶Å8Â≠óËäÇÁ©∫Èó¥Â≠òÂÇ®.Áî®ÂØÑÂ≠òÂô®ÁºñÂè∑*8(sp)Êù•Â≠òÊîæÂà∞trapcontext‰∏≠Áõ∏Â∫î‰ΩçÁΩÆÂéª
Âå∫ÂàÜÊòØ‰ªéÁî®Êà∑ÊÄÅ‰∏≠Êñ≠ËøòÊòØ‰ªéÂÜÖÊ†∏ÊÄÅ‰∏≠Êñ≠.Âè™ÈúÄÂà§Êñ≠spÊòØÂê¶‰∏∫0.sp!=0ÂàôÊòØ‰ªéÁî®Êà∑ÊÄÅËøõÂÖ•‰∏≠Êñ≠.sp=0ÂàôÊòØ‰ªéÂÜÖÊ†∏ÊÄÅËøõÂÖ•‰∏≠Êñ≠.Êó†ÈúÄÂàáÊç¢Ê†à</p>
<p>ÂÆûÁé∞‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞trap_handler</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    match cause {

        3 =&gt; breakpoint(&amp;mut tf.sepc),
        5 =&gt; super_timer(),
        12 =&gt; page_fault(tf),
        13 =&gt; page_fault(tf),
        15 =&gt; page_fault(tf),
        _ =&gt; println!(&quot;undefined trap!&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>1.ÊâìÂç∞Âá∫‰∏≠Êñ≠Á±ªÂûã,‰ª•ÂèäËß¶Âèë‰∏≠Êñ≠ÊåáÂÆöÁöÑpcÂÄº.‰ª•‰æø‰ª•ÂêéË∞ÉËØï</p>
<p>2.Ê†πÊçÆcause‰∏çÂêåÂàÜÂà´ËøõË°å‰∏çÂêåÁöÑÂ§ÑÁêÜ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Â¶ÇÊûúÊòØÊñ≠ÁÇπÂàôÊâìÂç∞Êñ≠ÁÇπpc. ÁÑ∂Âêépc+2.ÊâßË°å‰∏ã‰∏ÄÊù°Êåá‰ª§ (riscv64ÊåáÂÆöÈïøÂ∫¶‰∏∫4Â≠óËäÇ.ÂéüÊù•Â∫îËØ•ÊòØsepc+4.‰ΩÜÊòØÁºñËØëÂô®ÁöÑË°å‰∏∫‰ºöÂéãÁº©.ÊâÄ‰ª•‰øÆÊ≠£‰∏∫sepc+2)
fn breakpoint(sepc: &amp;mut usize) {
    println!(&quot;a breakpoint epc:0x{:x}&quot;, sepc);
    *sepc += 2;
}

ÊØèÊ¨°Ëß¶ÂèëÊó∂Èíü‰∏≠Êñ≠TICKS+1.Ëß¶Âèë100Ê¨°ÊâìÂç∞‰∏ÄÊ¨°.
fn super_timer() {
    clock_set_next_event();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}

//page_fault
fn page_fault(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    println!(&quot;{:?} va = {:#x} instruction = {:#x}&quot;, cause, tf.stval, tf.sepc);
    panic!(&quot;page fault!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>Ëá≥Ê≠§trapÂèØ‰ª•ÂèØ‰ª•Ê≠£Â∏∏Â∑•‰Ωú</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ËøêË°åÂ∫îÁî®Á®ãÂ∫è</strong></p>
<p><strong>Â∞ÜÂ∫îÁî®Á®ãÂ∫èÈìæÊé•Âà∞ÂÜÖÊ†∏</strong></p>
<p>link_app.S</p>
<pre><code class="language-x86asm">    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 3
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_2_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;
app_1_end:

    .section .data
    .global app_2_start
    .global app_2_end
app_2_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;
app_2_end:

</code></pre>
<p><strong>.incbin</strong></p>
<table><tr><td bgcolor=#EFF5FF>
The incbin directive includes file verbatim at the current location. You can control the search paths used with the -I command-line option (refer to Chapter 3 Command-Line Options). Quotation marks are required around file.
<p>The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user's responsibility to make sure that proper alignment is provided both before and after the incbin directive.</p>
</td></tr></table>
<p><strong>.quad</strong></p>
<p>Áî®Êù•ÂÆö‰πâ‰∏Ä‰∏™8Â≠óËäÇ. Âú∞ÂùÄ‰∏∫ÂêÑ‰∏™Â∫îÁî®Á®ãÂ∫èËµ∑ÂßãÂú∞ÂùÄ</p>
<p>num_app_ptr[x] Êù•ÂæóÂà∞_num_app‰∏≠ÂÆö‰πâÁöÑÂ∫îÁî®Á®ãÂ∫èËµ∑ÂßãÂú∞ÂùÄ</p>
<p>ÁÑ∂ÂêéÁî®copy_from_sliceÊù•ÂÆûÁé∞Á±ª‰ººmemcpyÁöÑÂäüËÉΩ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_MANAGER: AppManager = AppManager {
        inner: RefCell::new({
            extern &quot;C&quot; { fn _num_app(); }
            let num_app_ptr = _num_app as usize as *const usize;
            let num_app = unsafe { num_app_ptr.read_volatile() };
            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];
            let app_start_raw: &amp;[usize] = unsafe {
                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
            };
            app_start[..=num_app].copy_from_slice(app_start_raw);
            AppManagerInner {
                num_app,
                current_app: 0,
                app_start,
            }
        }),
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>ÊääÂ∫îÁî®Á®ãÂ∫èÁöÑ‰ª£Á†ÅÂíåÊï∞ÊçÆÂ≠òÂú®‰∫Üapp_startÁöÑÊï∞ÁªÑ‰πãÂêé.ÁÑ∂ÂêéÂà©Áî®trapËøîÂõûÂú®ÂÜÖÊ†∏Ê†à‰∏äÂéãÂÖ•ËÆæÁΩÆÂ•ΩÁöÑÊ†à
riscvÂáΩÊï∞Ë∞ÉÁî®ËßÑÂÆöÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ÊîæÂú®a0‰∏≠. Âà©Áî®ËøôÁÇπtrap.asm ‰∏≠ __trapret mv sp, a0  ÂèØ‰ª•ËÆ©Êàë‰ª¨ÂéãÂÖ•Êàë‰ª¨ËÆæÁΩÆÂ•ΩÁöÑÊ†à
Ê†àËÆæÁΩÆ:</p>
<p>1.sspËÆæÁΩÆ‰∏∫user</p>
<p>2.sepcËÆæÁΩÆ‰∏∫Â∫îÁî®Á®ãÂ∫èÂÖ•Âè£Âú∞ÂùÄ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TrapContext {
    pub fn set_sp(&amp;mut self, sp: usize) { self.x[2] = sp; }
    pub fn app_init_context(entry: usize, sp: usize) -&gt; Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
        };
        cx.set_sp(sp);
        cx
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Áî±‰∫éÂú® RISC-V ‰∏≠Ê†àÊòØÂêë‰∏ãÂ¢ûÈïøÁöÑ, Ê†àÈ°∂Âú∞ÂùÄ = Ëµ∑ÂßãÂú∞ÂùÄ+Ê†àÂ§ßÂ∞è</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl KernelStack {
    fn get_sp(&amp;self) -&gt; usize {
        self.data.as_ptr() as usize + KERNEL_STACK_SIZE
    }
    pub fn push_context(&amp;self, cx: TrapContext) -&gt; &amp;'static mut TrapContext {
        let cx_ptr = (self.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) as *mut TrapContext;
        unsafe { *cx_ptr = cx; }
        unsafe { cx_ptr.as_mut().unwrap() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Â§ÑÁêÜÁ≥ªÁªüË∞ÉÁî®</strong></p>
<p>Á≥ªÁªüË∞ÉÁî®:ÈÄöËøáÊü•riscvÊâãÂÜå Environment call from U-mode ‰∏∫ÂºÇÂ∏∏.ÂºÇÂ∏∏Âè∑‰∏∫8</p>
<p>Âú®traphandler‰∏≠Âä†ÂÖ•ÂØπÁ≥ªÁªüË∞ÉÁî®Â§ÑÁêÜ</p>
<p>ÈÄöËøáËØªÂèñscauseÁöÑÁ¨¨64‰ΩçÊù•Âå∫ÂàÜÊòØ‰∏≠Êñ≠ËøòÊòØÂºÇÂ∏∏, ÁÑ∂ÂêéËßÜ‰∏çÂêåÊÉÖÂÜµËøõË°åÂ§ÑÁêÜ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    let tmp = scause::read().get_bit(63);
    //tmp  Âå∫ÂàÜ‰∏≠Êñ≠ËøòÊòØÂºÇÂ∏∏
    if tmp == true {
        match cause {
            _ =&gt; println!(&quot;undefined trap!&quot;)
        }
        tf
    }else{
        match cause {
            2 =&gt; {
                println!(&quot;[kernel] IllegalInstruction in application, core dumped.&quot;);
                run_next_app();
            }
            3 =&gt; breakpoint(&amp;mut tf.sepc),
            5 =&gt; super_timer(),
            // 12 =&gt; page_fault(tf),
            // 13 =&gt; page_fault(tf),
            7 | 15 =&gt; {
                println!(&quot;[kernel] PageFault in application, core dumped.&quot;);
                run_next_app();
            }   
            8 =&gt; user_syscall(tf),
            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ÊúÄÁªàÂæóÂà∞È¢ÑÂèñÁªìÊûú~~</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>++++ setup interrupt! ++++
[kernel] num_app = 3
[kernel] app_0 [0x80210654, 0x802119e4)
[kernel] app_1 [0x802119e4, 0x80212e14)
[kernel] app_2 [0x80212e14, 0x802143ac)
[kernel] Loading app_0
[kernel] Loading app_0 finished
Hello, world!
[kernel] IllegalInstruction in application, core dumped.
[kernel] Loading app_1
[kernel] Loading app_1 finished
Into Test store_fault, we will insert an invalid store operation...
Kernel should kill this application!
[kernel] PageFault in application, core dumped.
[kernel] Loading app_2
[kernel] Loading app_2 finished
3^10000=5079
3^20000=8202
3^30000=8824
3^40000=5750
3^50000=3824
3^60000=8516
3^70000=2510
3^80000=9379
3^90000=2621
3^100000=2749
Test power OK!
[kernel] Application exited with code 0
panicked at 'All applications completed!', src\batch.rs:61:13
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ËøêË°åÂ∫îÁî®Á®ãÂ∫èÊÄªÁªì</strong></p>
<p><strong>1.ÁºñÂÜôÂ∫îÁî®Á®ãÂ∫è</strong></p>
<p>ÁºñÂÜôÁî®Êà∑ÊÄÅsyscall. Â∞±Â¶ÇÂêåosË∞ÉÁî®sbicallÁ±ª‰ºº!</p>
<p>ÈÄöËøálinkerÈìæÊé•ËÑöÊú¨.Êù•ÊåáÂÆöÂ∫îÁî®Á®ãÂ∫èÂÖ•Âè£Âú∞ÂùÄ</p>
<p><strong>2.ÈìæÊé•Â∫îÁî®Á®ãÂ∫è</strong></p>
<p>.quad Êù•ÊåáÂÆö‰∏Ä‰∏™8Â≠óËäÇÂú∞ÂùÄ</p>
<p>.incbin Êù•ËΩΩÂÖ•‰∏Ä‰∏™Êñá‰ª∂</p>
<p><strong>3.Âú®ÂÜÖÊ†∏‰∏≠ËΩΩÂÖ•Â∫îÁî®Á®ãÂ∫è</strong></p>
<p>ÈÄöËøáfrom_raw_parts_mut Âíå copy_from_slice Êù•ÂÆûÁé∞Á±ª‰ººmemcpyÂäüËÉΩ</p>
<p><strong>4.‰∏∫Â∫îÁî®Á®ãÂ∫èËÆæÁΩÆÂ•ΩTrapContext</strong></p>
<p>1.sspËÆæÁΩÆ‰∏∫user</p>
<p>2.sepcËÆæÁΩÆ‰∏∫Â∫îÁî®Á®ãÂ∫èÂÖ•Âè£Âú∞ÂùÄ</p>
<p><strong>5.Âà©Áî®trapretÊù•ÊääËÆæÁΩÆÂ•ΩÁöÑTrapContextÂéãÂÖ•Âà∞ÂÜÖÊ†∏Ê†à‰∏≠</strong></p>
<p><strong>6.‰∏≠Êñ≠‰∏≠Âä†ÂÖ•ÂØπÁ≥ªÁªüË∞ÉÁî®ÊîØÊåÅ</strong></p>
<p>1.Environment call from U-mode</p>
<p><strong>7.ÈÄâÊã©‰ΩïÊó∂ËøêË°åÂ∫îÁî®Á®ãÂ∫è</strong></p>
<p>Ë∞ÉÂ∫¶Âô®Áõ∏ÂÖ≥.ÂÆûÈ™åÊöÇÊó∂Êú™Ê∂âÂèä.Âè™ÊòØÈÄöËøá‰∫∫‰∏∫Ëß¶ÂèëÂºÇÂ∏∏Êåá‰ª§Êù•ËøõÂÖ•‰∏≠Êñ≠,ÁÑ∂ÂêéÂú®‰∏≠Êñ≠Â§ÑÁêÜ‰∏≠ËøêË°å‰∏ã‰∏Ä‰∏™Â∫îÁî®Á®ãÂ∫è</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Á¨¨‰∏âÁ´†</strong></p>
<p><strong>Â§öÈÅìÁ®ãÂ∫èÊîæÁΩÆ‰∏éÂä†ËΩΩ</strong></p>
<p>Âíå‰∏ä‰∏ÄÁ´†‰∏çÂêåÁöÑÊòØappÂÖ∂ÂÆûÂú∞ÂùÄË¢´Âä†ËΩΩÂà∞‰∫ÜAPP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT‰ΩçÁΩÆ‰∏ä</p>
<p><strong>‰ªªÂä°ÂàáÊç¢</strong></p>
<p>Âú®Â§ÑÁêÜtrapÊó∂.Êàë‰ª¨ÈúÄË¶ÅÂàáÊç¢ÊàêÂÜÖÊ†∏Ê†à.ËÄåÂú®Áî®Êà∑Á®ãÂ∫èÂàáÊç¢Êó∂,Êàë‰ª¨ÈúÄË¶ÅÂàáÊç¢ÁöÑÂè¶‰∏Ä‰∏™Á®ãÂ∫èÁöÑÊ†à.</p>
<p>ÂΩìÂâç‰ªªÂä°ÂàáÊç¢ÁöÑÊú¨Ë¥®ÊòØÂáΩÊï∞Ë∞ÉÁî®,Êàë‰ª¨ÈúÄË¶Å‰øùÂ≠òÁöÑÊòØriscvÂáΩÊï∞Ë∞ÉÁî®ËßÑÂÆö‰∏≠caller-savedÁöÑÂØÑÂ≠òÂô®.s0~s11</p>
<p>‰øùÂ≠òÂ•ΩÂΩìÂâç‰ªªÂä°ÁöÑ‰ø°ÊÅØÂêé.Â¶Ç‰ΩïËøîÂõûÂΩìÂâç‰ªªÂä°ÁªßÁª≠ÊâßË°å?. Âú®ÂÅöÂáΩÊï∞ÂàáÊç¢Ââç,ÁºñËØëÂô®‰ºöÂ∏ÆÊàë‰ª¨ÂêßraÂØÑÂ≠òÂô®ÁöÑÂÄºÊîπ‰∏∫</p>
<p>ÂáΩÊï∞Ë∞ÉÁî®ËøîÂõûÂêéÁ¨¨‰∏ÄÊù°Êåá‰ª§ÁöÑÂú∞ÂùÄ. Âõ†Ê≠§ÈúÄË¶Å‰øùÂ≠òra</p>
<p>ÂàáÊç¢Âà∞ÁõÆÊ†á‰ªªÂä°. riscvÂáΩÊï∞Ë∞ÉÁî®Á¨¨‰∏ÄÁ¨¨‰∫å‰∏™ÂèÇÊï∞ÂàÜÂà´‰øùÂ≠òÂú®a0/a1.Âõ†Ê≠§ld sp, 0(a1)Âç≥ÂèØÊç¢Ê†à.</p>
<p>ÁÑ∂ÂêéËØªÂèñra s0~s11. </p>
<p><strong>Âçè‰ΩúÂºèË∞ÉÂ∫¶</strong></p>
<p>Êúâ‰∫Ü‰ªªÂä°ÂàáÊç¢,ÈÇ£‰πà‰ΩïÊó∂ËøõË°åÂàáÊç¢?</p>
<p>Áé∞Âú®ÁöÑÂÅöÊ≥ïÊòØÂ∫îÁî®Á®ãÂ∫è‰∏ªÂä®ÊöÇÂÅúsys_yield ‰ª•Âèä‰∏ªÂä®ÈÄÄÂá∫sys_exit</p>
<p><strong>‰ªªÂä°ÁÆ°ÁêÜÂô®</strong></p>
<p>‰øùÂ≠ò‰∫ÜÂêÑ‰∏™Á®ãÂ∫èÂàáÊç¢Êó∂ÊèèËø∞Ëá™Ë∫´ÁöÑÊ†à‰ø°ÊÅØ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskManager {
    num_app: usize,
    inner: RefCell&lt;TaskManagerInner&gt;,
}

struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    current_task: usize,
}

unsafe impl Sync for TaskManager {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ÂàáÊç¢‰ªªÂä°</strong></p>
<p>__switchÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ÊòØËá™Ë∫´Ê†à,Á¨¨‰∫å‰∏™ÂèÇÊï∞ÊòØÁõÆÊ†á‰ªªÂä°ÁöÑÊ†à</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_next_task(&amp;self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.borrow_mut();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr2 = inner.tasks[current].get_task_cx_ptr2();
        let next_task_cx_ptr2 = inner.tasks[next].get_task_cx_ptr2();
        core::mem::drop(inner);
        unsafe {
            __switch(
                current_task_cx_ptr2,
                next_task_cx_ptr2,
            );
        }
    } else {
        panic!(&quot;All applications completed!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>find_next_task.ÊâæÂà∞Áä∂ÊÄÅ‰∏∫TaskStatus::ReadyÁöÑ‰ªªÂä°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    let inner = self.inner.borrow();
    let current = inner.current_task;
    (current + 1..current + self.num_app + 1)
        .map(|id| id % self.num_app)
        .find(|id| {
            inner.tasks[*id].task_status == TaskStatus::Ready
        })
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ÂàÜÊó∂Â§ö‰ªªÂä°Á≥ªÁªü‰∏éÊä¢Âç†ÂºèË∞ÉÂ∫¶</strong></p>
<p>ÊØîËæÉÁÆÄÂçï.ËÆæÁΩÆÂ•ΩÊó∂Èíü‰∏≠Êñ≠, Âπ∂Âú®Êó∂Èíü‰∏≠Êñ≠ÂèëÁîüÊó∂run_next_task(),Âú®trap_handler‰∏≠Âä†ÂÖ•Áõ∏Â∫îÂ§ÑÁêÜÂç≥ÂèØ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
.........
        match cause {
.........
            5 =&gt; super_timer(),

            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}


fn super_timer() {
    clock_set_next_event();
    suspend_current_and_run_next();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>chapter3ÁªÉ‰π†</strong></p>
<p><strong>stride Ë∞ÉÂ∫¶ÁÆóÊ≥ï</strong></p>
<p>‰πãÂâçÊòØÂú®ÂèëÁîüÊó∂Èíü‰∏≠Êñ≠Êó∂,ÈÄâÊã©‰∏ã‰∏Ä‰∏™ReadyÁä∂ÊÄÅÁöÑÁ®ãÂ∫èËøêË°å,strideË∞ÉÂ∫¶ÁÆóÊ≥ïÂç≥,Á®ãÂ∫èÂàùÂßãstride‰∏∫0.‰∏∫ÊØè‰∏™Á®ãÂ∫èËÆæÁΩÆ‰∏Ä‰∏™pass.ÊØèÊ¨°Á®ãÂ∫èËøêË°åstride+pass. 
Âπ∂ÊÄªÊòØÈÄâÊã©strideÊúÄÂ∞èÁöÑÁ®ãÂ∫èËøêË°å.</p>
<p><strong>Â¢ûÂä†Êï∞ÊçÆÁªìÊûÑ</strong></p>
<p>task_pass </p>
<p>task_stride</p>
<p>task_priority </p>
<p>task_time</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    pub current_task: usize,
    pub task_pass:[usize; MAX_APP_NUM],
    pub task_stride:[usize; MAX_APP_NUM],
    pub task_priority:[usize; MAX_APP_NUM],
    pub task_time:[usize; MAX_APP_NUM],
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ÂØªÊâæ‰∏ã‰∏Ä‰∏™ÊâßË°åÁ®ãÂ∫è</strong></p>
<p>1.Êõ¥Êñ∞ÂΩìÂâçËøõÁ®ãstride</p>
<p>2.ÂØªÊâæ‰∏ã‰∏Ä‰∏™strideÂÄºÊúÄÂ∞èÁöÑËøõÁ®ã</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    //update
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    let priority = inner.task_priority[current];
    if inner.tasks[current].task_status == TaskStatus::Ready {
        inner.task_stride[current] = inner.task_stride[current] + 127 / priority
    }

    let num_app = get_num_app();
    let mut max_stride = 10000000;
    let mut next = 0 as usize;
    for i in 0..num_app{
        let stride_i  = inner.task_stride[i];
        if stride_i &lt;= max_stride  &amp;&amp; inner.tasks[i].task_status != TaskStatus::Exited{
            next = i;
            max_stride =  stride_i;
        }
    }
    let mut  exited_count = 0 as usize;
    for i in 0..num_app{
        
        if inner.tasks[i].task_status == TaskStatus::Exited{
            exited_count += 1;
        }
    }
    if exited_count == num_app{
        println!(&quot;all exited&quot;);
        None
    }else{
        println!(&quot; next min stride  app id{}&quot;, next);
        Some(next)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ê†áËÆ∞ÈÄÄÂá∫ËøõÁ®ã</p>
<p>È¶ñÂÖàÊòØid0ËøêË°å.id0 exit ÂàáÊç¢Âà∞id3</p>
<p>id3ÊâßË°åÁöÑÊòØ‰∏ªÂä®yeildÊâÄ‰ª•Á´ãÈ©¨ËøõË°å‰∫ÜÂàáÊç¢</p>
<p>....</p>
<p>all exitedÊâÄ‰ª•Á®ãÂ∫èÊâßË°åÂÆåÊØï</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mark_current_suspended(&amp;self) {
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.task_time[current] += 1;
    inner.tasks[current].task_status = if inner.task_time[current] &gt;= 500 {
        inner.task_stride[current] = 10000000;
        println!(&quot;app id {}  exited  run out of time&quot;, current);
        TaskStatus::Exited
    } else {
        TaskStatus::Ready
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>Á®ãÂ∫èÂ¶ÇÊúüËøêË°å</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OpenSBI v0.7
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 128 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
stext 80200000 etext 8020a000
srodata 8020a000 erodata 80236000
sdata 8023663c edata 8023be49
sbss 8024be50 ebss 8024c058
Hello, world!
base i 0x80400000
base i 0x80420000
base i 0x80440000
base i 0x80460000
load app done
++++ setup timer!     ++++
power_3 [10000/200000]
power_3 [20000/200000]
power_3 [30000/200000]
power_3 [40000/200000]
power_3 [50000/200000]
power_3 [60000/200000]
power_3 [70000/200000]
power_3 [80000/200000]
power_3 [90000/200000]
power_3 [100000/200000]
power_3 [110000/200000]
power_3 [120000/200000]
power_3 [130000/200000]
power_3 [140000/200000]
power_3 [150000/200000]
power_3 [160000/200000]
power_3 [170000/200000]
power_3 [180000/200000]
power_3 [190000/200000]
power_3 [200000/200000]
3^200000 = 871008973
Test power_3 OK!
[kernel] Application exited with code 0
app id 0  exited 
 next min stride  app id3
current 0 start switch to  3
 next min stride  app id2
current 3 start switch to  2
 next min stride  app id1
current 2 start switch to  1
power_5 [10000/140000]
power_5 [20000/140000]
power_5 [30000/140000]
power_5 [40000/140000]
power_5 [50000/140000]
power_5 [60000/140000]
power_5 [70000/140000]
power_5 [80000/140000]
power_5 [90000/140000]
power_5 [100000/140000]
power_5 [110000/140000]
power_5 [120000/140000]
power_5 [130000/140000]
power_5 [140000/140000]
5^140000 = 386471875
Test power_5 OK!
[kernel] Application exited with code 0
app id 1  exited 
 next min stride  app id3
current 1 start switch to  3
Test sleep OK!
[kernel] Application exited with code 0
app id 3  exited 
 next min stride  app id2
current 3 start switch to  2
power_7 [10000/160000]
power_7 [20000/160000]
power_7 [30000/160000]
power_7 [40000/160000]
power_7 [50000/160000]
power_7 [60000/160000]
power_7 [70000/160000]
power_7 [80000/160000]
power_7 [90000/160000]
power_7 [100000/160000]
power_7 [110000/160000]
power_7 [120000/160000]
power_7 [130000/160000]
power_7 [140000/160000]
power_7 [150000/160000]
power_7 [160000/160000]
7^160000 = 667897727
Test power_7 OK!
[kernel] Application exited with code 0
app id 2  exited 
all exited
panicked at 'All applications completed!', src\task\mod.rs:149:13
93
panicked at 'It should shutdown!', src\sbi.rs:45:5

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Âú∞ÂùÄÁ©∫Èó¥</strong></p>
<p><strong>Áâ©ÁêÜÂÜÖÂ≠ò</strong></p>
<p>Áâ©ÁêÜÂÜÖÂ≠òÈ°µÂºèÁÆ°ÁêÜ</p>
<p>ÂØπ‰∫éÁâ©ÁêÜÂÜÖÂ≠òÁöÑÈ°µÂºèÁÆ°ÁêÜËÄåË®ÄÔºåÊàë‰ª¨ÊâÄË¶ÅÊîØÊåÅÁöÑÊìç‰ΩúÊòØÔºö</p>
<p>ÂàÜÈÖç‰∏Ä‰∏™Áâ©ÁêÜÈ°µÔºåËøîÂõûÂÖ∂Áâ©ÁêÜÈ°µÂè∑Ôºõ</p>
<p>ÁªôÂÆö‰∏Ä‰∏™Áâ©ÁêÜÈ°µÂè∑ÔºåÂõûÊî∂ÂÖ∂ÂØπÂ∫îÁöÑÁâ©ÁêÜÈ°µ„ÄÇ</p>
<p>ÁªôÂÆö‰∏Ä‰∏™È°µÂè∑Âå∫Èó¥ËøõË°åÂàùÂßãÂåñ„ÄÇ</p>
<p>ËøôÈáåÁî®ÊúÄÁÆÄÂçïÁöÑÊñπÂºèÂÆûÁé∞</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Allocator {
    a: [u8; MAX_PHYSICAL_PAGES],
    offset: usize,
    total:usize
}

impl Allocator {
    // ÁªôÂÆö‰∏Ä‰∏™È°µÂè∑Âå∫Èó¥ËøõË°åÂàùÂßãÂåñ„ÄÇ
    pub fn init(&amp;mut self, l:usize, r:usize) {
        self.offset = l - 1;
        self.total = r - l;
        // let size = r - l;

        //0Ë°®Á§∫Á©∫Èó≤
        for i in 0..self.total {
            self.a[i] = 0;
        }
    }

    // // ÁªôÂÆöÁâ©ÁêÜÂú∞ÂùÄ ÂàÜÈÖç‰∏Ä‰∏™Áâ©ÁêÜÈ°µÔºåËøîÂõûÂÖ∂Áâ©ÁêÜÈ°µÂè∑Ôºõ
    pub fn alloc(&amp;mut self) -&gt; usize {
        //ËÆæÁΩÆ‰∏Ä‰∏™ÂàÜÈÖçÊàêÂäüÊ†áÂøó
        let mut flag = 0;

        //ËøîÂõûÂàÜÈÖçÁöÑÁâ©ÁêÜÈ°µÂè∑
        let mut result = 0;
        for i in 0..MAX_PHYSICAL_PAGES-1 {
            if self.a[i] == 0 {
                self.a[i] = 1;
                flag = 1;
                result = i;
                return result;
            }
        }
        if flag == 0 {
            panic!(&quot;physical memory depleted!&quot;);
        }
        result
    }

    //ÂõûÊî∂Áâ©ÁêÜÈ°µÂè∑‰∏∫nÁöÑÁâ©ÁêÜÈ°µ
    pub fn dealloc(&amp;mut self, n: usize) {

        let p = n;
        if p &gt;= MAX_PHYSICAL_PAGES {
            panic!(&quot;ÈùûÊ≥ïÁâ©ÁêÜÈ°µÂè∑&quot;)
        }
        self.a[p] = 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Âä®ÊÄÅÂÜÖÂ≠òÂàÜÈÖç</strong></p>
<p>ÂÆûÁé∞ Trait GlobalAlloc</p>
<p>Áî®ÂÜôÂ•ΩÁöÑÂ∫ì Âπ∂ÊääÂÆÉÊ†áËÆ∞‰∏∫ #[global_allocator]</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use buddy_system_allocator::LockedHeap;

#[global_allocator]
static DYNAMIC_ALLOCATOR: LockedHeap = LockedHeap::empty();

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>rv39È°µË°®</strong></p>
<p><strong>ÂàÜÊûêÈ°µË°®ÈúÄË¶ÅÊîØÊåÅÁöÑÊìç‰Ωú</strong></p>
<p>1.Êñ∞Âª∫‰∏Ä‰∏™È°µË°®(ÂàÜÈÖç‰∏Ä‰∏™Áâ©ÁêÜÈ°µÂ∏ß,Âπ∂ÊääËØ•È°µÂ∏ß‰Ωú‰∏∫È°µË°®ÁöÑËµ∑ÂßãÂú∞ÂùÄ)</p>
<p>2.map unmap ‰∏∫‰∏ÄÂØπva Âíå pa Âª∫Á´ãÊò†Â∞Ñ</p>
<p>3.ÊâæÂà∞È°µË°®È°π</p>
<p><strong>ÁªôÂÆöÊüêvaÂª∫Á´ãÊò†Â∞ÑÁöÑËøáÁ®ã:</strong></p>
<p><strong>1.ÊâæÂà∞root_table</strong></p>
<p><strong>2.Âú®‰∏âÁ∫ßÈ°µË°®‰∏≠ÊâæÂà∞‰∫åÁ∫ßÈ°µË°®ÁöÑÈ°µË°®È°π.Ê†πÊçÆÈ°µË°®È°πÊù•ÊâæÂà∞‰∫åÁ∫ßÈ°µË°®ÁöÑÂú∞ÂùÄ</strong></p>
<p>Â¶ÇÊûúÈ°µË°®È°πÊú™Ë¢´ËÆæÁΩÆ. ÂàôÂàÜÈÖç‰∏Ä‰∏™Áâ©ÁêÜÈ°µÂ∏ß, Âπ∂ÊääËØ•Áâ©ÁêÜÈ°µÂ∏ßÂ°´ÂÜôÂà∞È°µË°®È°πÂπ∂ËÆæÁΩÆÊ†áËÆ∞‰Ωç(Âç≥‰ª•ÂêéËÉΩÈÄöËøáÊ≠§È°µË°®È°πÊâæÂà∞‰∫åÁ∫ßÈ°µË°®ÁöÑÂú∞ÂùÄ‰∫Ü)</p>
<p>Âè™ÈúÄÂ°´ÂÜôvalid‰Ωç.Âõ†‰∏∫ÂÆÉÊåáÂêë‰∏ã‰∏ÄÁ∫ßÈ°µË°®</p>
<p>ÂÖ∂‰∏≠p1_index  p2_index p3_index ÂàÜÂà´‰∏∫ </p>
<p>ËôöÊãüÂú∞ÂùÄvaÁöÑ12..21    21 .. 30  30..39 ‰Ωç</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p3_index = page.p3_index();
let p2_index = page.p2_index();
let p1_index = page.p1_index();

let p2_table = if self.root_table.entries[p3_index].is_unused() {
    let frame = alloc_frame().unwrap();
    self.root_table.entries[p3_index].set(frame, EF::VALID);
    let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
    p2_table.zero();
    p2_table
} else {
    let frame = self.root_table.entries[p3_index].frame();
    unsafe { frame.as_kernel_mut() }
};
<span class="boring">}
</span></code></pre></pre>
<p>ËøôÈáåÈúÄË¶Å‰∏Ä‰∏™ÊääÈ°µË°®È°π‰∏≠ÁöÑÂú∞ÂùÄËß£ÊûêÂá∫Êù•Âπ∂ÂΩìÊàêÈ°µË°®ÁöÑÊìç‰Ωú</p>
<p>(pte &gt;&gt; 10 )  &lt;&lt; 12  +  PHYSICAL_MEMORY_OFFSET</p>
<p>È°µË°®È°πÂè≥Áßª10‰ΩçÊù•ÂæóÂà∞Áâ©ÁêÜÈ°µÂè∑.   ‰∏Ä‰∏™Áâ©ÁêÜÈ°µÂ∏ß‰∏∫4k. ÂÜçÂ∑¶Áßª12‰ΩçÊù•ÂæóÂà∞Áâ©ÁêÜÂú∞ÂùÄ</p>
<p>Â¶ÇÊûúÊúâËÆæÁΩÆÂÅèÁßªÂàôÂä†‰∏äPHYSICAL_MEMORY_OFFSET</p>
<p>ËøôÊ†∑Â∞±ÂæóÂà∞‰∫ÜÈ°µË°®ÊâÄÂú®ÁöÑÁâ©ÁêÜÂú∞ÂùÄ</p>
<p>rustÂÜôÊ≥ïÊúâ‰∏§Áßç</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_page_table(&amp;self) -&gt; *mut PageTable {
    ((self.data &gt;&gt; 10) &lt;&lt; 12) as *mut PageTable
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame = self.root_table.entries[p3_index].frame();
pub unsafe fn as_kernel_mut&lt;'a, 'b, T&gt;(&amp;'a self) -&gt; &amp;'b mut T {
    &amp;mut *(    (    (self.0).0 + PHYSICAL_MEMORY_OFFSET)             as *mut T       )
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>3.ÁÑ∂ÂêéÂ∞±ÊòØÈáçÂ§ç‰∏äËø∞Êìç‰Ωú</strong></p>
<p><strong>Âú®‰∫åÁ∫ßÈ°µË°®‰∏≠ÊâæÂà∞‰∏ÄÁ∫ßÈ°µË°®ÁöÑÈ°µË°®È°π, Ê†πÊçÆÈ°µË°®È°πÊâæÂà∞‰∏ÄÁ∫ßÈ°µË°®ÁöÑÂú∞ÂùÄ</strong></p>
<p>Â¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÂàÜÈÖçÁâ©ÁêÜÈ°µÂ∏ß,Â°´ÂÜôÊ†áÂøó</p>
<p>ÊúÄÁªàÂú®‰∏ÄÁ∫ßÈ°µË°®‰∏≠ÊâæÂà∞ÂØπÂ∫îÁöÑÈ°µË°®È°π,ÊääÂØπÂ∫îÁöÑÁâ©ÁêÜÈ°µÂè∑Â°´ÂÜôËøõÂéªÂ∞±ÂÆåÊàê‰∫ÜÊò†Â∞Ñ</p>
<p><strong>ÈÇ£‰πàÊàë‰ª¨ËØ•Â°´ÂÜô‰ªÄ‰πàÁâ©ÁêÜÈ°µÂè∑ËøõÂéªÂë¢?</strong> ËøôÈáåÂ∞±ÊØîËæÉÈöèÊÑè‰∫Ü</p>
<ol>
<li>
<p>ÂèØ‰ª•ÈááÁî®‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂÅèÁßª pa = va +  PHYSICAL_MEMORY_OFFSET</p>
</li>
<li>
<p>ÂèØ‰ª•ÈááÁî®‰πãÂâçÂÜôÂ•ΩÁöÑÁâ©ÁêÜÂÜÖÂú∫ÂàÜÈÖçÂô®ÂàÜÈÖç‰∏Ä‰∏™Áâ©ÁêÜÈ°µÂè∑</p>
</li>
<li>
<p>...</p>
</li>
</ol>
<p>ÂÆåÊï¥Áâà</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_pte_create(&amp;mut self, va:usize) -&gt; Option&lt;&amp;mut PageTableEntry&gt; {
    let page = Page::of_addr(VirtAddr::new(va));
    let p3_index = page.p3_index();
    let p2_index = page.p2_index();
    let p1_index = page.p1_index();
    //ÊâæÂà∞‰∫åÁ∫ßÈ°µË°®
    let p2_table = if self.root_table.entries[p3_index].is_unused() {
        let frame = alloc_frame().unwrap();
        self.root_table.entries[p3_index].set(frame, EF::VALID);
        let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p2_table.zero();
        p2_table
    } else {
        let frame = self.root_table.entries[p3_index].frame();
        unsafe { frame.as_kernel_mut() }
    };
    //ÊâæÂà∞‰∏ÄÁ∫ßÈ°µË°®
    let p1_table = if p2_table.entries[p2_index].is_unused() {
        let frame = alloc_frame().unwrap();
        p2_table.entries[p2_index].set(frame, EF::VALID);
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table.zero();
        p1_table
    } else {
        let frame = p2_table.entries[p2_index].frame();
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table
    };
    //Âú®‰∏ÄÁ∫ßÈ°µË°®‰∏≠ÊâæÂà∞ÂØπÂ∫îÈ°µË°®È°π
    let p1_entry = Some (&amp;mut p1_table.entries[p1_index]);
    p1_entry
}
<span class="boring">}
</span></code></pre></pre>
<p>Âª∫Á´ãÊò†Â∞Ñ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map(&amp;mut self, va:usize, frame: Frame, ptflags: PageTableFlags) {
    let pte = self.find_pte_create(va).unwrap();
    if !pte.is_unused(){
        println!(&quot;pte {:?} already mapped&quot;, pte);
    }
    pte.set(frame, ptflags);
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
}

pub fn unmap(&amp;mut self, va:usize) {
    let pte = self.find_pte(va).unwrap();
    pte.set_unused();
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
    MapperFlush::flush(page);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>debug</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>satp :0x8000000000080a2b                 ÂØπÂ∫îÁâ©ÁêÜÂú∞ÂùÄ:0x80a2b000
p3_index‰∏∫511                       Á¨¨511È°πÂú®Áâ©ÁêÜÂú∞ÂùÄ:0x80a2bff8
0x80a2bff8Â§ÑÂÜÖÂ≠òÊòæÁ§∫ 0x000000002028b0c5(È°µË°®È°π)
(0x000000002028b0c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2c000
                                             Áâ©ÁêÜÂú∞ÂùÄ = 0x80a2c000


ÂæóÂà∞‰∫åÁ∫ßÈ°µË°®ËôöÊãüÂú∞ÂùÄ 0xffffffffc0a2c000   ÂØπÂ∫îÁâ©ÁêÜÂú∞ÂùÄ:0x80a2c000
p2_index‰∏∫1                            Á¨¨1È°πÂú®Áâ©ÁêÜÂú∞ÂùÄ:0x80a2c008
0x80a2c008Â§ÑÂÜÖÂ≠òÊòæÁ§∫ 0x000000002028b4c5(È°µË°®È°π)
(0x000000002028b4c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2d000
                                             Áâ©ÁêÜÂú∞ÂùÄ = 0x80a2d000


ÂæóÂà∞‰∏ÄÁ∫ßÈ°µË°®ËôöÊãüÂú∞ÂùÄ 0xffffffffc0a2d000   ÂØπÂ∫îÁâ©ÁêÜÂú∞ÂùÄ:0x80a2d000
p1_index‰∏∫2                            Á¨¨2È°πÂú®Áâ©ÁêÜÂú∞ÂùÄ:0x80a2d010
0x80a2d010Â§ÑÂÜÖÂ≠òÊòæÁ§∫ 0x00000000200808cf(È°µË°®È°π)
(0x00000000200808cf &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0202000
                                             Áâ©ÁêÜÂú∞ÂùÄ = 0x80202000
<span class="boring">}
</span></code></pre></pre>
<p>gdbÊòæÁ§∫Áâ©ÁêÜÂÜÖÂ≠ò</p>
<p>maintenance packet Qqemu.PhyMemMode:1</p>
<p>x/10xg $addr  ‰ª•64‰Ωç‰∏Ä‰∏™ÂçïÂÖÉÊù•ÊòæÁ§∫ÊüêÂú∞ÂùÄÂÜÖÂ≠ò‰∏≠ÂÜÖÂÆπ.</p>
<p><strong>È°µË°®Âª∫Á´ãËøáÁ®ã‰∏≠ÊúâÂèØËÉΩÂá∫ÈîôÁöÑÂú∞Êñπ:</strong></p>
<p>1.ÊåáÂêë‰∏ã‰∏ÄÁ∫ßÈ°µË°®ÁöÑÈ°µË°®È°πÊ†áÂøó‰ΩçËÆæÁΩÆÈîô! ËøôÊó∂debug‰ºöÂèëÁé∞ÁªôÂÆövaÊâãÂä®ÁÆóÊÄªËÉΩÂú®ÊúÄÂêéÊâæÂà∞Áõ∏Â∫îÁöÑÁâ©ÁêÜÈ°µÂ∏ß! ‰ΩÜÊòØÁ®ãÂ∫èÊ≤°Ê≥ïËøêË°å</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustÂ≠¶‰π†ËÆ∞ÂΩï-2"><a class="header" href="#-rustÂ≠¶‰π†ËÆ∞ÂΩï-2">üöß rustÂ≠¶‰π†ËÆ∞ÂΩï</a></h1>
<h2 id="ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞-2"><a class="header" href="#ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞-2">ËøôÈáå‰∏ªË¶ÅËÆ∞ÂΩï‰∏Ä‰∫õcÂÆûÁé∞ÁöÑos‰∏Ä‰∫õÂ∏∏Áî®Êï∞ÊçÆÁªìÊûÑÂ∑≤ÁªèÊìç‰ΩúÂú®rust‰∏≠ÊÄé‰πàÂÆûÁé∞</a></h2>
<p><strong>Áúã‰∏Ä‰∏™cËØ≠Ë®Ä‰æãÂ≠ê</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>‰ª•‰∏ãÊòØrustÂÆûÁé∞</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-foo"><a class="header" href="#-foo">üöß foo</a></h1>
<p><strong>ËÆ∞ÂΩï‰∏Ä‰∫õÊñ∞ÊäÄËÉΩ</strong></p>
<p><strong>docker</strong>
Âú®ÈÖçÁΩÆgithub+gitpod‰∏≠Â≠¶‰π†‰∫ÜdockerÁöÑÂü∫Êú¨Áî®Ê≥ïÂåÖÊã¨imageÁîüÊàê.container‰ΩøÁî®</p>
<p><br/> </br></p>
<p><strong>Ëé∑ÂèñÂü∫Á°ÄÈïúÂÉè</strong></p>
<p>Â¶ÇÊûúÊàë‰ª¨Êú¨Âú∞Ê≤°Êúâ ubuntu ÈïúÂÉèÔºåÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî® docker pull ÂëΩ‰ª§Êù•ËΩΩÂÖ• ubuntu ÈïúÂÉè</p>
<pre><code class="language-shell">$ docker pull ubuntu
</code></pre>
<p><strong>ÂêØÂä®ÂÆπÂô®</strong></p>
<pre><code>$ docker run -it ubuntu /bin/bash
</code></pre>
<p><strong>ÂÆâË£ÖÁéØÂ¢É(Áï•)</strong></p>
<p><strong>Êé®ÈÄÅÈïúÂÉèÂà∞Docker Hub</strong></p>
<p>ÈúÄË¶ÅÂú®docker hub‰∏äÊ≥®ÂÜåË¥¶Êà∑,ÂàõÂª∫‰ªìÂ∫ì</p>
<p>ÁôªÂÖ•docker</p>
<pre><code class="language-shell">$ docker login 
</code></pre>
<p>‰øÆÊîπÊ†áÁ≠æ</p>
<pre><code class="language-shell">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
</code></pre>
<p>Êé®ÈÄÅ</p>
<pre><code class="language-shell">$ docker push username/repository:[tag]
</code></pre>
<p><strong>Êü•ÁúãÊú¨Âú∞ÂÆπÂô®,ÈïúÂÉè</strong></p>
<pre><code class="language-shell">$ docker images
$ docker ps -a
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
