<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">å¼€å§‹ä¹‹å‰</a></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">1.</strong> ğŸš§ rustå­¦ä¹ è®°å½•</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="daliy/7-2.html"><strong aria-hidden="true">1.1.</strong> 7.2</a></li><li class="chapter-item expanded "><a href="daliy/7-3.html"><strong aria-hidden="true">1.2.</strong> 7.3</a></li><li class="chapter-item expanded "><a href="daliy/7-4.html"><strong aria-hidden="true">1.3.</strong> 7.4</a></li><li class="chapter-item expanded "><a href="daliy/7-5.html"><strong aria-hidden="true">1.4.</strong> 7.5</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">2.</strong> ğŸš§ tutorialå­¦ä¹ </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="daliy/7-6.html"><strong aria-hidden="true">2.1.</strong> 7.6</a></li><li class="chapter-item expanded "><a href="daliy/7-7.html"><strong aria-hidden="true">2.2.</strong> 7.7</a></li><li class="chapter-item expanded "><a href="daliy/7-8.html"><strong aria-hidden="true">2.3.</strong> 7.8</a></li><li class="chapter-item expanded "><a href="daliy/7-10.html"><strong aria-hidden="true">2.4.</strong> 7.9-7.10 å¤šæ ¸æ”¯æŒ</a></li><li class="chapter-item expanded "><a href="daliy/7-11.html"><strong aria-hidden="true">2.5.</strong> 7.11</a></li><li class="chapter-item expanded "><a href="daliy/7-13.html"><strong aria-hidden="true">2.6.</strong> 7.13</a></li><li class="chapter-item expanded "><a href="daliy/7-14.html"><strong aria-hidden="true">2.7.</strong> 7.14</a></li><li class="chapter-item expanded "><a href="daliy/7-15.html"><strong aria-hidden="true">2.8.</strong> 7.15</a></li><li class="chapter-item expanded "><a href="daliy/7-16.html"><strong aria-hidden="true">2.9.</strong> 7.16</a></li><li class="chapter-item expanded "><a href="daliy/7-17.html"><strong aria-hidden="true">2.10.</strong> 7.17</a></li><li class="chapter-item expanded "><a href="daliy/7-18.html"><strong aria-hidden="true">2.11.</strong> 7.18</a></li><li class="chapter-item expanded "><a href="daliy/7-19.html"><strong aria-hidden="true">2.12.</strong> 7.19</a></li><li class="chapter-item expanded "><a href="daliy/7-20.html"><strong aria-hidden="true">2.13.</strong> 7.20</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">3.</strong> ğŸš§ c2rust</a></li><li class="chapter-item expanded "><a href="foo.html"><strong aria-hidden="true">4.</strong> ğŸš§ foo</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="os-camp-2021-æ¯æ—¥å­¦ä¹ å®è·µè¿‡ç¨‹è®°å½•"><a class="header" href="#os-camp-2021-æ¯æ—¥å­¦ä¹ å®è·µè¿‡ç¨‹è®°å½•">OS Camp 2021 æ¯æ—¥å­¦ä¹ å®è·µè¿‡ç¨‹è®°å½•</a></h2>
<p>ä»“åº“é“¾æ¥:<a href="https://codechina.csdn.net/weixin_49256325/os_camp">https://codechina.csdn.net/weixin_49256325/os_camp</a></p>
<p><strong>ä¸ƒæœˆ</strong></p>
<table><thead><tr><th>Mon</th><th>Tues</th><th>Wed</th><th>Thur</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody>
<tr><td></td><td></td><td>1 <br>(<a href="c2rust.html">C2RUST</a>)</td><td>2 <br>(<a href="daliy/7-2.html">D1</a>)</td><td>3 <br>(<a href="daliy/7-3.html">D2</a>)</td><td>4 <br>(<a href="daliy/7-4.html">D3</a>)</td><td>5 <br>(<a href="daliy/7-5.html">D4</a>)</td></tr>
<tr><td>6<br>(<a href="daliy/7-6.html">D5</a>)</td><td>7 <br>(<a href="daliy/7-7.html">D6</a>)</td><td>8 <br>(<a href="daliy/7-8.html">D7</a>)</td><td>9  <br>(<a href="daliy/7-10.html">D9</a>)</td><td>10 <br> (<a href="daliy/7-10.html">D9</a>)</td><td>11 <br></td><td>12 <br></td></tr>
<tr><td>13<br>(<a href="daliy/7-13.html">D12</a>)</td><td>14 <br>(<a href="daliy/7-14.html">D13</a>)</td><td>15 <br>(<a href="daliy/7-15.html">D14</a>)</td><td>16 <br>(<a href="daliy/7-16.html">D15</a>)</td><td>17 <br>(<a href="daliy/7-17.html">D16</a>)</td><td>18 <br>(<a href="daliy/7-18.html">D17</a>)</td><td>19<br>(<a href="daliy/7-18.html">D18</a>)</td></tr>
<tr><td>20<br>(<a href="daliy/7-19.html">D19</a>)</td><td>21 <br></td><td>22 <br></td><td>23 <br></td><td>24 <br></td><td>25 <br></td><td>26 <br></td></tr>
<tr><td>27 <br></td><td>28 <br></td><td>29 <br></td><td>30 <br></td><td>31 <br></td><td></td><td></td></tr>
</tbody></table>
<p><strong>å…«æœˆ</strong></p>
<table><thead><tr><th>Mon</th><th>Tues</th><th>Wed</th><th>Thur</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td></td><td></td><td>1  <br></td><td>2  <br></td></tr>
<tr><td>3  <br></td><td>4  <br></td><td>5  <br></td><td>6  <br></td><td>7  <br></td><td>8  <br></td><td>9  <br></td></tr>
<tr><td>10 <br></td><td>11 <br></td><td>12 <br></td><td>13 <br></td><td>14 <br></td><td>15 <br></td><td>16 <br></td></tr>
<tr><td>17 <br></td><td>18 <br></td><td>19 <br></td><td>20 <br></td><td>21 <br></td><td>22 <br></td><td>23 <br></td></tr>
<tr><td>24 <br></td><td>25 <br></td><td>26 <br></td><td>27 <br></td><td>28 <br></td><td>29 <br></td><td>30 <br></td></tr>
<tr><td>31 <br></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h2 id="a-hrefdaliy5c7-1htmlc2rustaä¸»è¦è®°å½•ç§»æ¤filexä¸­ä¸€äº›cè¯­è¨€ä»£ç è½¬æ¢ä¸ºrustä»£ç çš„ä¸€äº›å°è¯•"><a class="header" href="#a-hrefdaliy5c7-1htmlc2rustaä¸»è¦è®°å½•ç§»æ¤filexä¸­ä¸€äº›cè¯­è¨€ä»£ç è½¬æ¢ä¸ºrustä»£ç çš„ä¸€äº›å°è¯•"><a href="daliy%5C7-1.html">c2rust</a>ä¸»è¦è®°å½•ç§»æ¤filexä¸­ä¸€äº›cè¯­è¨€ä»£ç è½¬æ¢ä¸ºrustä»£ç çš„ä¸€äº›å°è¯•</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•"><a class="header" href="#-rustå­¦ä¹ è®°å½•">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setp0------rustç»ƒä¹ ---a-hrefhttpsgithubcomrust-langrustlingsrustlingsafont"><a class="header" href="#setp0------rustç»ƒä¹ ---a-hrefhttpsgithubcomrust-langrustlingsrustlingsafont">setp0 ---- rustç»ƒä¹  -&gt; <a href="https://github.com/rust-lang/rustlings">rustlings</a></font></a></h1>
<hr />
<p><strong>AsRef&lt;T&gt;</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
   assert_eq!(&quot;hello&quot;, s.as_ref());
}
let s = &quot;hello&quot;;
is_hello(s);
<span class="boring">}
</span></code></pre></pre>
<p><strong>as_ref()</strong> ä¸èƒ½å‡ºé”™, å¦åˆ™å°±éœ€è¦ç”¨ <strong>Option<T> or a Result&lt;T,E&gt;</strong> å½¢å¼</p>
<p></br> <br/>
<strong>enmu match ç»„åˆ</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Move(Point),
    Echo(String),
    ChangeColor((u8, u8, u8)),
    Quit,
}
fn process(&amp;mut self, message: Message) {
    match message {
        Message::Move(value) =&gt; {
            self.move_position(value) 
        }
        Message::ChangeColor(value) =&gt; {
            self.change_color(value) 
        }
        Message::Echo(value) =&gt;{
            self.echo(value)
        }
        Message::Quit =&gt;{self.quit()}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>å…¶ä¸­<strong>value</strong>æ˜¯æšä¸¾æˆå‘˜ä¸­åŒ…å«çš„ä»»æ„ç±»å‹å€¼, å¦‚æœæšä¸¾æˆå‘˜ä¸­æœ‰2ä¸ªä»¥ä¸Šå˜é‡å¯ç”¨ <strong>( _, _, value)</strong> å½¢å¼æå–ä»»æ„å˜é‡</p>
<p></br><br>
<strong>mainå‡½æ•°ä¹Ÿå¯è¿”å›'Result'</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt;Result&lt;(), E&gt;{
    let cost = xxxxxxxxxxxxxx?;
    Ok(())
}
</code></pre></pre>
<p></br> <br/></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å®Œæˆäº†rustlingsç»ƒä¹ ,é€‰å‡ ä¸ªé¢˜ç›®è®°å½•ä¸€ä¸‹,ç„¶åæ‰“ç®—å¼„ä¸€ä¸‹github+gitpod</strong></p>
<p></br><br>
<strong>åŒä¸€ä¸ªå®ä¸­ä¹Ÿå¯ç”¨ ;  éš”å¼€æ¥åŒ¹é…ä¸åŒçš„è¾“å…¥</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
    ($val:expr) =&gt; {
        println!(&quot;Look at this other macro: {}&quot;, $val);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p></br><br>
<strong>ç”¨foldæ–¹æ³•å®ç°é˜¶ä¹˜</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1..num + 1).fold(1, |acc, x| acc * x)
<span class="boring">}
</span></code></pre></pre>
<p></br><br>
<strong>Arc&lt;Mutex&lt;&gt;&gt;</strong>
</br><br>
å•ç‹¬Arc-&gt;ä¸å¯å˜å¼•ç”¨...ä½†æ˜¯ä¿è¯äº’æ–¥è®¿é—®å¤šåŠæ˜¯éœ€è¦ä¿®æ”¹å˜é‡çš„.åˆä¸å¾—ä¸åŠ ä¸ŠMutex.å½¢æˆäº†è¿™ä¸€ç»å…¸ç»„åˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
let status_shared = status.clone();
thread::spawn(move || {
    for _ in 0..10 {
        thread::sleep(Duration::from_millis(250));
        status_shared.lock().unwrap().jobs_completed += 1;
    }
});
<span class="boring">}
</span></code></pre></pre>
<p><br></br></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>setp0-3.2</strong></p>
<p>3.2è¦æ±‚:ç”¨rustå®ç°cè¯­è¨€ä¾‹å­</p>
<p><strong>æ€»ç»“</strong>:cè¯­è¨€ä¸­æŒ‡é’ˆçš„ä¸€äº›ä½¿ç”¨å¾€å¾€åœ¨rustä¸­æ²¡æœ‰ç‰¹åˆ«å¥½çš„å¯¹åº”,è¿™æ—¶å€™æœ€å¥½æ›´æ”¹æ•°æ®ç»“æ„,æ“ä½œæ–¹å¼æ¥è¾¾åˆ°ç›¸åŒåŠŸèƒ½.</p>
<p>ä¸èƒ½å¾ˆå¥½å¯¹åº”çš„æƒ…å½¢æœ‰:</p>
<p>1.ç”¨æŒ‡é’ˆåšç´¢å¼•</p>
<p>2.if (æŸæŒ‡é’ˆ) ç­‰åšåˆ¤æ–­</p>
<p><strong>ä¾‹:</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    // create two arrays we care about
    int ages[] = {23, 43, 12, 89, 2};
    char *names[] = {
        &quot;Alan&quot;, &quot;Frank&quot;,
        &quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;
    };
    // safely get the size of ages
    int count = sizeof(ages) / sizeof(int);
    int i = 0;
    // first way using indexing
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s has %d years alive.\n&quot;,
                names[i], ages[i]);
    }
    // setup the pointers to the start of the arrays
    int *cur_age = ages;
    char **cur_name = names;
    // second way using pointers
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old.\n&quot;,
                *(cur_name+i), *(cur_age+i));
    }
    // third way, pointers are just arrays
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old again.\n&quot;,
                cur_name[i], cur_age[i]);
    }
    // fourth way with pointers in a stupid complex way
    for(cur_name = names, cur_age = ages;
            (cur_age - ages) &lt; count;
            cur_name++, cur_age++)
    {
        printf(&quot;%s lived %d years so far.\n&quot;,
                *cur_name, *cur_age);
    }
    return 0;
}
</code></pre>
<p>å¦‚æœç”Ÿç¡¬ç¿»è¯‘æˆrust</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::*;

fn main() {

    let mut ages = [23,43,12,89,2];
    let mut names = [&quot;Alan&quot;, &quot;Frank&quot;,&quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;];

    let count = size_of_val(&amp;ages) / size_of::&lt;i32&gt;();
    // let count = ages.len();

    for i in 0..count {
        println!(&quot;{} has {} years alive.&quot;,names[i], ages[i]);
    }
    println!(&quot;----\n&quot;);
    let cur_age = ages.as_mut_ptr();
    let cur_name = names.as_mut_ptr();
    
    for i in 0..count{
        unsafe {
            println!(&quot;{} is {} years old.&quot;, 
            *cur_name.offset(i as isize), 
            *cur_age.offset(i as isize));
        }
    }
    println!(&quot;----\n&quot;);

    unsafe { 
        let cur_age1 = core::slice::from_raw_parts_mut(ages.as_ptr() as *mut i32, count);
        for i in 0..count{
            println!(&quot;xxxx is {} years old.&quot;,  cur_age1[i])
        }
    }
    
}
</code></pre></pre>
<p>ç›®å‰æ”¶é›†åˆ°çš„æ–¹æ³•æœ‰:</p>
<p>1.å¾—åˆ°ä¸€ä¸ªå¯å¯¹æ•°æ®è¿›è¡Œä¿®æ”¹çš„æŒ‡é’ˆ  ç„¶åä»¥å­—èŠ‚å•ä½è®¡ç®—åç§»é‡.ä¸èƒ½è¶…è¿‡isizeå¤§å°.æ¥è¾¾åˆ°ç´¢å¼•</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cur_age = ages.as_mut_ptr()   
*cur_name.offset(i as isize)      
<span class="boring">}
</span></code></pre></pre>
<p>2.å¾—åˆ°ä¸€ä¸ªi32ç±»å‹é•¿åº¦ä¸ºcountç±»å‹çš„slice.å¯ä»¥ç†è§£ä¸ºå›ºå®šå¤§å°æ•°ç»„.</p>
<p>æ­¤æ–¹æ³•å¯¹å­—ç¬¦ä¸²æ•°ç»„æ— æ•ˆ...å¯èƒ½åŸå› :å­—ç¬¦ä¸²å¤§å°ä¸å›ºå®š.æ— æ³•å‡†ç¡®è®¡ç®—å¤§å°??</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>from_raw_parts_mut(ages.as_ptr() as *mut i32, count)
<span class="boring">}
</span></code></pre></pre>
<p><strong>æ›´å¤šæœ‰å…³åŸå§‹æŒ‡é’ˆå¯æŸ¥é˜…å®˜æ–¹æ–‡æ¡£</strong>:<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset">https://doc.rust-lang.org/std/primitive.pointer.html#method.offset</a></p>
<p>è¯¥æ–‡æ¡£ç¬¬ä¸€å¥è¯<strong>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</strong></p>
<p>åœ¨æœ‰æ›¿ä»£æ–¹æ³•æ—¶å€™è¿˜æ˜¯å»ºè®®é¿å…ä½¿ç”¨.</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>leetcode</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨:https://leetcode-cn.com/problems/merge-two-sorted-lists/
pub fn merge_two_lists(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        match (l1, l2) {
            (Some(n1), None) =&gt; Some(n1),
            (None, Some(n2)) =&gt; Some(n2),

            (Some(mut n1), Some(mut n2)) =&gt; {
                if n1.val &lt; n2.val {
                    let n = n1.next.take();
                    n1.next = merge_two_lists(n, Some(n2));
                    Some(n1)
                } else {
                    let n = n2.next.take();
                    n2.next = merge_two_lists(Some(n1), n);
                    Some(n2)
                }
            },
            _ =&gt; None,
        }
}
<span class="boring">}
</span></code></pre></pre>
<p>matchå¯ä»¥æ¥å—å¤šä¸ªå€¼.ä»¥å…ƒç»„å½¢å¼å­˜åœ¨</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•-1"><a class="header" href="#-rustå­¦ä¹ è®°å½•-1">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-1"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-1">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="76"><a class="header" href="#76">7.6</a></h1>
<p><strong>å¼€å§‹tutorial!</strong></p>
<p><strong>ä½¿ç”¨é“¾æ¥è„šæœ¬æŒ‡å®šç¨‹åºå†…å­˜å¸ƒå±€</strong></p>
<p>ä¸€èˆ¬æ¥è¯´ï¼Œä¸€ä¸ªç¨‹åºæŒ‰ç…§åŠŸèƒ½ä¸åŒä¼šåˆ†ä¸ºä¸‹é¢è¿™äº›æ®µï¼š</p>
<table><tr><td bgcolor=#EFF5FF>
.text æ®µï¼Œå³ä»£ç æ®µï¼Œå­˜æ”¾ä»£ç  å‡ºé”™æ—¶å€™çš„eipå¾€å¾€åœ¨è¿™ä¸ªæ®µ.æŒ‡å‘æŸä¸€æ¡è¯­å¥.ä»¥æ­¤æ¥å®šä½é—®é¢˜ï¼›
<p>.rodata æ®µï¼Œå³åªè¯»æ•°æ®æ®µï¼Œé¡¾åæ€ä¹‰é‡Œé¢å­˜æ”¾åªè¯»æ•°æ®ï¼Œé€šå¸¸æ˜¯ç¨‹åºä¸­çš„å¸¸é‡ï¼›</p>
<p>.data æ®µï¼Œå­˜æ”¾è¢«åˆå§‹åŒ–çš„å¯è¯»å†™æ•°æ®ï¼Œé€šå¸¸ä¿å­˜ç¨‹åºä¸­çš„å…¨å±€å˜é‡ï¼›</p>
<p>.bss æ®µï¼Œå­˜æ”¾è¢«åˆå§‹åŒ–ä¸º 00 çš„å¯è¯»å†™æ•°æ®ï¼Œä¸ .data æ®µçš„ä¸åŒä¹‹å¤„åœ¨äºæˆ‘ä»¬çŸ¥é“å®ƒè¦è¢«åˆå§‹åŒ–ä¸º 00 ï¼Œå› æ­¤åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­åªéœ€è®°å½•è¿™ä¸ªæ®µçš„å¤§å°ä»¥åŠæ‰€åœ¨ä½ç½®å³å¯ï¼Œè€Œä¸ç”¨è®°å½•é‡Œé¢çš„æ•°æ®ã€‚</p>
<p>stack ï¼Œå³æ ˆï¼Œç”¨æ¥å­˜å‚¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­çš„å±€éƒ¨å˜é‡ï¼Œä»¥åŠè´Ÿè´£å‡½æ•°è°ƒç”¨æ—¶çš„å„ç§æœºåˆ¶ã€‚å®ƒä»é«˜åœ°å€å‘ä½åœ°å€å¢é•¿ï¼›</p>
<p>heap ï¼Œå³å †ï¼Œç”¨æ¥æ”¯æŒç¨‹åº<b><font color=#42ACF4>è¿è¡Œè¿‡ç¨‹</font></b>ä¸­å†…å­˜çš„åŠ¨æ€åˆ†é…ï¼Œæ¯”å¦‚è¯´ä½ è¦è¯»è¿›æ¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåœ¨ä½ å†™ç¨‹åºçš„æ—¶å€™ä½ ä¹Ÿä¸çŸ¥é“å®ƒçš„é•¿åº¦ç©¶ç«Ÿä¸ºå¤šå°‘ï¼Œäºæ˜¯ä½ åªèƒ½åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼ŒçŸ¥é“äº†å­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹åï¼Œå†åœ¨å †ä¸­ç»™è¿™ä¸ªå­—ç¬¦ä¸²åˆ†é…å†…å­˜ã€‚</p>
</td></tr></table>
<p>é“¾æ¥è„šæœ¬ç¤ºä¾‹:</p>
<pre><code class="language-linker">
SECTIONS
{
. = 0x10000;
.text : { *(.text) }
. = 0x8000000;
.data : { *(.data) }
.bss : { *(.bss) }
}
</code></pre>
<p><b></b>
. è¡¨ç¤ºèµ·å§‹åœ°å€ å¦‚æœæ²¡æœ‰è¿™ä¸ªåœ°å€ï¼Œé»˜è®¤è¯¥ç¬¦å·çš„å€¼ä¸º0</p>
<p>.text : { *(.text) } : å°†æ‰€æœ‰(*ç¬¦å·ä»£è¡¨ä»»æ„è¾“å…¥æ–‡ä»¶)æ–‡ä»¶çš„.text sectionåˆå¹¶æˆä¸€ä¸ª.text section,è¯¥sectionçš„åœ°å€ç”±å®šä½å™¨ç¬¦å·çš„å€¼æŒ‡å®š, å³0x10000.</p>
<p>. = 0x8000000 ï¼šæŠŠå®šä½å™¨ç¬¦å·ç½®ä¸º0x8000000</p>
<p>.data : { *(.data) } : åŒä¸Š</p>
<p>.bss : { *(.bss) } :  åŒä¸Š</p>
<p><strong>å…¶ä»–å‘½ä»¤</strong>
ENTRY(SYMBOL) :å°†ç¬¦å·SYMBOLçš„å€¼è®¾ç½®æˆå…¥å£åœ°å€ã€‚</p>
<p>INCLUDE filename : åŒ…å«å…¶ä»–åä¸ºfilenameçš„é“¾æ¥è„šæœ¬</p>
<p>INPUT(files): å°†æ‹¬å·å†…çš„æ–‡ä»¶åšä¸ºé“¾æ¥è¿‡ç¨‹çš„è¾“å…¥æ–‡ä»¶</p>
<p>GROUP(files) : æŒ‡å®šéœ€è¦é‡å¤æœç´¢ç¬¦å·å®šä¹‰çš„å¤šä¸ªè¾“å…¥æ–‡ä»¶</p>
<p>OUTPUT(FILENAME) : å®šä¹‰è¾“å‡ºæ–‡ä»¶çš„åå­—</p>
<p>SEARCH_DIR(PATH) ï¼šå®šä¹‰æœç´¢è·¯å¾„ï¼Œ</p>
<p>OUTPUT_ARCH() : è®¾ç½®è¾“å‡ºæ–‡ä»¶çš„ä½“ç³»ç»“æ„</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>pythonç”Ÿæˆé“¾æ¥è„šæœ¬,ä»¥åŠç”¨æˆ·ç¨‹åºbuild</strong></p>
<p>å¤šä¸ªç”¨æˆ·ç¨‹åºbuild</p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()
for app in apps:
    app = app[:app.find('.')]
    lines = []
    lines_before = []
    with open(linker, 'r') as f:
        for line in f.readlines():
            lines_before.append(line)
            line = line.replace(hex(base_address), hex(base_address+step*app_id))
            lines.append(line)
    with open(linker, 'w+') as f:
        f.writelines(lines)
    os.system('cargo build --bin %s --release' % app)
    print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
    with open(linker, 'w+') as f:
        f.writelines(lines_before)
    app_id = app_id + 1

</code></pre>
<p><strong>ç”Ÿæˆbinæ–‡ä»¶...objcopy</strong></p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()

for app in apps:
    app = app.strip('.rs')
    os.system('rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/%s --strip-all -O binary  target/riscv64gc-unknown-none-elf/release/%s.bin'%(app,app))
</code></pre>
<p><strong>ç”Ÿæˆé“¾æ¥è„šæœ¬link_app.S  ç›®å½•ä¸‹æ‰€æœ‰binæ–‡ä»¶å†™è¿›é“¾æ¥è„šæœ¬</strong></p>
<pre><code class="language-python">import os


f = open('link_app.S', 'w')

f.writelines(&quot;    .align 3\n&quot;)
f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global _num_app\n&quot;)
f.writelines(&quot;_num_app:\n&quot;)
apps = os.listdir('target/riscv64gc-unknown-none-elf/release')
num = 0

bin_list = []
for app in apps:
    if 'bin' in app:
        num += 1
        bin_list.append(app)

f.writelines(&quot;    .quad %s\n&quot; %len(bin_list))

count  = 0
for app in bin_list:
    f.writelines(&quot;    .quad app_%s_start\n&quot; %count)
    count += 1

f.writelines(&quot;\n&quot;)

f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global app_0_start\n&quot;)
f.writelines(&quot;    .global app_0_end\n&quot;)

for i in range(len(bin_list)):
    f.writelines(&quot;app_%s_start:\n&quot; %i)
    f.writelines(&quot;    .incbin \&quot;../test/target/riscv64gc-unknown-none-elf/release/%s\&quot;\n&quot; %bin_list[i])
    f.writelines(&quot;app_%s_end:\n\n&quot; %i)
    
f.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ"><a class="header" href="#æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ">æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ</a></h1>
<p>åœ¨intelæ‰‹å†Œ8.4 MULTIPLE-PROCESSOR (MP) INITIALIZATION å¯æŸ¥åˆ°å¤šæ ¸å¯åŠ¨ç›¸å…³ä¿¡æ¯.</p>
<font size = 3> 
8.4.1 BSP and AP Processors
The MP initialization protocol defines two classes of processors: the bootstrap processor (BSP) and the application
processors (APs). Following a power-up or RESET of an MP system, system hardware dynamically selects one of the
processors on the system bus as the BSP. The remaining processors are designated as APs.
As part of the BSP selection mechanism, the BSP flag is set in the IA32_APIC_BASE MSR (see Figure 10-5) of the
BSP, indicating that it is the BSP. This flag is cleared for all other processors.
The BSP executes the BIOSâ€™s boot-strap code to configure the APIC environment, sets up system-wide data structures, and starts and initializes the APs. When the BSP and APs are initialized, the BSP then begins executing the
operating-system initialization code.
</font>
<br></br>
<font size = 3> 
Following a power-up or reset, the APs complete a minimal self-configuration, then wait for a startup signal (a SIPI
message) from the BSP processor. Upon receiving a SIPI message, an AP executes the BIOS AP configuration code,
which ends with the AP being placed in halt state.
For Intel 64 and IA-32 processors supporting Intel Hyper-Threading Technology, the MP initialization protocol treats
each of the logical processors on the system bus or coherent link domain as a separate processor (with a unique
APIC ID). During boot-up, one of the logical processors is selected as the BSP and the remainder of the logical
processors are designated as APs.
</font>
<p>åœ¨å¯åŠ¨æ—¶å€™.ä¼šé€‰å‡ºä¸€ä¸ªæ ¸ä½œä¸ºBSP. åŒæ—¶è®¾ç½®å…¶ä»–æ ¸(APs)çš„flagä¿¡æ¯.ç„¶åç”±BSPæ¥æ‰§è¡Œåˆå§‹åŒ–å…¶ä»–æ ¸(APs). å½“BSPå’ŒAPséƒ½åˆå§‹åŒ–å®Œæˆå,ç”±BSPæ¥æ‰§è¡Œç³»ç»Ÿåˆå§‹åŒ–ä»£ç </p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å­¦ä¹ å¤šæ ¸å¯åŠ¨æ”¯æŒ</strong></p>
<p><strong>å‚è€ƒå·²æœ‰çš„å®ç°</strong></p>
<p>ä¸»è¦çœ‹é“¾æ¥è„šæœ¬ä¸­æŒ‡å®šçš„å…¥å£æ±‡ç¼–ä»£ç ,ä»¥åŠæ¥ä¸‹æ¥è·³è½¬åˆ°çš„ä»£ç </p>
<p>1.rcore</p>
<pre><code class="language-x86asm">    .section .text.entry
    .globl _start
_start:
    # a0 == hartid
    # pc == 0x80200000
    # sp == 0x800xxxxx

    # 1. set sp
    # sp = bootstack + (hartid + 1) * 0x10000
    add     t0, a0, 1
    slli    t0, t0, 14
    lui     sp, %hi(bootstack)
    add     sp, sp, t0

....(ç•¥)

    # 3. jump to rust_main (absolute address)
    lui     t0, %hi(rust_main)
    addi    t0, t0, %lo(rust_main)
    jr      t0

    .section .bss.stack
    .align 12   # page align
    .global bootstack
bootstack:
    .space 4096 * 4 * 8
    .global bootstacktop
bootstacktop:

    .section .data
    .align 12   # page align
....(ç•¥)
</code></pre>
<p><strong>åŠ è½½å¸¸é‡åˆ°æŸå¯„å­˜å™¨å¸¸ç”¨çš„æ±‡ç¼–ä»£ç </strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(constant)
addi    t0, t0, %lo(constant)
</code></pre>
<p><strong>åŠ è½½ç»å¯¹åœ°å€åˆ°æŸå¯„å­˜å™¨</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(address)
addi    t0, t0, %lo(address)
</code></pre>
<p>æœ‰äº†è¿™ä¸ªåŸºç¡€è¿™æ®µä»£ç å°±å¥½ç†è§£äº†
ä¸ºå½“å‰æ ¸å¿ƒè®¾ç½®ä¸€ä¸ªæ ˆ,åœ°å€ä¸º:sp = bootstack + (hartid + 1) * 0x10000
å†è·³è½¬åˆ°rust_main....</p>
<p><strong>next:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn rust_main(hartid: usize, device_tree_paddr: usize) -&gt; ! {
    let device_tree_vaddr = phys_to_virt(device_tree_paddr);

    unsafe {
        cpu::set_cpu_id(hartid);
    }

    if hartid != BOOT_HART_ID {
        while !AP_CAN_INIT.load(Ordering::Relaxed) {}
        others_main(hartid);
    }

    unsafe {
        memory::clear_bss();
    }

    println!(
        &quot;Hello RISCV! in hart {}, device tree @ {:#x}&quot;,
        hartid, device_tree_vaddr
    );

    crate::logging::init();
    unsafe {
        trapframe::init();
    }
    memory::init(device_tree_vaddr);
    timer::init();
    // FIXME: init driver on u540
    #[cfg(not(any(feature = &quot;board_u540&quot;)))]
    board::init(device_tree_vaddr);
    unsafe {
        board::init_external_interrupt();
    }
    crate::process::init();

    AP_CAN_INIT.store(true, Ordering::Relaxed);
    crate::kmain();
}

fn others_main(hartid: usize) -&gt; ! {
    unsafe {
        trapframe::init();
    }
    memory::init_other();
    timer::init();
    info!(&quot;Hello RISCV! in hart {}&quot;, hartid);
    crate::kmain();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>rust_mainçš„å¤šæ ¸å¤„ç†</strong></p>
<p>1.è®¾ç½®thread_pointerä¸ºhartid</p>
<p>2.é¦–å…ˆè®©hartid = BOOT_HART_IDæ‰§è¡Œå®Œrust_main,åŒæ—¶å¦‚æœå…¶ä»–hartè¿›å…¥åˆ°æ­¤å‡½æ•°åˆ™å¾ªç¯ç­‰å¾….ç›´åˆ°BST(boot_hart)æ‰§è¡Œå¯åŠ¨ä»£ç ,å¹¶è®¾ç½®åŸå­æ“ä½œæ“ä½œAP_CAN_INIT.store(true, Ordering::Relaxed)å,å†æ‰§è¡Œå…¶ä»–hartçš„åˆå§‹åŒ–æ“ä½œ.</p>
<p>è¿™é‡Œç”¨åˆ°äº†rustä¸­çš„atomicåŸºæœ¬ç”¨æ³•å¦‚ä¸‹:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicBool, Ordering};
let some_bool = AtomicBool::new(true);
some_bool.store(false, Ordering::Relaxed);
assert_eq!(some_bool.load(Ordering::Relaxed), false);
<span class="boring">}
</span></code></pre></pre>
<table><td bgcolor=#EFF5FF>
ç”³è¯·ä¸€ä¸ªåŸå­å‹boolå˜é‡åˆå§‹åŒ–ä¸ºtrue. AtomicBool::new(true)
<p>load(Ordering::Relaxed)æ¥è·å¾—å˜é‡å€¼</p>
<p>store(false, Ordering::Relaxed)æ¥æ”¹å˜å€¼</p>
</td></table>
<p><strong>å¤šæ ¸å¯åŠ¨æ¦‚æ‹¬</strong></p>
<p>1.è®©ä¸»æ ¸(BST)æ‰§è¡Œå®Œå¯åŠ¨ä»£ç .åŒæ—¶è®¾ç½®åŸå­æ“ä½œè®©å…¶ä»–æ ¸ç­‰å¾….ç„¶åæ‰§è¡Œå…¶ä»–æ ¸(AP)çš„å¯åŠ¨ä»£ç .</p>
<p>2.ä¸ºæ¯ä¸ªæ ¸è®¾ç½®å¥½æ ˆ</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å®ç°ä¸­æ–­æœºåˆ¶</strong></p>
<p>å†…æ ¸æ ˆ:å›ºå®šå¤§å°,æ¯ä¸ªè¿›ç¨‹,çº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªå†…æ ¸æ ˆ.å†…æ ¸æ ˆæ˜¯è¿›ç¨‹,çº¿ç¨‹åœ¨å†…æ ¸æ€ä¸‹æ‰€ä½¿ç”¨çš„æ ˆ.åœ¨ç”¨æˆ·æ€ä¸‹cpuçš„spæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ç”¨æˆ·æ ˆçš„æ ˆé¡¶.å†…æ ¸æ€ä¸‹æŒ‡å®šå†…æ ¸æ ˆçš„æ ˆé¡¶.</p>
<p><strong>ä¸­æ–­å®ç°æ€è·¯</strong></p>
<table><tr><td bgcolor=#EFF5FF>
1.åŒºåˆ†æ˜¯ä»ç”¨æˆ·æ€è¿˜æ˜¯å†…æ ¸æ€ä¸­æ–­, ä¿å­˜32ä¸ªé€šç”¨å¯„å­˜å™¨ä»¥åŠä¸€äº›æ§åˆ¶ä¸çŠ¶æ€å¯„å­˜å™¨csr.ç„¶åè·³è½¬åˆ°ä¸­æ–­å¤„ç†å‡½æ•°  æ­¤éƒ¨åˆ†ç”¨æ±‡ç¼–è¯­è¨€å†™
<p>2.è¿›å…¥ä¸­æ–­å¤„ç†å‡½æ•°,printä¸­æ–­æ¥æº(ç”¨æˆ·æ€orå†…æ ¸æ€) å½“å‰ä¸­æ–­æŒ‡ä»¤(pc) ä¸­æ–­åŸå› (è¯»å–scauseå¯„å­˜å™¨)
# å¦‚æœä»å†…æ ¸æ€è¿›å…¥ä¸­æ–­ï¼Œ sstatus çš„ SPP ä½è¢«ç¡¬ä»¶è®¾ä¸º 1
# å¦‚æœä»ç”¨æˆ·æ€è¿›å…¥ä¸­æ–­ï¼Œ sstatus çš„ SPP ä½è¢«ç¡¬ä»¶è®¾ä¸º 0</p>
<p>3.æ¢å¤ä¸Šä¸‹æ–‡. æ¢å¤32ä¸ªé€šç”¨å¯„å­˜å™¨,ä»¥åŠä¸€äº›csrå¯„å­˜å™¨.</p>
</td></tr></table>
<p>æŒ‰ç…§ TrapContext ç»“æ„ä½“çš„å†…å­˜å¸ƒå±€ï¼Œå®ƒä»ä½åœ°å€åˆ°é«˜åœ°å€åˆ†åˆ«æŒ‰é¡ºåºæ”¾ç½® x0~x31ï¼Œæœ€åæ˜¯ sstatus å’Œ sepc ã€‚å› æ­¤é€šç”¨å¯„å­˜å™¨ xn åº”è¯¥è¢«ä¿å­˜åœ¨åœ°å€åŒºé—´ [sp+8n,sp+8(n+1)) ã€‚ åœ¨è¿™é‡Œæˆ‘ä»¬æ­£æ˜¯è¿™æ ·åŸºäº sp æ¥ä¿å­˜è¿™äº›é€šç”¨å¯„å­˜å™¨çš„ã€‚
(ä¸»è¦ä¿å­˜trapframeä¸­å†…å®¹)ä¿å­˜32ä¸ªé€šç”¨å¯„å­˜å™¨ä»¥åŠä¸€äº›æ§åˆ¶ä¸çŠ¶æ€å¯„å­˜å™¨csr æ­¤éƒ¨åˆ†ä¸trapframeç»“æ„ä½“ä¸€è‡´. æ¢å¤æ—¶åªè¦æŠŠç»“æ„ä½“æŒ‡é’ˆæŒ‡å‘spå°±èƒ½æ¢å¤trapframe</p>
<p>csrrw rd, csr, rs å¯ä»¥å°† CSR å½“å‰çš„å€¼è¯»åˆ°é€šç”¨å¯„å­˜å™¨ rd ä¸­ï¼Œç„¶åå°† é€šç”¨å¯„å­˜å™¨ rs çš„å€¼å†™å…¥è¯¥ CSR ã€‚å› æ­¤è¿™é‡Œèµ·åˆ°çš„æ˜¯äº¤æ¢ sscratch å’Œ sp çš„æ•ˆæœã€‚åœ¨è¿™ä¸€è¡Œä¹‹å‰ sp æŒ‡å‘ç”¨æˆ·æ ˆï¼Œ sscratch æŒ‡å‘å†…æ ¸æ ˆï¼Œç°åœ¨ sp æŒ‡å‘å†…æ ¸æ ˆï¼Œ sscratch æŒ‡å‘ç”¨æˆ·æ ˆã€‚</p>
<hr />
<p>ä»ç”¨æˆ·æ€ä¸­æ–­æ—¶,spæŒ‡å‘å†…æ ¸æ ˆ.ç„¶ååœ¨sp[...]åŒºé—´ä¸­ä¿å­˜trapcontextå†…å®¹</p>
<p><strong>ç–‘é—®</strong>:(ä¸­æ–­å¤„ç†ç¨‹åºç”¨çš„ä¹Ÿæ˜¯å†…æ ¸æ ˆ,éš¾é“æ‰§è¡Œæµä¸ä¼šæ”¹å˜å†…æ ¸æ ˆä¸­çš„å†…å®¹å—? é‚£ä¿å­˜äº†è¿˜æœ‰ä»€ä¹ˆæ„ä¹‰. è¯¥æ‰§è¡Œæµä»…ä¼šæ”¹åŠ¨trapcontextä¸­çš„å†…å®¹å—?)</p>
<p><strong>åˆ†æ</strong>:spæ°¸è¿œæŒ‡å‘æ‰§è¡Œæµä¸­çš„æ ˆ.æ‰€ä»¥ä¸­æ–­å¤„ç†ç¨‹åºè¿è¡Œæ—¶å€™å¹¶ä¸ä¼šå¹²æ‰°åˆ°åŸæœ¬ä¿æŒçš„å†…å®¹</p>
<p>more:å†…æ ¸æ ˆå¯ä»¥ç†è§£ä¸ºæ˜¯ä¸€ä¸ªä¸­æ–­å‘ç”Ÿæ—¶ä¸´æ—¶å­˜æ”¾é€šç”¨å¯„å­˜å™¨ä»¥åŠæŒ‡ä»¤ä¸çŠ¶æ€å¯„å­˜å™¨ä¿¡æ¯çš„æ ˆ. å®é™…å†…æ ¸åœ¨æ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°æ—¶å¹¶ä¸ä¼šç”¨åˆ°è¯¥æ ˆ(æŒ‡çš„æ˜¯ä¸ä¿®æ”¹.è¿˜æ˜¯å¯ä»¥ä»ä¸­è¯»å–ä¸€äº›ä¿¡æ¯),å†…æ ¸æ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°æ—¶æ‰€ä½¿ç”¨çš„æ ˆæ˜¯sp.(åœ¨ä»»ä½•æ‰§è¡Œæµä¸­ä½¿ç”¨çš„æ ˆéƒ½åº”è¯¥æ˜¯sp)</p>
<hr />
<p><strong>addi sp, sp, -34*8</strong>ä¸ºä»€ä¹ˆè¿™æ¡æŒ‡ä»¤å¯ä»¥è¡¨ç¤ºåˆ†é…äº†æ ˆå¸§. å¯ä»¥ç†è§£ä¸ºspæŒ‡å‘çš„æ˜¯æ ˆé¡¶.ç°åœ¨å¢åŠ spçš„å€¼æ„å‘³ç€æ ˆé¡¶çš„æé«˜.ç›¸å½“äºåˆ†é…äº†ç©ºé—´</p>
<hr />
<p><strong>æ—¶é’Ÿä¸­æ–­</strong></p>
<p>ç›¸å…³å¯„å­˜å™¨ mtime  â€‹mtimecmp   mie  sie sip</p>
<p>SI(Software Interrupt)ï¼Œè½¯ä»¶ä¸­æ–­
TI(Timer Interrupt)ï¼Œæ—¶é’Ÿä¸­æ–­
EI(External Interrupt)ï¼Œå¤–éƒ¨ä¸­æ–­</p>
<p>â€‹mtimecmp â€‹= â€‹mtime â€‹+ â€‹Xâ€‹
A timer interrupt (if enabled) is generated whenever â€‹mtime â€‹is greater than or equal to the valuein the â€‹mtimecmp â€‹register. Therefore, to generate a timer interrupt after â€‹X â€‹cycles, one can updatemtimecmp â€‹register as follows: â€‹mtimecmp â€‹= â€‹mtime â€‹+ â€‹Xâ€‹.</p>
<p>// æ ¹æ®ä¸­æ–­åŸå› åˆ†ç±»è®¨è®º</p>
<pre><code>// åªèƒ½å½“æ¯ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­è§¦å‘æ—¶
// è®¾ç½®ä¸‹ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­çš„è§¦å‘æ—¶é—´
// è®¾ç½®ä¸ºå½“å‰æ—¶é—´åŠ ä¸Š TIMEBASE
// è¿™æ¬¡è°ƒç”¨ç”¨æ¥é¢„å¤„ç†
</code></pre>
<p>æ ¹ç»scause åŒºåˆ†ä¸­æ–­ç±»åˆ«.   è¯¥æœ‰ä¸åŒçš„å¤„ç†äº†   ä»¥åŠè®¾ç½®å¤šå°‘cycleè§¦å‘ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ä¸­æ–­å…·ä½“å®ç°</strong></p>
<p><strong>æ•´ç†ä¸‹ä¸­æ–­æ“ä½œç›¸å…³çš„csrå¯„å­˜å™¨</strong></p>
<blockquote>
<p><strong>sepc</strong>:å‘ç”Ÿå¼‚å¸¸çš„æŒ‡ä»¤çš„pcè¢«å­˜å…¥sepc. æˆ‘ä»¬éœ€è¦è¯»å–ä»–æ¥è·å¾—bugä¿¡æ¯.</p>
<p><strong>stvec</strong>:riscvå¤„ç†å™¨trapåè·³å…¥çš„PCåœ°å€ç”±ä¸€ä¸ªå«åšæœºå™¨æ¨¡å¼å¼‚å¸¸å…¥å£åŸºåœ°å€å¯„å­˜å™¨mtvecçš„csrå¯„å­˜å™¨æŒ‡å®š. mtvecæ˜¯ä¸€ä¸ªå¯è¯»å¯å†™çš„å¯„å­˜å™¨, è½¯ä»¶å¯ä»¥ç¼–ç¨‹è®¾å®šå®ƒçš„å€¼.åœ¨Sæ¨¡å¼ä¸‹ç”¨åˆ°çš„å¯„å­˜å™¨å³ä¸ºstvec.æˆ‘ä»¬éœ€è¦ç”¨å†™stvecæ¥è·³è½¬åˆ°ä¸­æ–­å¤„ç†ä»£ç .trap.asmä¸­çš„__alltrapså¤„</p>
<p><strong>scaues</strong>:å®ƒä¼šè®°å½•ä¸­æ–­å‘ç”Ÿçš„åŸå› , éœ€è¦ç”¨è¯»å–è¯¥å¯„å­˜å™¨æ¥æ ¹æ®ä¸åŒç±»å‹ä¸­æ–­æ‰§è¡Œä¸åŒå¤„ç†ä»£ç </p>
<p><strong>sstatus</strong>:éœ€è¦è®¾ç½®å®ƒçš„sieä½æ¥ä½¿èƒ½ä¸­æ–­</p>
</blockquote>
<p><strong>å¦‚ä½•è¯»å†™csrå¯„å­˜å™¨</strong></p>
<p>è¯»å†™satpå¯„å­˜å™¨ä¸ºä¾‹:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, satp&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn write(x: usize) {
    llvm_asm!(&quot;csrw satp, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆå§‹åŒ–ä¸­æ–­</strong></p>
<p>åœ¨å¤„ç†å™¨çš„ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­,ä¸€æ—¦å‘ç”Ÿå¼‚å¸¸,åˆ™ç»ˆæ­¢å½“å‰çš„ç¨‹åºæµ,å¤„ç†å™¨è¢«å¼ºè¡Œè·³è½¬åˆ°ä¸€ä¸ªæ–°çš„PCåœ°å€ã€‚</p>
<p>åœ¨riscvä¸­Sæ€è¯¥åœ°å€ç”±stvecæŒ‡å®šstvecä½2ä½ä½modeåŸŸ,é«˜30ä½æ˜¯baseåŸŸ.</p>
<p>å½“<strong>MODE</strong>=0ï¼Œè®¾ç½®ä¸º Direct æ¨¡å¼æ—¶ï¼Œåˆ™æ‰€æœ‰çš„å¼‚å¸¸å“åº”æ—¶å¤„ç†å™¨å‡è·³è½¬åˆ°baseå€¼æŒ‡ç¤ºçš„pcåœ°å€ã€‚</p>
<p>å½“<strong>MODE=1</strong>æ—¶ï¼Œè®¾ç½®ä¸º Vectored æ¨¡å¼æ—¶ï¼Œé‡åˆ°ä¸­æ–­æˆ‘ä»¬ä¼šè¿›è¡Œè·³è½¬å¦‚ä¸‹ï¼šPC-&gt;BASE + 4 x causeã€‚è€Œè¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€å°†å„ä¸­æ–­å¤„ç†ç¨‹åºæ”¾åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œå¹¶è®¾ç½®å¥½ stvec ï¼Œé‡åˆ°ä¸­æ–­çš„æ—¶å€™ç¡¬ä»¶æ ¹æ®ä¸­æ–­åŸå› å°±ä¼šè‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”çš„ä¸­æ–­å¤„ç†ç¨‹åºäº†</p>
<p>åœ¨æ­¤æˆ‘ä»¬é€‰æ‹©Directæ¨¡å¼.è·³è½¬åˆ°ç»Ÿä¸€åœ°å€è¿›è¡Œå¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init() {
    unsafe {
        extern &quot;C&quot; {
            fn __alltraps();
        }
        //è®¾ç½®trapè·³è½¬åˆ°ç»Ÿä¸€åœ°å€ __alltrapså¤„
        println!(&quot;trap init--------------&quot;);
        stvec::write(__alltraps as usize);
        sstatus::set_sie();
    }
    println!(&quot;++++ setup interrupt! ++++&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>stvec</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub unsafe fn _write(x: usize) {
    llvm_asm!(&quot;csrw stvec, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
//0ä¸ºè®¾ç½®æˆDirectæ¨¡å¼
#[inline]
pub unsafe fn write(addr: usize) {
    _write(addr + 0 as usize);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>sstatus</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIE: usize = 1 &lt;&lt; 1;  // supervisor interrupt enable
#[inline]
pub fn write(x: usize) {
    unsafe {llvm_asm!(&quot;csrw sstatus, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);}
}

#[inline]
pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, sstatus&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}

#[inline]
pub fn set_sie() {
    write(read() | SIE);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>__alltrap</strong></p>
<pre><code class="language-x86asm">__alltraps:
    csrrw sp, sscratch, sp       äº¤æ¢ç”¨æˆ·æ ˆå’Œå†…æ ¸æ ˆ
    addi sp, sp, -34*8           åœ¨å†…æ ¸æ ˆä¸Šåˆ†é…ä¸€ä¸ªtrapcontextå¤§å°çš„æ ˆå¸§
    
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct TrapContext {
    // 32ä¸ªé€šç”¨å¯„å­˜å™¨ 
    pub x: [usize; 32], 
    // å‡ ä¸ªç›¸å…³csrå¯„å­˜å™¨
    pub sstatus: usize,
    pub sepc: usize,
    pub stval: usize,
    pub scause: usize,
    //å…±éœ€(32+4)*8çš„æ ˆç©ºé—´
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>trap.asm</strong></p>
<pre><code class="language-x86asm">	.section .text
	.globl __alltraps
__alltraps:
	SAVE_ALL
	mv a0, sp
	jal trap_handler

	.globl __trapret
__trapret:
	RESTORE_ALL
	sret

.equ XLENB, 8
.macro LOAD a1, a2
	ld \a1, \a2*XLENB(sp)
.endm

.macro STORE a1, a2
	sd \a1, \a2*XLENB(sp)
.endm
</code></pre>
<p><strong>save_allå’Œrestore_all</strong></p>
<pre><code class="language-x86asm">
.macro SAVE_ALL
	csrrw sp, sscratch, sp
	addi sp, sp, -36*XLENB
	STORE x1, 1
	STORE x3, 3
...
    STORE x30, 30
    STORE x31, 31

	csrrw s0, sscratch, x0
	csrr s1, sstatus
	csrr s2, sepc
	csrr s3, stval
	csrr s4, scause
	
	STORE s0, 2
	STORE s1, 32
	STORE s2, 33
	STORE s3, 34
	STORE s4, 35
.endm
</code></pre>
<pre><code class="language-x86asm">.macro RESTORE_ALL
	LOAD s1, 32
	LOAD s2, 33
	andi s0, s1, 1 &lt;&lt; 8
    csrw sstatus, s1
    csrw sepc, s2
	LOAD x1, 1
	LOAD x3, 3
...
    LOAD x30, 30
    LOAD x31, 31

	LOAD x2, 2
.endm
</code></pre>
<p>åˆ†åˆ«ç”¨ldå’Œsdæ¥ä¿å­˜é€šç”¨å¯„å­˜å™¨.64ä½æ•°æ®éœ€è¦8å­—èŠ‚ç©ºé—´å­˜å‚¨.ç”¨å¯„å­˜å™¨ç¼–å·*8(sp)æ¥å­˜æ”¾åˆ°trapcontextä¸­ç›¸åº”ä½ç½®å»
åŒºåˆ†æ˜¯ä»ç”¨æˆ·æ€ä¸­æ–­è¿˜æ˜¯ä»å†…æ ¸æ€ä¸­æ–­.åªéœ€åˆ¤æ–­spæ˜¯å¦ä¸º0.sp!=0åˆ™æ˜¯ä»ç”¨æˆ·æ€è¿›å…¥ä¸­æ–­.sp=0åˆ™æ˜¯ä»å†…æ ¸æ€è¿›å…¥ä¸­æ–­.æ— éœ€åˆ‡æ¢æ ˆ</p>
<p>å®ç°ä¸­æ–­å¤„ç†å‡½æ•°trap_handler</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    match cause {

        3 =&gt; breakpoint(&amp;mut tf.sepc),
        5 =&gt; super_timer(),
        12 =&gt; page_fault(tf),
        13 =&gt; page_fault(tf),
        15 =&gt; page_fault(tf),
        _ =&gt; println!(&quot;undefined trap!&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>1.æ‰“å°å‡ºä¸­æ–­ç±»å‹,ä»¥åŠè§¦å‘ä¸­æ–­æŒ‡å®šçš„pcå€¼.ä»¥ä¾¿ä»¥åè°ƒè¯•</p>
<p>2.æ ¹æ®causeä¸åŒåˆ†åˆ«è¿›è¡Œä¸åŒçš„å¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>å¦‚æœæ˜¯æ–­ç‚¹åˆ™æ‰“å°æ–­ç‚¹pc. ç„¶åpc+2.æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ (riscv64æŒ‡å®šé•¿åº¦ä¸º4å­—èŠ‚.åŸæ¥åº”è¯¥æ˜¯sepc+4.ä½†æ˜¯ç¼–è¯‘å™¨çš„è¡Œä¸ºä¼šå‹ç¼©.æ‰€ä»¥ä¿®æ­£ä¸ºsepc+2)
fn breakpoint(sepc: &amp;mut usize) {
    println!(&quot;a breakpoint epc:0x{:x}&quot;, sepc);
    *sepc += 2;
}

æ¯æ¬¡è§¦å‘æ—¶é’Ÿä¸­æ–­TICKS+1.è§¦å‘100æ¬¡æ‰“å°ä¸€æ¬¡.
fn super_timer() {
    clock_set_next_event();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}

//page_fault
fn page_fault(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    println!(&quot;{:?} va = {:#x} instruction = {:#x}&quot;, cause, tf.stval, tf.sepc);
    panic!(&quot;page fault!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>è‡³æ­¤trapå¯ä»¥å¯ä»¥æ­£å¸¸å·¥ä½œ</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è¿è¡Œåº”ç”¨ç¨‹åº</strong></p>
<p><strong>å°†åº”ç”¨ç¨‹åºé“¾æ¥åˆ°å†…æ ¸</strong></p>
<p>link_app.S</p>
<pre><code class="language-x86asm">    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 3
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_2_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;
app_1_end:

    .section .data
    .global app_2_start
    .global app_2_end
app_2_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;
app_2_end:

</code></pre>
<p><strong>.incbin</strong></p>
<table><tr><td bgcolor=#EFF5FF>
The incbin directive includes file verbatim at the current location. You can control the search paths used with the -I command-line option (refer to Chapter 3 Command-Line Options). Quotation marks are required around file.
<p>The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user's responsibility to make sure that proper alignment is provided both before and after the incbin directive.</p>
</td></tr></table>
<p><strong>.quad</strong></p>
<p>ç”¨æ¥å®šä¹‰ä¸€ä¸ª8å­—èŠ‚. åœ°å€ä¸ºå„ä¸ªåº”ç”¨ç¨‹åºèµ·å§‹åœ°å€</p>
<p>num_app_ptr[x] æ¥å¾—åˆ°_num_appä¸­å®šä¹‰çš„åº”ç”¨ç¨‹åºèµ·å§‹åœ°å€</p>
<p>ç„¶åç”¨copy_from_sliceæ¥å®ç°ç±»ä¼¼memcpyçš„åŠŸèƒ½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_MANAGER: AppManager = AppManager {
        inner: RefCell::new({
            extern &quot;C&quot; { fn _num_app(); }
            let num_app_ptr = _num_app as usize as *const usize;
            let num_app = unsafe { num_app_ptr.read_volatile() };
            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];
            let app_start_raw: &amp;[usize] = unsafe {
                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
            };
            app_start[..=num_app].copy_from_slice(app_start_raw);
            AppManagerInner {
                num_app,
                current_app: 0,
                app_start,
            }
        }),
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>æŠŠåº”ç”¨ç¨‹åºçš„ä»£ç å’Œæ•°æ®å­˜åœ¨äº†app_startçš„æ•°ç»„ä¹‹å.ç„¶ååˆ©ç”¨trapè¿”å›åœ¨å†…æ ¸æ ˆä¸Šå‹å…¥è®¾ç½®å¥½çš„æ ˆ
riscvå‡½æ•°è°ƒç”¨è§„å®šç¬¬ä¸€ä¸ªå‚æ•°æ”¾åœ¨a0ä¸­. åˆ©ç”¨è¿™ç‚¹trap.asm ä¸­ __trapret mv sp, a0  å¯ä»¥è®©æˆ‘ä»¬å‹å…¥æˆ‘ä»¬è®¾ç½®å¥½çš„æ ˆ
æ ˆè®¾ç½®:</p>
<p>1.sspè®¾ç½®ä¸ºuser</p>
<p>2.sepcè®¾ç½®ä¸ºåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TrapContext {
    pub fn set_sp(&amp;mut self, sp: usize) { self.x[2] = sp; }
    pub fn app_init_context(entry: usize, sp: usize) -&gt; Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
        };
        cx.set_sp(sp);
        cx
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ç”±äºåœ¨ RISC-V ä¸­æ ˆæ˜¯å‘ä¸‹å¢é•¿çš„, æ ˆé¡¶åœ°å€ = èµ·å§‹åœ°å€+æ ˆå¤§å°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl KernelStack {
    fn get_sp(&amp;self) -&gt; usize {
        self.data.as_ptr() as usize + KERNEL_STACK_SIZE
    }
    pub fn push_context(&amp;self, cx: TrapContext) -&gt; &amp;'static mut TrapContext {
        let cx_ptr = (self.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) as *mut TrapContext;
        unsafe { *cx_ptr = cx; }
        unsafe { cx_ptr.as_mut().unwrap() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¤„ç†ç³»ç»Ÿè°ƒç”¨</strong></p>
<p>ç³»ç»Ÿè°ƒç”¨:é€šè¿‡æŸ¥riscvæ‰‹å†Œ Environment call from U-mode ä¸ºå¼‚å¸¸.å¼‚å¸¸å·ä¸º8</p>
<p>åœ¨traphandlerä¸­åŠ å…¥å¯¹ç³»ç»Ÿè°ƒç”¨å¤„ç†</p>
<p>é€šè¿‡è¯»å–scauseçš„ç¬¬64ä½æ¥åŒºåˆ†æ˜¯ä¸­æ–­è¿˜æ˜¯å¼‚å¸¸, ç„¶åè§†ä¸åŒæƒ…å†µè¿›è¡Œå¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    let tmp = scause::read().get_bit(63);
    //tmp  åŒºåˆ†ä¸­æ–­è¿˜æ˜¯å¼‚å¸¸
    if tmp == true {
        match cause {
            _ =&gt; println!(&quot;undefined trap!&quot;)
        }
        tf
    }else{
        match cause {
            2 =&gt; {
                println!(&quot;[kernel] IllegalInstruction in application, core dumped.&quot;);
                run_next_app();
            }
            3 =&gt; breakpoint(&amp;mut tf.sepc),
            5 =&gt; super_timer(),
            // 12 =&gt; page_fault(tf),
            // 13 =&gt; page_fault(tf),
            7 | 15 =&gt; {
                println!(&quot;[kernel] PageFault in application, core dumped.&quot;);
                run_next_app();
            }   
            8 =&gt; user_syscall(tf),
            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æœ€ç»ˆå¾—åˆ°é¢„å–ç»“æœ~~</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>++++ setup interrupt! ++++
[kernel] num_app = 3
[kernel] app_0 [0x80210654, 0x802119e4)
[kernel] app_1 [0x802119e4, 0x80212e14)
[kernel] app_2 [0x80212e14, 0x802143ac)
[kernel] Loading app_0
[kernel] Loading app_0 finished
Hello, world!
[kernel] IllegalInstruction in application, core dumped.
[kernel] Loading app_1
[kernel] Loading app_1 finished
Into Test store_fault, we will insert an invalid store operation...
Kernel should kill this application!
[kernel] PageFault in application, core dumped.
[kernel] Loading app_2
[kernel] Loading app_2 finished
3^10000=5079
3^20000=8202
3^30000=8824
3^40000=5750
3^50000=3824
3^60000=8516
3^70000=2510
3^80000=9379
3^90000=2621
3^100000=2749
Test power OK!
[kernel] Application exited with code 0
panicked at 'All applications completed!', src\batch.rs:61:13
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è¿è¡Œåº”ç”¨ç¨‹åºæ€»ç»“</strong></p>
<p><strong>1.ç¼–å†™åº”ç”¨ç¨‹åº</strong></p>
<p>ç¼–å†™ç”¨æˆ·æ€syscall. å°±å¦‚åŒosè°ƒç”¨sbicallç±»ä¼¼!</p>
<p>é€šè¿‡linkeré“¾æ¥è„šæœ¬.æ¥æŒ‡å®šåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<p><strong>2.é“¾æ¥åº”ç”¨ç¨‹åº</strong></p>
<p>.quad æ¥æŒ‡å®šä¸€ä¸ª8å­—èŠ‚åœ°å€</p>
<p>.incbin æ¥è½½å…¥ä¸€ä¸ªæ–‡ä»¶</p>
<p><strong>3.åœ¨å†…æ ¸ä¸­è½½å…¥åº”ç”¨ç¨‹åº</strong></p>
<p>é€šè¿‡from_raw_parts_mut å’Œ copy_from_slice æ¥å®ç°ç±»ä¼¼memcpyåŠŸèƒ½</p>
<p><strong>4.ä¸ºåº”ç”¨ç¨‹åºè®¾ç½®å¥½TrapContext</strong></p>
<p>1.sspè®¾ç½®ä¸ºuser</p>
<p>2.sepcè®¾ç½®ä¸ºåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<p><strong>5.åˆ©ç”¨trapretæ¥æŠŠè®¾ç½®å¥½çš„TrapContextå‹å…¥åˆ°å†…æ ¸æ ˆä¸­</strong></p>
<p><strong>6.ä¸­æ–­ä¸­åŠ å…¥å¯¹ç³»ç»Ÿè°ƒç”¨æ”¯æŒ</strong></p>
<p>1.Environment call from U-mode</p>
<p><strong>7.é€‰æ‹©ä½•æ—¶è¿è¡Œåº”ç”¨ç¨‹åº</strong></p>
<p>è°ƒåº¦å™¨ç›¸å…³.å®éªŒæš‚æ—¶æœªæ¶‰åŠ.åªæ˜¯é€šè¿‡äººä¸ºè§¦å‘å¼‚å¸¸æŒ‡ä»¤æ¥è¿›å…¥ä¸­æ–­,ç„¶ååœ¨ä¸­æ–­å¤„ç†ä¸­è¿è¡Œä¸‹ä¸€ä¸ªåº”ç”¨ç¨‹åº</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ç¬¬ä¸‰ç« </strong></p>
<p><strong>å¤šé“ç¨‹åºæ”¾ç½®ä¸åŠ è½½</strong></p>
<p>å’Œä¸Šä¸€ç« ä¸åŒçš„æ˜¯appå…¶å®åœ°å€è¢«åŠ è½½åˆ°äº†APP_BASE_ADDRESS + app_id * APP_SIZE_LIMITä½ç½®ä¸Š</p>
<p><strong>ä»»åŠ¡åˆ‡æ¢</strong></p>
<p>åœ¨å¤„ç†trapæ—¶.æˆ‘ä»¬éœ€è¦åˆ‡æ¢æˆå†…æ ¸æ ˆ.è€Œåœ¨ç”¨æˆ·ç¨‹åºåˆ‡æ¢æ—¶,æˆ‘ä»¬éœ€è¦åˆ‡æ¢çš„å¦ä¸€ä¸ªç¨‹åºçš„æ ˆ.</p>
<p>å½“å‰ä»»åŠ¡åˆ‡æ¢çš„æœ¬è´¨æ˜¯å‡½æ•°è°ƒç”¨,æˆ‘ä»¬éœ€è¦ä¿å­˜çš„æ˜¯riscvå‡½æ•°è°ƒç”¨è§„å®šä¸­caller-savedçš„å¯„å­˜å™¨.s0~s11</p>
<p>ä¿å­˜å¥½å½“å‰ä»»åŠ¡çš„ä¿¡æ¯å.å¦‚ä½•è¿”å›å½“å‰ä»»åŠ¡ç»§ç»­æ‰§è¡Œ?. åœ¨åšå‡½æ•°åˆ‡æ¢å‰,ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬å§raå¯„å­˜å™¨çš„å€¼æ”¹ä¸º</p>
<p>å‡½æ•°è°ƒç”¨è¿”å›åç¬¬ä¸€æ¡æŒ‡ä»¤çš„åœ°å€. å› æ­¤éœ€è¦ä¿å­˜ra</p>
<p>åˆ‡æ¢åˆ°ç›®æ ‡ä»»åŠ¡. riscvå‡½æ•°è°ƒç”¨ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°åˆ†åˆ«ä¿å­˜åœ¨a0/a1.å› æ­¤ld sp, 0(a1)å³å¯æ¢æ ˆ.</p>
<p>ç„¶åè¯»å–ra s0~s11. </p>
<p><strong>åä½œå¼è°ƒåº¦</strong></p>
<p>æœ‰äº†ä»»åŠ¡åˆ‡æ¢,é‚£ä¹ˆä½•æ—¶è¿›è¡Œåˆ‡æ¢?</p>
<p>ç°åœ¨çš„åšæ³•æ˜¯åº”ç”¨ç¨‹åºä¸»åŠ¨æš‚åœsys_yield ä»¥åŠä¸»åŠ¨é€€å‡ºsys_exit</p>
<p><strong>ä»»åŠ¡ç®¡ç†å™¨</strong></p>
<p>ä¿å­˜äº†å„ä¸ªç¨‹åºåˆ‡æ¢æ—¶æè¿°è‡ªèº«çš„æ ˆä¿¡æ¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskManager {
    num_app: usize,
    inner: RefCell&lt;TaskManagerInner&gt;,
}

struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    current_task: usize,
}

unsafe impl Sync for TaskManager {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆ‡æ¢ä»»åŠ¡</strong></p>
<p>__switchç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è‡ªèº«æ ˆ,ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç›®æ ‡ä»»åŠ¡çš„æ ˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_next_task(&amp;self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.borrow_mut();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr2 = inner.tasks[current].get_task_cx_ptr2();
        let next_task_cx_ptr2 = inner.tasks[next].get_task_cx_ptr2();
        core::mem::drop(inner);
        unsafe {
            __switch(
                current_task_cx_ptr2,
                next_task_cx_ptr2,
            );
        }
    } else {
        panic!(&quot;All applications completed!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>find_next_task.æ‰¾åˆ°çŠ¶æ€ä¸ºTaskStatus::Readyçš„ä»»åŠ¡</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    let inner = self.inner.borrow();
    let current = inner.current_task;
    (current + 1..current + self.num_app + 1)
        .map(|id| id % self.num_app)
        .find(|id| {
            inner.tasks[*id].task_status == TaskStatus::Ready
        })
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆ†æ—¶å¤šä»»åŠ¡ç³»ç»Ÿä¸æŠ¢å å¼è°ƒåº¦</strong></p>
<p>æ¯”è¾ƒç®€å•.è®¾ç½®å¥½æ—¶é’Ÿä¸­æ–­, å¹¶åœ¨æ—¶é’Ÿä¸­æ–­å‘ç”Ÿæ—¶run_next_task(),åœ¨trap_handlerä¸­åŠ å…¥ç›¸åº”å¤„ç†å³å¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
.........
        match cause {
.........
            5 =&gt; super_timer(),

            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}


fn super_timer() {
    clock_set_next_event();
    suspend_current_and_run_next();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>chapter3ç»ƒä¹ </strong></p>
<p><strong>stride è°ƒåº¦ç®—æ³•</strong></p>
<p>ä¹‹å‰æ˜¯åœ¨å‘ç”Ÿæ—¶é’Ÿä¸­æ–­æ—¶,é€‰æ‹©ä¸‹ä¸€ä¸ªReadyçŠ¶æ€çš„ç¨‹åºè¿è¡Œ,strideè°ƒåº¦ç®—æ³•å³,ç¨‹åºåˆå§‹strideä¸º0.ä¸ºæ¯ä¸ªç¨‹åºè®¾ç½®ä¸€ä¸ªpass.æ¯æ¬¡ç¨‹åºè¿è¡Œstride+pass. 
å¹¶æ€»æ˜¯é€‰æ‹©strideæœ€å°çš„ç¨‹åºè¿è¡Œ.</p>
<p><strong>å¢åŠ æ•°æ®ç»“æ„</strong></p>
<p>task_pass </p>
<p>task_stride</p>
<p>task_priority </p>
<p>task_time</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    pub current_task: usize,
    pub task_pass:[usize; MAX_APP_NUM],
    pub task_stride:[usize; MAX_APP_NUM],
    pub task_priority:[usize; MAX_APP_NUM],
    pub task_time:[usize; MAX_APP_NUM],
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¯»æ‰¾ä¸‹ä¸€ä¸ªæ‰§è¡Œç¨‹åº</strong></p>
<p>1.æ›´æ–°å½“å‰è¿›ç¨‹stride</p>
<p>2.å¯»æ‰¾ä¸‹ä¸€ä¸ªstrideå€¼æœ€å°çš„è¿›ç¨‹</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    //update
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    let priority = inner.task_priority[current];
    if inner.tasks[current].task_status == TaskStatus::Ready {
        inner.task_stride[current] = inner.task_stride[current] + 127 / priority
    }

    let num_app = get_num_app();
    let mut max_stride = 10000000;
    let mut next = 0 as usize;
    for i in 0..num_app{
        let stride_i  = inner.task_stride[i];
        if stride_i &lt;= max_stride  &amp;&amp; inner.tasks[i].task_status != TaskStatus::Exited{
            next = i;
            max_stride =  stride_i;
        }
    }
    let mut  exited_count = 0 as usize;
    for i in 0..num_app{
        
        if inner.tasks[i].task_status == TaskStatus::Exited{
            exited_count += 1;
        }
    }
    if exited_count == num_app{
        println!(&quot;all exited&quot;);
        None
    }else{
        println!(&quot; next min stride  app id{}&quot;, next);
        Some(next)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æ ‡è®°é€€å‡ºè¿›ç¨‹</p>
<p>é¦–å…ˆæ˜¯id0è¿è¡Œ.id0 exit åˆ‡æ¢åˆ°id3</p>
<p>id3æ‰§è¡Œçš„æ˜¯ä¸»åŠ¨yeildæ‰€ä»¥ç«‹é©¬è¿›è¡Œäº†åˆ‡æ¢</p>
<p>....</p>
<p>all exitedæ‰€ä»¥ç¨‹åºæ‰§è¡Œå®Œæ¯•</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mark_current_suspended(&amp;self) {
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.task_time[current] += 1;
    inner.tasks[current].task_status = if inner.task_time[current] &gt;= 500 {
        inner.task_stride[current] = 10000000;
        println!(&quot;app id {}  exited  run out of time&quot;, current);
        TaskStatus::Exited
    } else {
        TaskStatus::Ready
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>ç¨‹åºå¦‚æœŸè¿è¡Œ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OpenSBI v0.7
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 128 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
stext 80200000 etext 8020a000
srodata 8020a000 erodata 80236000
sdata 8023663c edata 8023be49
sbss 8024be50 ebss 8024c058
Hello, world!
base i 0x80400000
base i 0x80420000
base i 0x80440000
base i 0x80460000
load app done
++++ setup timer!     ++++
power_3 [10000/200000]
power_3 [20000/200000]
power_3 [30000/200000]
power_3 [40000/200000]
power_3 [50000/200000]
power_3 [60000/200000]
power_3 [70000/200000]
power_3 [80000/200000]
power_3 [90000/200000]
power_3 [100000/200000]
power_3 [110000/200000]
power_3 [120000/200000]
power_3 [130000/200000]
power_3 [140000/200000]
power_3 [150000/200000]
power_3 [160000/200000]
power_3 [170000/200000]
power_3 [180000/200000]
power_3 [190000/200000]
power_3 [200000/200000]
3^200000 = 871008973
Test power_3 OK!
[kernel] Application exited with code 0
app id 0  exited 
 next min stride  app id3
current 0 start switch to  3
 next min stride  app id2
current 3 start switch to  2
 next min stride  app id1
current 2 start switch to  1
power_5 [10000/140000]
power_5 [20000/140000]
power_5 [30000/140000]
power_5 [40000/140000]
power_5 [50000/140000]
power_5 [60000/140000]
power_5 [70000/140000]
power_5 [80000/140000]
power_5 [90000/140000]
power_5 [100000/140000]
power_5 [110000/140000]
power_5 [120000/140000]
power_5 [130000/140000]
power_5 [140000/140000]
5^140000 = 386471875
Test power_5 OK!
[kernel] Application exited with code 0
app id 1  exited 
 next min stride  app id3
current 1 start switch to  3
Test sleep OK!
[kernel] Application exited with code 0
app id 3  exited 
 next min stride  app id2
current 3 start switch to  2
power_7 [10000/160000]
power_7 [20000/160000]
power_7 [30000/160000]
power_7 [40000/160000]
power_7 [50000/160000]
power_7 [60000/160000]
power_7 [70000/160000]
power_7 [80000/160000]
power_7 [90000/160000]
power_7 [100000/160000]
power_7 [110000/160000]
power_7 [120000/160000]
power_7 [130000/160000]
power_7 [140000/160000]
power_7 [150000/160000]
power_7 [160000/160000]
7^160000 = 667897727
Test power_7 OK!
[kernel] Application exited with code 0
app id 2  exited 
all exited
panicked at 'All applications completed!', src\task\mod.rs:149:13
93
panicked at 'It should shutdown!', src\sbi.rs:45:5

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>åœ°å€ç©ºé—´</strong></p>
<p><strong>ç‰©ç†å†…å­˜</strong></p>
<p>ç‰©ç†å†…å­˜é¡µå¼ç®¡ç†</p>
<p>å¯¹äºç‰©ç†å†…å­˜çš„é¡µå¼ç®¡ç†è€Œè¨€ï¼Œæˆ‘ä»¬æ‰€è¦æ”¯æŒçš„æ“ä½œæ˜¯ï¼š</p>
<p>åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œè¿”å›å…¶ç‰©ç†é¡µå·ï¼›</p>
<p>ç»™å®šä¸€ä¸ªç‰©ç†é¡µå·ï¼Œå›æ”¶å…¶å¯¹åº”çš„ç‰©ç†é¡µã€‚</p>
<p>ç»™å®šä¸€ä¸ªé¡µå·åŒºé—´è¿›è¡Œåˆå§‹åŒ–ã€‚</p>
<p>è¿™é‡Œç”¨æœ€ç®€å•çš„æ–¹å¼å®ç°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Allocator {
    a: [u8; MAX_PHYSICAL_PAGES],
    offset: usize,
    total:usize
}

impl Allocator {
    // ç»™å®šä¸€ä¸ªé¡µå·åŒºé—´è¿›è¡Œåˆå§‹åŒ–ã€‚
    pub fn init(&amp;mut self, l:usize, r:usize) {
        self.offset = l - 1;
        self.total = r - l;
        // let size = r - l;

        //0è¡¨ç¤ºç©ºé—²
        for i in 0..self.total {
            self.a[i] = 0;
        }
    }

    // // ç»™å®šç‰©ç†åœ°å€ åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œè¿”å›å…¶ç‰©ç†é¡µå·ï¼›
    pub fn alloc(&amp;mut self) -&gt; usize {
        //è®¾ç½®ä¸€ä¸ªåˆ†é…æˆåŠŸæ ‡å¿—
        let mut flag = 0;

        //è¿”å›åˆ†é…çš„ç‰©ç†é¡µå·
        let mut result = 0;
        for i in 0..MAX_PHYSICAL_PAGES-1 {
            if self.a[i] == 0 {
                self.a[i] = 1;
                flag = 1;
                result = i;
                return result;
            }
        }
        if flag == 0 {
            panic!(&quot;physical memory depleted!&quot;);
        }
        result
    }

    //å›æ”¶ç‰©ç†é¡µå·ä¸ºnçš„ç‰©ç†é¡µ
    pub fn dealloc(&amp;mut self, n: usize) {

        let p = n;
        if p &gt;= MAX_PHYSICAL_PAGES {
            panic!(&quot;éæ³•ç‰©ç†é¡µå·&quot;)
        }
        self.a[p] = 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åŠ¨æ€å†…å­˜åˆ†é…</strong></p>
<p>å®ç° Trait GlobalAlloc</p>
<p>ç”¨å†™å¥½çš„åº“ å¹¶æŠŠå®ƒæ ‡è®°ä¸º #[global_allocator]</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use buddy_system_allocator::LockedHeap;

#[global_allocator]
static DYNAMIC_ALLOCATOR: LockedHeap = LockedHeap::empty();

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>rv39é¡µè¡¨</strong></p>
<p><strong>åˆ†æé¡µè¡¨éœ€è¦æ”¯æŒçš„æ“ä½œ</strong></p>
<p>1.æ–°å»ºä¸€ä¸ªé¡µè¡¨(åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå¸§,å¹¶æŠŠè¯¥é¡µå¸§ä½œä¸ºé¡µè¡¨çš„èµ·å§‹åœ°å€)</p>
<p>2.map unmap ä¸ºä¸€å¯¹va å’Œ pa å»ºç«‹æ˜ å°„</p>
<p>3.æ‰¾åˆ°é¡µè¡¨é¡¹</p>
<p><strong>ç»™å®šæŸvaå»ºç«‹æ˜ å°„çš„è¿‡ç¨‹:</strong></p>
<p><strong>1.æ‰¾åˆ°root_table</strong></p>
<p><strong>2.åœ¨ä¸‰çº§é¡µè¡¨ä¸­æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„é¡µè¡¨é¡¹.æ ¹æ®é¡µè¡¨é¡¹æ¥æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„åœ°å€</strong></p>
<p>å¦‚æœé¡µè¡¨é¡¹æœªè¢«è®¾ç½®. åˆ™åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå¸§, å¹¶æŠŠè¯¥ç‰©ç†é¡µå¸§å¡«å†™åˆ°é¡µè¡¨é¡¹å¹¶è®¾ç½®æ ‡è®°ä½(å³ä»¥åèƒ½é€šè¿‡æ­¤é¡µè¡¨é¡¹æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„åœ°å€äº†)</p>
<p>åªéœ€å¡«å†™validä½.å› ä¸ºå®ƒæŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨</p>
<p>å…¶ä¸­p1_index  p2_index p3_index åˆ†åˆ«ä¸º </p>
<p>è™šæ‹Ÿåœ°å€vaçš„12..21    21 .. 30  30..39 ä½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p3_index = page.p3_index();
let p2_index = page.p2_index();
let p1_index = page.p1_index();

let p2_table = if self.root_table.entries[p3_index].is_unused() {
    let frame = alloc_frame().unwrap();
    self.root_table.entries[p3_index].set(frame, EF::VALID);
    let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
    p2_table.zero();
    p2_table
} else {
    let frame = self.root_table.entries[p3_index].frame();
    unsafe { frame.as_kernel_mut() }
};
<span class="boring">}
</span></code></pre></pre>
<p>è¿™é‡Œéœ€è¦ä¸€ä¸ªæŠŠé¡µè¡¨é¡¹ä¸­çš„åœ°å€è§£æå‡ºæ¥å¹¶å½“æˆé¡µè¡¨çš„æ“ä½œ</p>
<p>(pte &gt;&gt; 10 )  &lt;&lt; 12  +  PHYSICAL_MEMORY_OFFSET</p>
<p>é¡µè¡¨é¡¹å³ç§»10ä½æ¥å¾—åˆ°ç‰©ç†é¡µå·.   ä¸€ä¸ªç‰©ç†é¡µå¸§ä¸º4k. å†å·¦ç§»12ä½æ¥å¾—åˆ°ç‰©ç†åœ°å€</p>
<p>å¦‚æœæœ‰è®¾ç½®åç§»åˆ™åŠ ä¸ŠPHYSICAL_MEMORY_OFFSET</p>
<p>è¿™æ ·å°±å¾—åˆ°äº†é¡µè¡¨æ‰€åœ¨çš„ç‰©ç†åœ°å€</p>
<p>rustå†™æ³•æœ‰ä¸¤ç§</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_page_table(&amp;self) -&gt; *mut PageTable {
    ((self.data &gt;&gt; 10) &lt;&lt; 12) as *mut PageTable
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame = self.root_table.entries[p3_index].frame();
pub unsafe fn as_kernel_mut&lt;'a, 'b, T&gt;(&amp;'a self) -&gt; &amp;'b mut T {
    &amp;mut *(    (    (self.0).0 + PHYSICAL_MEMORY_OFFSET)             as *mut T       )
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>3.ç„¶åå°±æ˜¯é‡å¤ä¸Šè¿°æ“ä½œ</strong></p>
<p><strong>åœ¨äºŒçº§é¡µè¡¨ä¸­æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹, æ ¹æ®é¡µè¡¨é¡¹æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„åœ°å€</strong></p>
<p>å¦‚æœä¸å­˜åœ¨åˆ™åˆ†é…ç‰©ç†é¡µå¸§,å¡«å†™æ ‡å¿—</p>
<p>æœ€ç»ˆåœ¨ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„é¡µè¡¨é¡¹,æŠŠå¯¹åº”çš„ç‰©ç†é¡µå·å¡«å†™è¿›å»å°±å®Œæˆäº†æ˜ å°„</p>
<p><strong>é‚£ä¹ˆæˆ‘ä»¬è¯¥å¡«å†™ä»€ä¹ˆç‰©ç†é¡µå·è¿›å»å‘¢?</strong> è¿™é‡Œå°±æ¯”è¾ƒéšæ„äº†</p>
<ol>
<li>
<p>å¯ä»¥é‡‡ç”¨ä¸€ä¸ªå›ºå®šçš„åç§» pa = va +  PHYSICAL_MEMORY_OFFSET</p>
</li>
<li>
<p>å¯ä»¥é‡‡ç”¨ä¹‹å‰å†™å¥½çš„ç‰©ç†å†…åœºåˆ†é…å™¨åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå·</p>
</li>
<li>
<p>...</p>
</li>
</ol>
<p>å®Œæ•´ç‰ˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_pte_create(&amp;mut self, va:usize) -&gt; Option&lt;&amp;mut PageTableEntry&gt; {
    let page = Page::of_addr(VirtAddr::new(va));
    let p3_index = page.p3_index();
    let p2_index = page.p2_index();
    let p1_index = page.p1_index();
    //æ‰¾åˆ°äºŒçº§é¡µè¡¨
    let p2_table = if self.root_table.entries[p3_index].is_unused() {
        let frame = alloc_frame().unwrap();
        self.root_table.entries[p3_index].set(frame, EF::VALID);
        let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p2_table.zero();
        p2_table
    } else {
        let frame = self.root_table.entries[p3_index].frame();
        unsafe { frame.as_kernel_mut() }
    };
    //æ‰¾åˆ°ä¸€çº§é¡µè¡¨
    let p1_table = if p2_table.entries[p2_index].is_unused() {
        let frame = alloc_frame().unwrap();
        p2_table.entries[p2_index].set(frame, EF::VALID);
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table.zero();
        p1_table
    } else {
        let frame = p2_table.entries[p2_index].frame();
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table
    };
    //åœ¨ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”é¡µè¡¨é¡¹
    let p1_entry = Some (&amp;mut p1_table.entries[p1_index]);
    p1_entry
}
<span class="boring">}
</span></code></pre></pre>
<p>å»ºç«‹æ˜ å°„</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map(&amp;mut self, va:usize, frame: Frame, ptflags: PageTableFlags) {
    let pte = self.find_pte_create(va).unwrap();
    if !pte.is_unused(){
        println!(&quot;pte {:?} already mapped&quot;, pte);
    }
    pte.set(frame, ptflags);
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
}

pub fn unmap(&amp;mut self, va:usize) {
    let pte = self.find_pte(va).unwrap();
    pte.set_unused();
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
    MapperFlush::flush(page);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>debug</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>satp :0x8000000000080a2b                 å¯¹åº”ç‰©ç†åœ°å€:0x80a2b000
p3_indexä¸º511                       ç¬¬511é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2bff8
0x80a2bff8å¤„å†…å­˜æ˜¾ç¤º 0x000000002028b0c5(é¡µè¡¨é¡¹)
(0x000000002028b0c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2c000
                                             ç‰©ç†åœ°å€ = 0x80a2c000


å¾—åˆ°äºŒçº§é¡µè¡¨è™šæ‹Ÿåœ°å€ 0xffffffffc0a2c000   å¯¹åº”ç‰©ç†åœ°å€:0x80a2c000
p2_indexä¸º1                            ç¬¬1é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2c008
0x80a2c008å¤„å†…å­˜æ˜¾ç¤º 0x000000002028b4c5(é¡µè¡¨é¡¹)
(0x000000002028b4c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2d000
                                             ç‰©ç†åœ°å€ = 0x80a2d000


å¾—åˆ°ä¸€çº§é¡µè¡¨è™šæ‹Ÿåœ°å€ 0xffffffffc0a2d000   å¯¹åº”ç‰©ç†åœ°å€:0x80a2d000
p1_indexä¸º2                            ç¬¬2é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2d010
0x80a2d010å¤„å†…å­˜æ˜¾ç¤º 0x00000000200808cf(é¡µè¡¨é¡¹)
(0x00000000200808cf &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0202000
                                             ç‰©ç†åœ°å€ = 0x80202000
<span class="boring">}
</span></code></pre></pre>
<p>gdbæ˜¾ç¤ºç‰©ç†å†…å­˜</p>
<p>maintenance packet Qqemu.PhyMemMode:1</p>
<p>x/10xg $addr  ä»¥64ä½ä¸€ä¸ªå•å…ƒæ¥æ˜¾ç¤ºæŸåœ°å€å†…å­˜ä¸­å†…å®¹.</p>
<p><strong>é¡µè¡¨å»ºç«‹è¿‡ç¨‹ä¸­æœ‰å¯èƒ½å‡ºé”™çš„åœ°æ–¹:</strong></p>
<p>1.æŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹æ ‡å¿—ä½è®¾ç½®é”™! è¿™æ—¶debugä¼šå‘ç°ç»™å®švaæ‰‹åŠ¨ç®—æ€»èƒ½åœ¨æœ€åæ‰¾åˆ°ç›¸åº”çš„ç‰©ç†é¡µå¸§! ä½†æ˜¯ç¨‹åºæ²¡æ³•è¿è¡Œ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•-2"><a class="header" href="#-rustå­¦ä¹ è®°å½•-2">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-2"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-2">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-foo"><a class="header" href="#-foo">ğŸš§ foo</a></h1>
<p><strong>è®°å½•ä¸€äº›æ–°æŠ€èƒ½</strong></p>
<p><strong>docker</strong>
åœ¨é…ç½®github+gitpodä¸­å­¦ä¹ äº†dockerçš„åŸºæœ¬ç”¨æ³•åŒ…æ‹¬imageç”Ÿæˆ.containerä½¿ç”¨</p>
<p><br/> </br></p>
<p><strong>è·å–åŸºç¡€é•œåƒ</strong></p>
<p>å¦‚æœæˆ‘ä»¬æœ¬åœ°æ²¡æœ‰ ubuntu é•œåƒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ docker pull å‘½ä»¤æ¥è½½å…¥ ubuntu é•œåƒ</p>
<pre><code class="language-shell">$ docker pull ubuntu
</code></pre>
<p><strong>å¯åŠ¨å®¹å™¨</strong></p>
<pre><code>$ docker run -it ubuntu /bin/bash
</code></pre>
<p><strong>å®‰è£…ç¯å¢ƒ(ç•¥)</strong></p>
<p><strong>æ¨é€é•œåƒåˆ°Docker Hub</strong></p>
<p>éœ€è¦åœ¨docker hubä¸Šæ³¨å†Œè´¦æˆ·,åˆ›å»ºä»“åº“</p>
<p>ç™»å…¥docker</p>
<pre><code class="language-shell">$ docker login 
</code></pre>
<p>ä¿®æ”¹æ ‡ç­¾</p>
<pre><code class="language-shell">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
</code></pre>
<p>æ¨é€</p>
<pre><code class="language-shell">$ docker push username/repository:[tag]
</code></pre>
<p><strong>æŸ¥çœ‹æœ¬åœ°å®¹å™¨,é•œåƒ</strong></p>
<pre><code class="language-shell">$ docker images
$ docker ps -a
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
