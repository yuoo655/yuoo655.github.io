<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> 🚧 Welcome to my blog!</a></li><li class="chapter-item "><a href="new.html"><strong aria-hidden="true">2.</strong> 🚧 存档</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="futures_in_rust/futrue.html"><strong aria-hidden="true">2.1.</strong> 🚧 Futures in Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="futures_in_rust/2022-01-20.html"><strong aria-hidden="true">2.1.1.</strong> lambda calculus---&gt;closure</a></li><li class="chapter-item "><a href="futures_in_rust/2022-01-21.html"><strong aria-hidden="true">2.1.2.</strong> closure---&gt;generator</a></li><li class="chapter-item "><a href="futures_in_rust/2022-01-23.html"><strong aria-hidden="true">2.1.3.</strong> generator---&gt;future</a></li></ol></li><li class="chapter-item "><a href="os_camp_log.md.html"><strong aria-hidden="true">2.2.</strong> 🚧 2021-os-camp</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="camp-daliy/7-6.html"><strong aria-hidden="true">2.2.1.</strong> 7.6 指定程序内存布局</a></li><li class="chapter-item "><a href="camp-daliy/7-7.html"><strong aria-hidden="true">2.2.2.</strong> 7.7 链接脚本编写</a></li><li class="chapter-item "><a href="camp-daliy/7-8.html"><strong aria-hidden="true">2.2.3.</strong> 7.8 实现彩色输出</a></li><li class="chapter-item "><a href="camp-daliy/7-9.html"><strong aria-hidden="true">2.2.4.</strong> 7.9 intel手册中的多核启动</a></li><li class="chapter-item "><a href="camp-daliy/7-10.html"><strong aria-hidden="true">2.2.5.</strong> 7.10 多核支持</a></li><li class="chapter-item "><a href="camp-daliy/7-11.html"><strong aria-hidden="true">2.2.6.</strong> 7.11 中断机制概况</a></li><li class="chapter-item "><a href="camp-daliy/7-13.html"><strong aria-hidden="true">2.2.7.</strong> 7.13 中断详细实现</a></li><li class="chapter-item "><a href="camp-daliy/7-14.html"><strong aria-hidden="true">2.2.8.</strong> 7.14 运行用户程序</a></li><li class="chapter-item "><a href="camp-daliy/7-15.html"><strong aria-hidden="true">2.2.9.</strong> 7.15 运行用户程序总结</a></li><li class="chapter-item "><a href="camp-daliy/7-16.html"><strong aria-hidden="true">2.2.10.</strong> 7.16 用户程序切换</a></li><li class="chapter-item "><a href="camp-daliy/7-17.html"><strong aria-hidden="true">2.2.11.</strong> 7.17 stride 调度算法</a></li><li class="chapter-item "><a href="camp-daliy/7-18.html"><strong aria-hidden="true">2.2.12.</strong> 7.18 物理内存分配</a></li><li class="chapter-item "><a href="camp-daliy/7-19.html"><strong aria-hidden="true">2.2.13.</strong> 7.19 页表</a></li><li class="chapter-item "><a href="camp-daliy/7-20.html"><strong aria-hidden="true">2.2.14.</strong> 7.20 debug</a></li><li class="chapter-item "><a href="camp-daliy/7-21.html"><strong aria-hidden="true">2.2.15.</strong> 7.21</a></li><li class="chapter-item "><a href="camp-daliy/7-23.html"><strong aria-hidden="true">2.2.16.</strong> 7.23</a></li><li class="chapter-item "><a href="camp-daliy/7-24.html"><strong aria-hidden="true">2.2.17.</strong> 7.24 文件系统</a></li><li class="chapter-item "><a href="camp-daliy/7-25.html"><strong aria-hidden="true">2.2.18.</strong> 7.25</a></li><li class="chapter-item "><a href="camp-daliy/7-26.html"><strong aria-hidden="true">2.2.19.</strong> 7.26</a></li><li class="chapter-item "><a href="camp-daliy/7-27.html"><strong aria-hidden="true">2.2.20.</strong> 7.27</a></li></ol></li><li class="chapter-item "><a href="rust/2022-1-16.html"><strong aria-hidden="true">2.3.</strong> 🚧 rust笔记</a></li><li class="chapter-item "><a href="c2rust.html"><strong aria-hidden="true">2.4.</strong> 🚧c2rust</a></li><li class="chapter-item "><a href="foo.html"><strong aria-hidden="true">2.5.</strong> 🚧 docker笔记</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-存档"><a class="header" href="#-存档">🚧 存档</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-futures-in-rust"><a class="header" href="#-futures-in-rust">🚧 Futures in Rust</a></h1>
<h1 id="rust异步运行时详解"><a class="header" href="#rust异步运行时详解">rust异步运行时详解</a></h1>
<p>lambda calculus --&gt; closure --&gt; generator --&gt; future</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从lambda-calculus到闭包closure"><a class="header" href="#从lambda-calculus到闭包closure">从lambda calculus到闭包(closure)</a></h1>
<p>lambda演算是Alonzo Church在1935年设计的计算模型，与Turing是同时代的。他们提出了非常不同的计算模型。</p>
<p>Turing证明了两者在计算能力上是等效的,它们都可以有效的模仿另一个,是等效的计算模型.</p>
<p>lambda演算非常特别,因为它由仅由函数和这些函数的参数组成的表达式组成</p>
<h2 id="lambda演算"><a class="header" href="#lambda演算">lambda演算</a></h2>
<blockquote>
<p>λx. y 定义参数 x 并返回值 y 的函数</p>
</blockquote>
<blockquote>
<p>(λx. x)  这是一个恒等函数. 其中λx表示参数, x表示函数的返回值<br />
((λx. x) 2) = 2</p>
</blockquote>
<blockquote>
<p>有两个参数x ,y的情况<br />
((λx. λy. x+y) 2 3) = 5</p>
</blockquote>
<blockquote>
<p>((λx. (x x)) (λx. (x x))) =  ((λx. (x x)) (λx. (x x))) = ((λx. (x x)) (λx. (x x)))   loop<br />
可以传入函数作为参数. 这个例子中返回的将永远是它自己.</p>
</blockquote>
<h2 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h2>
<p>匿名函数又称lambda函数, lambda抽象, lambda表达式,建立在lambda演算基础上.</p>
<p>python中lambda函数例子:</p>
<pre><code class="language-python">&gt;&gt;&gt; foo = lambda x: x * x
&gt;&gt;&gt; foo(10)
100
</code></pre>
<p>rust中的lambda函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let adder = |a, b| a + b;
<span class="boring">}
</span></code></pre></pre>
<h2 id="闭包closure"><a class="header" href="#闭包closure">闭包(Closure)</a></h2>
<p>闭包(Closure)，函数闭包(function closures)又称词法闭包(Lexical Closure)</p>
<h3 id="下面提供多种解释来帮助理解闭包"><a class="header" href="#下面提供多种解释来帮助理解闭包">下面提供多种解释来帮助理解闭包:</a></h3>
<p>在<a href="https://doc.rust-lang.org/book/ch13-01-closures.html">rust book</a>中闭包定义: 可以捕获环境的匿名函数</p>
<p>闭包也可称为引用了自由变量的函数. 这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外.</p>
<p>闭包是由函数和与其相关的引用环境组合而成的实体</p>
<p>闭包就是一个捕获了当前上下文变量的结构体(外加一段代码 lambda function)</p>
<p>直接理解rust中的闭包有点困难,我们先从python的例子来看</p>
<h3 id="python中的闭包"><a class="header" href="#python中的闭包">python中的闭包</a></h3>
<p><strong>例一:</strong></p>
<blockquote>
<p>一个函数内部定义另一个函数。这个函数就称为嵌套函数<br />
在display内部, 可以通过它的局部作用域访问greeting<br />
Python 将该greeting变量称为自由变量。<br />
当您查看display函数时，实际上是在查看：display函数本身。以及值为'Hello'的自由变量greeting。</p>
</blockquote>
<pre><code class="language-python">def say():
    greeting = 'Hello'

    def display():
        print(greeting)

    display()
</code></pre>
<p><strong>例二:</strong></p>
<blockquote>
<p>say()函数返回display()函数,而不是执行它<br />
当返回display()函数时,它也返回了闭包</p>
</blockquote>
<pre><code class="language-python">def say():
    greeting = 'hello'

    def display():
        print(greeting)
    
    return display

fn = say()
fn()
</code></pre>
<blockquote>
<p><img src="futures_in_rust/./../img/closure_python.png" alt="avatar" /></p>
</blockquote>
<p><strong>输出:</strong></p>
<p><strong>hello</strong></p>
<p>既然变量greeting是say的局部变量,出了函数体应该是不能访问greeting的, 但依旧可以看到fn()输出了hello</p>
<pre><code class="language-python">&gt;&gt;print(fn.__closure__)

(&lt;cell at 0x0000017184915C40: str object at 0x0000017186A829B0&gt;,)
</code></pre>
<p>在这个例子中，单元的内存地址是0x0000017184915C40。它引用了一个字符串对象0x0000017186A829B0</p>
<p><strong>例三:</strong></p>
<blockquote>
<p>如果在say函数 和中显示字符串对象的内存地址closure，您应该会看到它们引用了内存中的同一个对象：
这时多个作用域共享同一个变量，所以外部函数和内部函数作用域中的变量greeting是相同的</p>
</blockquote>
<pre><code class="language-python">def say():
    greeting = 'Hello'
    print(hex(id(greeting)))

    def display():
        print(hex(id(greeting)))
        print(greeting)

    return display


fn = say()
fn()
</code></pre>
<p><strong>输出:</strong></p>
<p><strong>0x17186a829b0</strong></p>
<p><strong>0x17186a829b0</strong></p>
<h4 id="参考a-hrefhttpswwwpythontutorialnetadvanced-pythonpython-closureshttpswwwpythontutorialnetadvanced-pythonpython-closuresa"><a class="header" href="#参考a-hrefhttpswwwpythontutorialnetadvanced-pythonpython-closureshttpswwwpythontutorialnetadvanced-pythonpython-closuresa">参考:<a href="https://www.pythontutorial.net/advanced-python/python-closures/">https://www.pythontutorial.net/advanced-python/python-closures/</a></a></h4>
<h2 id="rust中的闭包"><a class="header" href="#rust中的闭包">rust中的闭包</a></h2>
<p>rust中闭包稍微复杂一些, 因为涉及到获取参数的方式, 在rust中函数获取参数的方式有三种:获取所有权，可变借用和不可变借用</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>闭包是<strong>函数指针(fn)和环境</strong>的组合</p>
<p>闭包<strong>不捕获任何环境中变量</strong>是一个函数指针。</p>
<p>闭包的方法移出了所捕获的变量的所有权，则会实现<code>FnOnce(self)</code></p>
<p>闭包的方法<strong>没有</strong>移出所捕获的变量的所有权，<strong>并且对变量进行了修改</strong>，即通过可变借用使用所捕获的变量，则会实现<code>FnMut(&amp;mut self)</code></p>
<p>闭包的方法<strong>没有</strong>移出所捕获的变量的所有权，<strong>并且没有对变量进行修改</strong>，即通过不可变借用使用所捕获的变量，则会实现<code>Fn(&amp;self)</code></p>
<p>如果你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 <code>move</code> 关键字。这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。</p>
<blockquote>
<p><img src="futures_in_rust/./../img/rust-closure2.jpg" alt="avatar" /></p>
</blockquote>
<h3 id="例"><a class="header" href="#例">例</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(unboxed_closures, fn_traits)]
<span class="boring">fn main() {
</span>//定义闭包结构体
struct Say {
    //捕获的环境变量
    s: String,
}

//实现FnOnce方法
impl FnOnce&lt;()&gt; for Say {
    type  Output = ();
    extern &quot;rust-call&quot;  fn call_once(self, args: ()) -&gt; () {
        println!(&quot;{}&quot;, self.s);
    }
}

//实现FnMut方法
impl FnMut&lt;()&gt; for Say {
    extern &quot;rust-call&quot;  fn call_mut(&amp;mut self, args: ()) -&gt; () {
        self.s.push_str(&quot; world!&quot;);
        println!(&quot;{}&quot;, self.s);
    }
}

//实现Fn方法
impl Fn&lt;()&gt; for Say {
    extern &quot;rust-call&quot; fn call(&amp;self, args: ()) -&gt; () {
        println!(&quot;{}&quot;, self.s);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut greeting = &quot;hello&quot;.to_string();
    //闭包say捕获环境变量greeting
    let mut say = Say { s: greeting};
    
    //不修改环境变量 不捕获所有权
    say.call(());
    //修改环境变量, 不捕获所有权
    say.call_mut(());
    //移除所有权
    say.call_once(());
    //之后再调用call call_mut call_once就会报错
}
</code></pre></pre>
<h3 id="在了解了rust闭包内部实现之后再看一些例子"><a class="header" href="#在了解了rust闭包内部实现之后再看一些例子">在了解了rust闭包内部实现之后,再看一些例子</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//实现了call. 不修改环境变量,不捕获所有权,可多次调用say,但不能修改greeting
let greeting = &quot;hello&quot;;
let say = || {
    println!(&quot;{}&quot;, greeting);
};
say();

//实现了call_mut,修改环境变量,不捕获所有权,可多次调用say,可修改greeting
let mut greeting = &quot;hello&quot;.to_string();
let mut say = || {
    greeting.push_str(&quot; world&quot;);
    println!(&quot;{}&quot;, greeting);
};
say();


//实现了call_once,修改环境变量(也可以不修改),捕获所有权,只能调用一次say
let mut greeting = &quot;hello&quot;.to_string();
let mut say = move || {
    greeting.push_str(&quot; world&quot;);
    println!(&quot;{}&quot;, greeting);
};
say();
<span class="boring">}
</span></code></pre></pre>
<p>图片来源于<a href="https://zhuanlan.zhihu.com/p/341815515">Rust中的闭包与关键字move</a></p>
<h3 id="参考"><a class="header" href="#参考">参考</a></h3>
<p><a href="https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759">Understanding Closures in Rust.</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/341815515">Rust中的闭包与关键字move</a></p>
<p><a href="https://time.geekbang.org/course/detail/100060601-294649">rust语言基础(张汉东)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包到生成器"><a class="header" href="#闭包到生成器">闭包到生成器</a></h1>
<h2 id="生成器"><a class="header" href="#生成器">生成器</a></h2>
<p><strong>一个简单的生成器</strong></p>
<blockquote>
<p>下面gen是一个生成器. 可以看处它是使用闭包的语法声明的. 
与闭包不同的是. 它多了一个yield关键字, 它可以通过resume()方法多次恢复.<br />
每次resume()调用时,闭包内的代码都会运行, 直到遇到yield<br />
resume返回 yield的值</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#![feature(generators, generator_trait)]
use std::ops::Generator;
use std::pin::Pin;

fn main() {
    // 用闭包创建一个生成器
    let mut gen = || {
        yield 1;
        yield 2;
        yield 3;
        yield 4;
        return 5;
    };

    //不断调用resume执行
    for _ in 0..5 {
        let c = Pin::new(&amp;mut gen).resume(());
        println!(&quot;{:?}&quot;, c);
    }

}
</code></pre></pre>
<blockquote>
<p>前4个调用resume()将返回GeneratorState::Yielded(x)，然后返回GeneratorState::Complete(x).</p>
</blockquote>
<p><strong>输出</strong></p>
<p>Yielded(1)</p>
<p>Yielded(2) </p>
<p>Yielded(3) </p>
<p>Yielded(4) </p>
<p>Complete(5)</p>
<blockquote>
<p>resume()真正返回的是GeneratorState   ,定义如下</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GeneratorState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>接下来看看生成器的背后具体做了什么,以及它和我们之前将的闭包的关系</strong></p>
<p><strong>这是上面例子的等效代码</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::pin::Pin;

#[derive(Debug)]
pub enum GeneratorState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}

pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(self: Pin&lt;&amp;mut Self&gt;) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}

//和上一章中定义的闭包结构体类似,包含捕获的环境
struct MyGen {
    i: i32,
}

//为MyGen实现Generator trait
impl Generator for MyGen {
    type Yield = i32;
    type Return = i32;
    fn resume(mut self : Pin&lt;&amp;mut Self&gt;) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        self.i += 1;
        if self.i == 5 {
            GeneratorState::Complete(self.i)
        } else {
            GeneratorState::Yielded(self.i)
        }
    }
}

fn main() {
    let mut gen = MyGen { i: 0 };    
    for _ in 0..5 {
        let c = Pin::new(&amp;mut gen).resume();
        println!(&quot;{:?}&quot;, c);
    }
}
</code></pre></pre>
<p><strong>再看闭包内部的实现</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

impl FnOnce&lt;()&gt; for Say {
    type  Output = ();
    extern &quot;rust-call&quot;  fn call_once(self, args: ()) -&gt; () {
        foo();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可见每次生成器执行resume,相当于闭包执行了一次call_once(call, call_mut)</p>
<p>与闭包不同的是,每次resume,生成器都将执行到结果为GeneratorState::Yielded()处, 编译器将生成器编译成状态机。每处yield出对应一个不同的状态.</p>
<p><strong>参考</strong></p>
<p><a href="https://cfsamson.github.io/books-futures-explained/introduction.html">Futures Explained in 200 Lines of Rust</a></p>
<p><a href="https://time.geekbang.org/course/detail/100060601-294649">rust语言基础(张汉东)</a></p>
<p><a href="https://github.com/rust-lang/rust/issues/43122">Experimentally add coroutines to Rust #43122</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generator---future"><a class="header" href="#generator---future">generator---&gt;future</a></h1>
<h2 id="future的定义"><a class="header" href="#future的定义">Future的定义</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>可见与生成器的区别是:</strong></p>
<p>生成器使用resume来执行进入下一个状态, Future使用poll.</p>
<p>生成器返回Yielded或者Complete, Future返回Pending或者Ready.</p>
<p>Future中有Context, waker</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-2021-os-camp"><a class="header" href="#-2021-os-camp">🚧 2021-os-camp</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="76"><a class="header" href="#76">7.6</a></h1>
<p><strong>开始tutorial!</strong></p>
<p><strong>使用链接脚本指定程序内存布局</strong></p>
<p>一般来说，一个程序按照功能不同会分为下面这些段：</p>
<table><tr><td bgcolor=#EFF5FF>
.text 段，即代码段，存放代码 出错时候的eip往往在这个段.指向某一条语句.以此来定位问题；
<p>.rodata 段，即只读数据段，顾名思义里面存放只读数据，通常是程序中的常量；</p>
<p>.data 段，存放被初始化的可读写数据，通常保存程序中的全局变量；</p>
<p>.bss 段，存放被初始化为 00 的可读写数据，与 .data 段的不同之处在于我们知道它要被初始化为 00 ，因此在可执行文件中只需记录这个段的大小以及所在位置即可，而不用记录里面的数据。</p>
<p>stack ，即栈，用来存储程序运行过程中的局部变量，以及负责函数调用时的各种机制。它从高地址向低地址增长；</p>
<p>heap ，即堆，用来支持程序<b><font color=#42ACF4>运行过程</font></b>中内存的动态分配，比如说你要读进来一个字符串，在你写程序的时候你也不知道它的长度究竟为多少，于是你只能在运行过程中，知道了字符串的长度之后，再在堆中给这个字符串分配内存。</p>
</td></tr></table>
<p>链接脚本示例:</p>
<pre><code class="language-linker">
SECTIONS
{
. = 0x10000;
.text : { *(.text) }
. = 0x8000000;
.data : { *(.data) }
.bss : { *(.bss) }
}
</code></pre>
<p><b></b>
. 表示起始地址 如果没有这个地址，默认该符号的值为0</p>
<p>.text : { *(.text) } : 将所有(*符号代表任意输入文件)文件的.text section合并成一个.text section,该section的地址由定位器符号的值指定, 即0x10000.</p>
<p>. = 0x8000000 ：把定位器符号置为0x8000000</p>
<p>.data : { *(.data) } : 同上</p>
<p>.bss : { *(.bss) } :  同上</p>
<p><strong>其他命令</strong>
ENTRY(SYMBOL) :将符号SYMBOL的值设置成入口地址。</p>
<p>INCLUDE filename : 包含其他名为filename的链接脚本</p>
<p>INPUT(files): 将括号内的文件做为链接过程的输入文件</p>
<p>GROUP(files) : 指定需要重复搜索符号定义的多个输入文件</p>
<p>OUTPUT(FILENAME) : 定义输出文件的名字</p>
<p>SEARCH_DIR(PATH) ：定义搜索路径，</p>
<p>OUTPUT_ARCH() : 设置输出文件的体系结构</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>python生成链接脚本,以及用户程序build</strong></p>
<p>多个用户程序build</p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()
for app in apps:
    app = app[:app.find('.')]
    lines = []
    lines_before = []
    with open(linker, 'r') as f:
        for line in f.readlines():
            lines_before.append(line)
            line = line.replace(hex(base_address), hex(base_address+step*app_id))
            lines.append(line)
    with open(linker, 'w+') as f:
        f.writelines(lines)
    os.system('cargo build --bin %s --release' % app)
    print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
    with open(linker, 'w+') as f:
        f.writelines(lines_before)
    app_id = app_id + 1

</code></pre>
<p><strong>生成bin文件...objcopy</strong></p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()

for app in apps:
    app = app.strip('.rs')
    os.system('rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/%s --strip-all -O binary  target/riscv64gc-unknown-none-elf/release/%s.bin'%(app,app))
</code></pre>
<p><strong>生成链接脚本link_app.S  目录下所有bin文件写进链接脚本</strong></p>
<pre><code class="language-python">import os


f = open('link_app.S', 'w')

f.writelines(&quot;    .align 3\n&quot;)
f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global _num_app\n&quot;)
f.writelines(&quot;_num_app:\n&quot;)
apps = os.listdir('target/riscv64gc-unknown-none-elf/release')
num = 0

bin_list = []
for app in apps:
    if 'bin' in app:
        num += 1
        bin_list.append(app)

f.writelines(&quot;    .quad %s\n&quot; %len(bin_list))

count  = 0
for app in bin_list:
    f.writelines(&quot;    .quad app_%s_start\n&quot; %count)
    count += 1

f.writelines(&quot;\n&quot;)

f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global app_0_start\n&quot;)
f.writelines(&quot;    .global app_0_end\n&quot;)

for i in range(len(bin_list)):
    f.writelines(&quot;app_%s_start:\n&quot; %i)
    f.writelines(&quot;    .incbin \&quot;../test/target/riscv64gc-unknown-none-elf/release/%s\&quot;\n&quot; %bin_list[i])
    f.writelines(&quot;app_%s_end:\n\n&quot; %i)
    
f.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>彩色输出</strong></p>
<p>用print宏包装 info debug error. 加点参数就能显示出不同颜色</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! print {
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print(format_args!($($arg)*));
    });
}

#[macro_export]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;{}\n&quot;, format_args!($($arg)*)));
}


#[macro_export]
macro_rules! info {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[31m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}

#[macro_export]
macro_rules! debug {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[32m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}

#[macro_export]
macro_rules! error {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[34m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统多核支持"><a class="header" href="#操作系统多核支持">操作系统多核支持</a></h1>
<p>在intel手册8.4 MULTIPLE-PROCESSOR (MP) INITIALIZATION 可查到多核启动相关信息.</p>
<font size = 3> 
8.4.1 BSP and AP Processors
The MP initialization protocol defines two classes of processors: the bootstrap processor (BSP) and the application
processors (APs). Following a power-up or RESET of an MP system, system hardware dynamically selects one of the
processors on the system bus as the BSP. The remaining processors are designated as APs.
As part of the BSP selection mechanism, the BSP flag is set in the IA32_APIC_BASE MSR (see Figure 10-5) of the
BSP, indicating that it is the BSP. This flag is cleared for all other processors.
The BSP executes the BIOS’s boot-strap code to configure the APIC environment, sets up system-wide data structures, and starts and initializes the APs. When the BSP and APs are initialized, the BSP then begins executing the
operating-system initialization code.
</font>
<br></br>
<font size = 3> 
Following a power-up or reset, the APs complete a minimal self-configuration, then wait for a startup signal (a SIPI
message) from the BSP processor. Upon receiving a SIPI message, an AP executes the BIOS AP configuration code,
which ends with the AP being placed in halt state.
For Intel 64 and IA-32 processors supporting Intel Hyper-Threading Technology, the MP initialization protocol treats
each of the logical processors on the system bus or coherent link domain as a separate processor (with a unique
APIC ID). During boot-up, one of the logical processors is selected as the BSP and the remainder of the logical
processors are designated as APs.
</font>
<p>在启动时候.会选出一个核作为BSP. 同时设置其他核(APs)的flag信息.然后由BSP来执行初始化其他核(APs). 当BSP和APs都初始化完成后,由BSP来执行系统初始化代码</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>学习多核启动支持</strong></p>
<p><strong>参考已有的实现</strong></p>
<p>主要看链接脚本中指定的入口汇编代码,以及接下来跳转到的代码</p>
<p>1.rcore</p>
<pre><code class="language-x86asm">    .section .text.entry
    .globl _start
_start:
    # a0 == hartid
    # pc == 0x80200000
    # sp == 0x800xxxxx

    # 1. set sp
    # sp = bootstack + (hartid + 1) * 0x10000
    add     t0, a0, 1
    slli    t0, t0, 14
    lui     sp, %hi(bootstack)
    add     sp, sp, t0

....(略)

    # 3. jump to rust_main (absolute address)
    lui     t0, %hi(rust_main)
    addi    t0, t0, %lo(rust_main)
    jr      t0

    .section .bss.stack
    .align 12   # page align
    .global bootstack
bootstack:
    .space 4096 * 4 * 8
    .global bootstacktop
bootstacktop:

    .section .data
    .align 12   # page align
....(略)
</code></pre>
<p><strong>加载常量到某寄存器常用的汇编代码</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(constant)
addi    t0, t0, %lo(constant)
</code></pre>
<p><strong>加载绝对地址到某寄存器</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(address)
addi    t0, t0, %lo(address)
</code></pre>
<p><strong>有了这个基础这段代码就好理解了</strong>
为当前核心设置一个栈,地址为:sp = bootstack + (hartid + 1) * 0x10000
再跳转到rust_main....</p>
<p><strong>next:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn rust_main(hartid: usize, device_tree_paddr: usize) -&gt; ! {
    let device_tree_vaddr = phys_to_virt(device_tree_paddr);

    unsafe {
        cpu::set_cpu_id(hartid);
    }

    if hartid != BOOT_HART_ID {
        while !AP_CAN_INIT.load(Ordering::Relaxed) {}
        others_main(hartid);
    }

    unsafe {
        memory::clear_bss();
    }

    println!(
        &quot;Hello RISCV! in hart {}, device tree @ {:#x}&quot;,
        hartid, device_tree_vaddr
    );

    crate::logging::init();
    unsafe {
        trapframe::init();
    }
    memory::init(device_tree_vaddr);
    timer::init();
    // FIXME: init driver on u540
    #[cfg(not(any(feature = &quot;board_u540&quot;)))]
    board::init(device_tree_vaddr);
    unsafe {
        board::init_external_interrupt();
    }
    crate::process::init();

    AP_CAN_INIT.store(true, Ordering::Relaxed);
    crate::kmain();
}

fn others_main(hartid: usize) -&gt; ! {
    unsafe {
        trapframe::init();
    }
    memory::init_other();
    timer::init();
    info!(&quot;Hello RISCV! in hart {}&quot;, hartid);
    crate::kmain();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>rust_main的多核处理</strong></p>
<p>1.设置thread_pointer为hartid</p>
<p>2.首先让hartid = BOOT_HART_ID执行完rust_main,同时如果其他hart进入到此函数则循环等待.直到BST(boot_hart)执行启动代码,并设置原子操作操作AP_CAN_INIT.store(true, Ordering::Relaxed)后,再执行其他hart的初始化操作.</p>
<p>这里用到了rust中的atomic基本用法如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicBool, Ordering};
let some_bool = AtomicBool::new(true);
some_bool.store(false, Ordering::Relaxed);
assert_eq!(some_bool.load(Ordering::Relaxed), false);
<span class="boring">}
</span></code></pre></pre>
<table><td bgcolor=#EFF5FF>
申请一个原子型bool变量初始化为true. AtomicBool::new(true)
<p>load(Ordering::Relaxed)来获得变量值</p>
<p>store(false, Ordering::Relaxed)来改变值</p>
</td></table>
<p><strong>多核启动概括</strong></p>
<p>1.让主核(BST)执行完启动代码.同时设置原子操作让其他核等待.然后执行其他核(AP)的启动代码.</p>
<p>2.为每个核设置好栈</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>实现中断机制</strong></p>
<p>内核栈:固定大小,每个进程,线程都有一个内核栈.内核栈是进程,线程在内核态下所使用的栈.在用户态下cpu的sp指针指向的是用户栈的栈顶.内核态下指定内核栈的栈顶.</p>
<p><strong>中断实现思路</strong></p>
<table><tr><td bgcolor=#EFF5FF>
1.区分是从用户态还是内核态中断, 保存32个通用寄存器以及一些控制与状态寄存器csr.然后跳转到中断处理函数  此部分用汇编语言写
<p>2.进入中断处理函数,print中断来源(用户态or内核态) 当前中断指令(pc) 中断原因(读取scause寄存器)
# 如果从内核态进入中断， sstatus 的 SPP 位被硬件设为 1
# 如果从用户态进入中断， sstatus 的 SPP 位被硬件设为 0</p>
<p>3.恢复上下文. 恢复32个通用寄存器,以及一些csr寄存器.</p>
</td></tr></table>
<p>按照 TrapContext 结构体的内存布局，它从低地址到高地址分别按顺序放置 x0~x31，最后是 sstatus 和 sepc 。因此通用寄存器 xn 应该被保存在地址区间 [sp+8n,sp+8(n+1)) 。 在这里我们正是这样基于 sp 来保存这些通用寄存器的。
(主要保存trapframe中内容)保存32个通用寄存器以及一些控制与状态寄存器csr 此部分与trapframe结构体一致. 恢复时只要把结构体指针指向sp就能恢复trapframe</p>
<p>csrrw rd, csr, rs 可以将 CSR 当前的值读到通用寄存器 rd 中，然后将 通用寄存器 rs 的值写入该 CSR 。因此这里起到的是交换 sscratch 和 sp 的效果。在这一行之前 sp 指向用户栈， sscratch 指向内核栈，现在 sp 指向内核栈， sscratch 指向用户栈。</p>
<hr />
<p>从用户态中断时,sp指向内核栈.然后在sp[...]区间中保存trapcontext内容</p>
<p><strong>疑问</strong>:(中断处理程序用的也是内核栈,难道执行流不会改变内核栈中的内容吗? 那保存了还有什么意义. 该执行流仅会改动trapcontext中的内容吗?)</p>
<p><strong>分析</strong>:sp永远指向执行流中的栈.所以中断处理程序运行时候并不会干扰到原本保持的内容</p>
<p>more:内核栈可以理解为是一个中断发生时临时存放通用寄存器以及指令与状态寄存器信息的栈. 实际内核在执行中断处理函数时并不会用到该栈(指的是不修改.还是可以从中读取一些信息),内核执行中断处理函数时所使用的栈是sp.(在任何执行流中使用的栈都应该是sp)</p>
<hr />
<p><strong>addi sp, sp, -34*8</strong>为什么这条指令可以表示分配了栈帧. sp指向的是栈顶. 栈向低地址增长,现在减少sp的值意味着栈顶的提高.相当于分配了空间</p>
<hr />
<p><strong>时钟中断</strong></p>
<p>相关寄存器 mtime  ​mtimecmp   mie  sie sip</p>
<p>SI(Software Interrupt)，软件中断
TI(Timer Interrupt)，时钟中断
EI(External Interrupt)，外部中断</p>
<p>​mtimecmp ​= ​mtime ​+ ​X​
A timer interrupt (if enabled) is generated whenever ​mtime ​is greater than or equal to the valuein the ​mtimecmp ​register. Therefore, to generate a timer interrupt after ​X ​cycles, one can updatemtimecmp ​register as follows: ​mtimecmp ​= ​mtime ​+ ​X​.</p>
<p>// 根据中断原因分类讨论</p>
<pre><code>// 只能当每一次时钟中断触发时
// 设置下一次时钟中断的触发时间
// 设置为当前时间加上 TIMEBASE
// 这次调用用来预处理
</code></pre>
<p>根绝scause 区分中断类别.   该有不同的处理了   以及设置多少cycle触发一次时钟中断</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>中断具体实现</strong></p>
<p><strong>整理下中断操作相关的csr寄存器</strong></p>
<blockquote>
<p><strong>sepc</strong>:发生异常的指令的pc被存入sepc. 我们需要读取他来获得bug信息.</p>
<p><strong>stvec</strong>:riscv处理器trap后跳入的PC地址由一个叫做机器模式异常入口基地址寄存器mtvec的csr寄存器指定. mtvec是一个可读可写的寄存器, 软件可以编程设定它的值.在S模式下用到的寄存器即为stvec.我们需要用写stvec来跳转到中断处理代码.trap.asm中的__alltraps处</p>
<p><strong>scaues</strong>:它会记录中断发生的原因, 需要用读取该寄存器来根据不同类型中断执行不同处理代码</p>
<p><strong>sstatus</strong>:需要设置它的sie位来使能中断</p>
</blockquote>
<p><strong>如何读写csr寄存器</strong></p>
<p>读写satp寄存器为例:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, satp&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn write(x: usize) {
    llvm_asm!(&quot;csrw satp, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>初始化中断</strong></p>
<p>在处理器的程序执行过程中,一旦发生异常,则终止当前的程序流,处理器被强行跳转到一个新的PC地址。</p>
<p>在riscv中S态该地址由stvec指定stvec低2位位mode域,高30位是base域.</p>
<p>当<strong>MODE</strong>=0，设置为 Direct 模式时，则所有的异常响应时处理器均跳转到base值指示的pc地址。</p>
<p>当<strong>MODE=1</strong>时，设置为 Vectored 模式时，遇到中断我们会进行跳转如下：PC-&gt;BASE + 4 x cause。而这样，我们只需将各中断处理程序放在正确的位置，并设置好 stvec ，遇到中断的时候硬件根据中断原因就会自动跳转到对应的中断处理程序了</p>
<p>在此我们选择Direct模式.跳转到统一地址进行处理</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init() {
    unsafe {
        extern &quot;C&quot; {
            fn __alltraps();
        }
        //设置trap跳转到统一地址 __alltraps处
        println!(&quot;trap init--------------&quot;);
        stvec::write(__alltraps as usize);
        sstatus::set_sie();
    }
    println!(&quot;++++ setup interrupt! ++++&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>stvec</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub unsafe fn _write(x: usize) {
    llvm_asm!(&quot;csrw stvec, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
//0为设置成Direct模式
#[inline]
pub unsafe fn write(addr: usize) {
    _write(addr + 0 as usize);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>sstatus</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIE: usize = 1 &lt;&lt; 1;  // supervisor interrupt enable
#[inline]
pub fn write(x: usize) {
    unsafe {llvm_asm!(&quot;csrw sstatus, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);}
}

#[inline]
pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, sstatus&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}

#[inline]
pub fn set_sie() {
    write(read() | SIE);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>__alltrap</strong></p>
<pre><code class="language-x86asm">__alltraps:
    csrrw sp, sscratch, sp       交换用户栈和内核栈
    addi sp, sp, -34*8           在内核栈上分配一个trapcontext大小的栈帧
    
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct TrapContext {
    // 32个通用寄存器 
    pub x: [usize; 32], 
    // 几个相关csr寄存器
    pub sstatus: usize,
    pub sepc: usize,
    pub stval: usize,
    pub scause: usize,
    //共需(32+4)*8的栈空间
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>trap.asm</strong></p>
<pre><code class="language-x86asm">	.section .text
	.globl __alltraps
__alltraps:
	SAVE_ALL
	mv a0, sp
	jal trap_handler

	.globl __trapret
__trapret:
	RESTORE_ALL
	sret

.equ XLENB, 8
.macro LOAD a1, a2
	ld \a1, \a2*XLENB(sp)
.endm

.macro STORE a1, a2
	sd \a1, \a2*XLENB(sp)
.endm
</code></pre>
<p><strong>save_all和restore_all</strong></p>
<pre><code class="language-x86asm">
.macro SAVE_ALL
	csrrw sp, sscratch, sp
	addi sp, sp, -36*XLENB
	STORE x1, 1
	STORE x3, 3
...
    STORE x30, 30
    STORE x31, 31

	csrrw s0, sscratch, x0
	csrr s1, sstatus
	csrr s2, sepc
	csrr s3, stval
	csrr s4, scause
	
	STORE s0, 2
	STORE s1, 32
	STORE s2, 33
	STORE s3, 34
	STORE s4, 35
.endm
</code></pre>
<pre><code class="language-x86asm">.macro RESTORE_ALL
	LOAD s1, 32
	LOAD s2, 33
	andi s0, s1, 1 &lt;&lt; 8
    csrw sstatus, s1
    csrw sepc, s2
	LOAD x1, 1
	LOAD x3, 3
...
    LOAD x30, 30
    LOAD x31, 31

	LOAD x2, 2
.endm
</code></pre>
<p>分别用ld和sd来保存通用寄存器.64位数据需要8字节空间存储.用寄存器编号*8(sp)来存放到trapcontext中相应位置去
区分是从用户态中断还是从内核态中断.只需判断sp是否为0.sp!=0则是从用户态进入中断.sp=0则是从内核态进入中断.无需切换栈</p>
<p>实现中断处理函数trap_handler</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    match cause {

        3 =&gt; breakpoint(&amp;mut tf.sepc),
        5 =&gt; super_timer(),
        12 =&gt; page_fault(tf),
        13 =&gt; page_fault(tf),
        15 =&gt; page_fault(tf),
        _ =&gt; println!(&quot;undefined trap!&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>1.打印出中断类型,以及触发中断指定的pc值.以便以后调试</p>
<p>2.根据cause不同分别进行不同的处理</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>如果是断点则打印断点pc. 然后pc+2.执行下一条指令 (riscv64指定长度为4字节.原来应该是sepc+4.但是编译器的行为会压缩.所以修正为sepc+2)
fn breakpoint(sepc: &amp;mut usize) {
    println!(&quot;a breakpoint epc:0x{:x}&quot;, sepc);
    *sepc += 2;
}

每次触发时钟中断TICKS+1.触发100次打印一次.
fn super_timer() {
    clock_set_next_event();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}

//page_fault
fn page_fault(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    println!(&quot;{:?} va = {:#x} instruction = {:#x}&quot;, cause, tf.stval, tf.sepc);
    panic!(&quot;page fault!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>至此trap可以可以正常工作</strong></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>运行应用程序</strong></p>
<p><strong>将应用程序链接到内核</strong></p>
<p>link_app.S</p>
<pre><code class="language-x86asm">    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 3
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_2_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;
app_1_end:

    .section .data
    .global app_2_start
    .global app_2_end
app_2_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;
app_2_end:

</code></pre>
<p><strong>.incbin</strong></p>
<table><tr><td bgcolor=#EFF5FF>
The incbin directive includes file verbatim at the current location. You can control the search paths used with the -I command-line option (refer to Chapter 3 Command-Line Options). Quotation marks are required around file.
<p>The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user's responsibility to make sure that proper alignment is provided both before and after the incbin directive.</p>
</td></tr></table>
<p><strong>.quad</strong></p>
<p>用来定义一个8字节. 地址为各个应用程序起始地址</p>
<p>num_app_ptr[x] 来得到_num_app中定义的应用程序起始地址</p>
<p>然后用copy_from_slice来实现类似memcpy的功能</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_MANAGER: AppManager = AppManager {
        inner: RefCell::new({
            extern &quot;C&quot; { fn _num_app(); }
            let num_app_ptr = _num_app as usize as *const usize;
            let num_app = unsafe { num_app_ptr.read_volatile() };
            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];
            let app_start_raw: &amp;[usize] = unsafe {
                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
            };
            app_start[..=num_app].copy_from_slice(app_start_raw);
            AppManagerInner {
                num_app,
                current_app: 0,
                app_start,
            }
        }),
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>把应用程序的代码和数据存在了app_start的数组之后.然后利用trap返回在内核栈上压入设置好的栈
riscv函数调用规定第一个参数放在a0中. 利用这点trap.asm 中 __trapret mv sp, a0  可以让我们压入我们设置好的栈
栈设置:</p>
<p>1.ssp设置为user</p>
<p>2.sepc设置为应用程序入口地址</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TrapContext {
    pub fn set_sp(&amp;mut self, sp: usize) { self.x[2] = sp; }
    pub fn app_init_context(entry: usize, sp: usize) -&gt; Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
        };
        cx.set_sp(sp);
        cx
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>由于在 RISC-V 中栈是向下增长的, 栈顶地址 = 起始地址+栈大小</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl KernelStack {
    fn get_sp(&amp;self) -&gt; usize {
        self.data.as_ptr() as usize + KERNEL_STACK_SIZE
    }
    pub fn push_context(&amp;self, cx: TrapContext) -&gt; &amp;'static mut TrapContext {
        let cx_ptr = (self.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) as *mut TrapContext;
        unsafe { *cx_ptr = cx; }
        unsafe { cx_ptr.as_mut().unwrap() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>处理系统调用</strong></p>
<p>系统调用:通过查riscv手册 Environment call from U-mode 为异常.异常号为8</p>
<p>在traphandler中加入对系统调用处理</p>
<p>通过读取scause的第64位来区分是中断还是异常, 然后视不同情况进行处理</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    let tmp = scause::read().get_bit(63);
    //tmp  区分中断还是异常
    if tmp == true {
        match cause {
            _ =&gt; println!(&quot;undefined trap!&quot;)
        }
        tf
    }else{
        match cause {
            2 =&gt; {
                println!(&quot;[kernel] IllegalInstruction in application, core dumped.&quot;);
                run_next_app();
            }
            3 =&gt; breakpoint(&amp;mut tf.sepc),
            5 =&gt; super_timer(),
            // 12 =&gt; page_fault(tf),
            // 13 =&gt; page_fault(tf),
            7 | 15 =&gt; {
                println!(&quot;[kernel] PageFault in application, core dumped.&quot;);
                run_next_app();
            }   
            8 =&gt; user_syscall(tf),
            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最终得到预取结果~~</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>++++ setup interrupt! ++++
[kernel] num_app = 3
[kernel] app_0 [0x80210654, 0x802119e4)
[kernel] app_1 [0x802119e4, 0x80212e14)
[kernel] app_2 [0x80212e14, 0x802143ac)
[kernel] Loading app_0
[kernel] Loading app_0 finished
Hello, world!
[kernel] IllegalInstruction in application, core dumped.
[kernel] Loading app_1
[kernel] Loading app_1 finished
Into Test store_fault, we will insert an invalid store operation...
Kernel should kill this application!
[kernel] PageFault in application, core dumped.
[kernel] Loading app_2
[kernel] Loading app_2 finished
3^10000=5079
3^20000=8202
3^30000=8824
3^40000=5750
3^50000=3824
3^60000=8516
3^70000=2510
3^80000=9379
3^90000=2621
3^100000=2749
Test power OK!
[kernel] Application exited with code 0
panicked at 'All applications completed!', src\batch.rs:61:13
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>运行应用程序总结</strong></p>
<p><strong>1.编写应用程序</strong></p>
<p>编写用户态syscall. 就如同os调用sbicall类似!</p>
<p>通过linker链接脚本.来指定应用程序入口地址</p>
<p><strong>2.链接应用程序</strong></p>
<p>.quad 来指定一个8字节地址</p>
<p>.incbin 来载入一个文件</p>
<p><strong>3.在内核中载入应用程序</strong></p>
<p>通过from_raw_parts_mut 和 copy_from_slice 来实现类似memcpy功能</p>
<p><strong>4.为应用程序设置好TrapContext</strong></p>
<p>1.ssp设置为user</p>
<p>2.sepc设置为应用程序入口地址</p>
<p><strong>5.利用trapret来把设置好的TrapContext压入到内核栈中</strong></p>
<p><strong>6.中断中加入对系统调用支持</strong></p>
<p>1.Environment call from U-mode</p>
<p><strong>7.选择何时运行应用程序</strong></p>
<p>调度器相关.实验暂时未涉及.只是通过人为触发异常指令来进入中断,然后在中断处理中运行下一个应用程序</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>第三章</strong></p>
<p><strong>多道程序放置与加载</strong></p>
<p>和上一章不同的是app其实地址被加载到了APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT位置上</p>
<p><strong>任务切换</strong></p>
<p>在处理trap时.我们需要切换成内核栈.而在用户程序切换时,我们需要切换的另一个程序的栈.</p>
<p>当前任务切换的本质是函数调用,我们需要保存的是riscv函数调用规定中caller-saved的寄存器.s0~s11</p>
<p>保存好当前任务的信息后.如何返回当前任务继续执行?. 在做函数切换前,编译器会帮我们吧ra寄存器的值改为</p>
<p>函数调用返回后第一条指令的地址. 因此需要保存ra</p>
<p>切换到目标任务. riscv函数调用第一第二个参数分别保存在a0/a1.因此ld sp, 0(a1)即可换栈.</p>
<p>然后读取ra s0~s11. </p>
<p><strong>协作式调度</strong></p>
<p>有了任务切换,那么何时进行切换?</p>
<p>现在的做法是应用程序主动暂停sys_yield 以及主动退出sys_exit</p>
<p><strong>任务管理器</strong></p>
<p>保存了各个程序切换时描述自身的栈信息</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskManager {
    num_app: usize,
    inner: RefCell&lt;TaskManagerInner&gt;,
}

struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    current_task: usize,
}

unsafe impl Sync for TaskManager {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>切换任务</strong></p>
<p>__switch第一个参数是自身栈,第二个参数是目标任务的栈</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_next_task(&amp;self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.borrow_mut();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr2 = inner.tasks[current].get_task_cx_ptr2();
        let next_task_cx_ptr2 = inner.tasks[next].get_task_cx_ptr2();
        core::mem::drop(inner);
        unsafe {
            __switch(
                current_task_cx_ptr2,
                next_task_cx_ptr2,
            );
        }
    } else {
        panic!(&quot;All applications completed!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>find_next_task.找到状态为TaskStatus::Ready的任务</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    let inner = self.inner.borrow();
    let current = inner.current_task;
    (current + 1..current + self.num_app + 1)
        .map(|id| id % self.num_app)
        .find(|id| {
            inner.tasks[*id].task_status == TaskStatus::Ready
        })
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>分时多任务系统与抢占式调度</strong></p>
<p>比较简单.设置好时钟中断, 并在时钟中断发生时run_next_task(),在trap_handler中加入相应处理即可</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
.........
        match cause {
.........
            5 =&gt; super_timer(),

            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}


fn super_timer() {
    clock_set_next_event();
    suspend_current_and_run_next();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>chapter3练习</strong></p>
<p><strong>stride 调度算法</strong></p>
<p>之前是在发生时钟中断时,选择下一个Ready状态的程序运行,stride调度算法即,程序初始stride为0.为每个程序设置一个pass.每次程序运行stride+pass. 
并总是选择stride最小的程序运行.</p>
<p><strong>增加数据结构</strong></p>
<p>task_pass </p>
<p>task_stride</p>
<p>task_priority </p>
<p>task_time</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    pub current_task: usize,
    pub task_pass:[usize; MAX_APP_NUM],
    pub task_stride:[usize; MAX_APP_NUM],
    pub task_priority:[usize; MAX_APP_NUM],
    pub task_time:[usize; MAX_APP_NUM],
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>寻找下一个执行程序</strong></p>
<p>1.更新当前进程stride</p>
<p>2.寻找下一个stride值最小的进程</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    //update
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    let priority = inner.task_priority[current];
    if inner.tasks[current].task_status == TaskStatus::Ready {
        inner.task_stride[current] = inner.task_stride[current] + 127 / priority
    }

    let num_app = get_num_app();
    let mut max_stride = 10000000;
    let mut next = 0 as usize;
    for i in 0..num_app{
        let stride_i  = inner.task_stride[i];
        if stride_i &lt;= max_stride  &amp;&amp; inner.tasks[i].task_status != TaskStatus::Exited{
            next = i;
            max_stride =  stride_i;
        }
    }
    let mut  exited_count = 0 as usize;
    for i in 0..num_app{
        
        if inner.tasks[i].task_status == TaskStatus::Exited{
            exited_count += 1;
        }
    }
    if exited_count == num_app{
        println!(&quot;all exited&quot;);
        None
    }else{
        println!(&quot; next min stride  app id{}&quot;, next);
        Some(next)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>标记退出进程</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mark_current_suspended(&amp;self) {
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.task_time[current] += 1;
    inner.tasks[current].task_status = if inner.task_time[current] &gt;= 500 {
        inner.task_stride[current] = 10000000;
        println!(&quot;app id {}  exited  run out of time&quot;, current);
        TaskStatus::Exited
    } else {
        TaskStatus::Ready
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>首先是id0运行.id0 exit 切换到id3</p>
<p>id3执行的是主动yeild所以立马进行了切换</p>
<p>....</p>
<p>all exited所以程序执行完毕</p>
<p>程序如期运行</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OpenSBI v0.7
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 128 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
stext 80200000 etext 8020a000
srodata 8020a000 erodata 80236000
sdata 8023663c edata 8023be49
sbss 8024be50 ebss 8024c058
Hello, world!
base i 0x80400000
base i 0x80420000
base i 0x80440000
base i 0x80460000
load app done
++++ setup timer!     ++++
power_3 [10000/200000]
power_3 [20000/200000]
power_3 [30000/200000]
power_3 [40000/200000]
power_3 [50000/200000]
power_3 [60000/200000]
power_3 [70000/200000]
power_3 [80000/200000]
power_3 [90000/200000]
power_3 [100000/200000]
power_3 [110000/200000]
power_3 [120000/200000]
power_3 [130000/200000]
power_3 [140000/200000]
power_3 [150000/200000]
power_3 [160000/200000]
power_3 [170000/200000]
power_3 [180000/200000]
power_3 [190000/200000]
power_3 [200000/200000]
3^200000 = 871008973
Test power_3 OK!
[kernel] Application exited with code 0
app id 0  exited 
 next min stride  app id3
current 0 start switch to  3
 next min stride  app id2
current 3 start switch to  2
 next min stride  app id1
current 2 start switch to  1
power_5 [10000/140000]
power_5 [20000/140000]
power_5 [30000/140000]
power_5 [40000/140000]
power_5 [50000/140000]
power_5 [60000/140000]
power_5 [70000/140000]
power_5 [80000/140000]
power_5 [90000/140000]
power_5 [100000/140000]
power_5 [110000/140000]
power_5 [120000/140000]
power_5 [130000/140000]
power_5 [140000/140000]
5^140000 = 386471875
Test power_5 OK!
[kernel] Application exited with code 0
app id 1  exited 
 next min stride  app id3
current 1 start switch to  3
Test sleep OK!
[kernel] Application exited with code 0
app id 3  exited 
 next min stride  app id2
current 3 start switch to  2
power_7 [10000/160000]
power_7 [20000/160000]
power_7 [30000/160000]
power_7 [40000/160000]
power_7 [50000/160000]
power_7 [60000/160000]
power_7 [70000/160000]
power_7 [80000/160000]
power_7 [90000/160000]
power_7 [100000/160000]
power_7 [110000/160000]
power_7 [120000/160000]
power_7 [130000/160000]
power_7 [140000/160000]
power_7 [150000/160000]
power_7 [160000/160000]
7^160000 = 667897727
Test power_7 OK!
[kernel] Application exited with code 0
app id 2  exited 
all exited
panicked at 'All applications completed!', src\task\mod.rs:149:13
93
panicked at 'It should shutdown!', src\sbi.rs:45:5

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>地址空间</strong></p>
<p><strong>物理内存</strong></p>
<p>物理内存页式管理</p>
<p>对于物理内存的页式管理而言，我们所要支持的操作是：</p>
<p>分配一个物理页，返回其物理页号；</p>
<p>给定一个物理页号，回收其对应的物理页。</p>
<p>给定一个页号区间进行初始化。</p>
<p>这里用最简单的方式实现</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Allocator {
    a: [u8; MAX_PHYSICAL_PAGES],
    offset: usize,
    total:usize
}

impl Allocator {
    // 给定一个页号区间进行初始化。
    pub fn init(&amp;mut self, l:usize, r:usize) {
        self.offset = l - 1;
        self.total = r - l;
        // let size = r - l;

        //0表示空闲
        for i in 0..self.total {
            self.a[i] = 0;
        }
    }

    // // 给定物理地址 分配一个物理页，返回其物理页号；
    pub fn alloc(&amp;mut self) -&gt; usize {
        //设置一个分配成功标志
        let mut flag = 0;

        //返回分配的物理页号
        let mut result = 0;
        for i in 0..MAX_PHYSICAL_PAGES-1 {
            if self.a[i] == 0 {
                self.a[i] = 1;
                flag = 1;
                result = i;
                return result;
            }
        }
        if flag == 0 {
            panic!(&quot;physical memory depleted!&quot;);
        }
        result
    }

    //回收物理页号为n的物理页
    pub fn dealloc(&amp;mut self, n: usize) {

        let p = n;
        if p &gt;= MAX_PHYSICAL_PAGES {
            panic!(&quot;非法物理页号&quot;)
        }
        self.a[p] = 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>动态内存分配</strong></p>
<p>实现 Trait GlobalAlloc</p>
<p>用写好的库 并把它标记为 #[global_allocator]</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use buddy_system_allocator::LockedHeap;

#[global_allocator]
static DYNAMIC_ALLOCATOR: LockedHeap = LockedHeap::empty();

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>rv39页表</strong></p>
<p><strong>分析页表需要支持的操作</strong></p>
<p>1.新建一个页表(分配一个物理页帧,并把该页帧作为页表的基址)</p>
<p>2.map unmap 为一对va 和 pa 建立映射</p>
<p>3.找到页表项</p>
<p><strong>给定某va建立映射的过程:</strong></p>
<p><strong>1.找到root_table</strong></p>
<p><strong>2.在三级页表中找到二级页表的页表项.根据页表项来找到二级页表的地址</strong></p>
<p>如果页表项未被设置. 则分配一个物理页帧, 并把该物理页帧填写到页表项并设置标记位(即以后能通过此页表项找到二级页表的地址了)</p>
<p>只需填写valid位.因为它指向下一级页表</p>
<p>其中p1_index  p2_index p3_index 分别为 </p>
<p>虚拟地址va的12..21    21 .. 30  30..39 位</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p3_index = page.p3_index();
let p2_index = page.p2_index();
let p1_index = page.p1_index();

let p2_table = if self.root_table.entries[p3_index].is_unused() {
    let frame = alloc_frame().unwrap();
    self.root_table.entries[p3_index].set(frame, EF::VALID);
    let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
    p2_table.zero();
    p2_table
} else {
    let frame = self.root_table.entries[p3_index].frame();
    unsafe { frame.as_kernel_mut() }
};
<span class="boring">}
</span></code></pre></pre>
<p>这里需要一个把页表项中的地址解析出来并当成页表的操作</p>
<p>(pte &gt;&gt; 10 )  &lt;&lt; 12  +  PHYSICAL_MEMORY_OFFSET</p>
<p>页表项右移10位来得到物理页号. 一个物理页帧为4k. 再左移12位来得到物理地址</p>
<p>如果有设置偏移则加上PHYSICAL_MEMORY_OFFSET</p>
<p>这样就得到了页表所在的物理地址</p>
<p>rust写法有两种</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_page_table(&amp;self) -&gt; *mut PageTable {
    ((self.data &gt;&gt; 10) &lt;&lt; 12) as *mut PageTable
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame = self.root_table.entries[p3_index].frame();
pub unsafe fn as_page_table&lt;'a, 'b, T&gt;(&amp;'a self) -&gt; &amp;'b mut T {
    &amp;mut *(    ((self.0).0 + PHYSICAL_MEMORY_OFFSET)   as *mut T  )
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>3.然后就是重复上述操作</strong></p>
<p><strong>在二级页表中找到一级页表的页表项, 根据页表项找到一级页表的地址</strong></p>
<p>如果不存在则分配物理页帧,填写标志</p>
<p><strong>最终在一级页表中找到对应的页表项,把对应的物理页号填写进去就完成了映射</strong></p>
<p><strong>那么我们该填写什么物理页号进去呢?</strong> 这里就比较随意了</p>
<ol>
<li>
<p>可以采用一个固定的偏移 pa = va +  PHYSICAL_MEMORY_OFFSET</p>
</li>
<li>
<p>可以采用之前写好的物理内存分配器分配一个物理页号</p>
</li>
<li>
<p>...</p>
</li>
</ol>
<p>完整版</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_pte_create(&amp;mut self, va:usize) -&gt; Option&lt;&amp;mut PageTableEntry&gt; {
    let page = Page::of_addr(VirtAddr::new(va));
    let p3_index = page.p3_index();
    let p2_index = page.p2_index();
    let p1_index = page.p1_index();
    //找到二级页表
    let p2_table = if self.root_table.entries[p3_index].is_unused() {
        let frame = alloc_frame().unwrap();
        self.root_table.entries[p3_index].set(frame, EF::VALID);
        let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p2_table.zero();
        p2_table
    } else {
        let frame = self.root_table.entries[p3_index].frame();
        unsafe { frame.as_kernel_mut() }
    };
    //找到一级页表
    let p1_table = if p2_table.entries[p2_index].is_unused() {
        let frame = alloc_frame().unwrap();
        p2_table.entries[p2_index].set(frame, EF::VALID);
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table.zero();
        p1_table
    } else {
        let frame = p2_table.entries[p2_index].frame();
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table
    };
    //在一级页表中找到对应页表项
    let p1_entry = Some (&amp;mut p1_table.entries[p1_index]);
    p1_entry
}
<span class="boring">}
</span></code></pre></pre>
<p>建立映射</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map(&amp;mut self, va:usize, frame: Frame, ptflags: PageTableFlags) {
    let pte = self.find_pte_create(va).unwrap();
    if !pte.is_unused(){
        println!(&quot;pte {:?} already mapped&quot;, pte);
    }
    pte.set(frame, ptflags);
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
}

pub fn unmap(&amp;mut self, va:usize) {
    let pte = self.find_pte(va).unwrap();
    pte.set_unused();
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
    MapperFlush::flush(page);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>debug</strong></p>
<p>pa = va - 0xffffffff40000000</p>
<p>其中p1_index p2_index p3_index 分别为 虚拟地址va的  12..21  和 21..30 和 30..39 位</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>satp :0x8000000000080a2b                 对应物理地址:0x80a2b000
p3_index为511                       第511项在物理地址:0x80a2bff8
0x80a2bff8处内存显示 0x000000002028b0c5(页表项)
(0x000000002028b0c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2c000
                                             物理地址 = 0x80a2c000


得到二级页表虚拟地址 0xffffffffc0a2c000   对应物理地址:0x80a2c000
p2_index为1                            第1项在物理地址:0x80a2c008
0x80a2c008处内存显示 0x000000002028b4c5(页表项)
(0x000000002028b4c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2d000
                                             物理地址 = 0x80a2d000


得到一级页表虚拟地址 0xffffffffc0a2d000   对应物理地址:0x80a2d000
p1_index为2                            第2项在物理地址:0x80a2d010
0x80a2d010处内存显示 0x00000000200808cf(页表项)
(0x00000000200808cf &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0202000
                                             物理地址 = 0x80202000
<span class="boring">}
</span></code></pre></pre>
<p>gdb显示物理内存  maintenance packet Qqemu.PhyMemMode:1</p>
<p>x/10xg $addr  以64位一个单元来显示某地址内存中内容.</p>
<p><strong>页表建立过程中有可能出错的地方:</strong></p>
<p>1.指向下一级页表的页表项标志位设置错! (应严格按照riscv手册中指示的指向下一级页表的标志位设置方式...否则该页就会被当初普通页)..这时debug会发现给定va手动算总能在最后找到相应的物理页帧! 但是程序没法运行</p>
<p><strong>rust小程序辅助计算页表相关信息</strong></p>
<p>假设 pa = va - 0xffffffff40000000</p>
<pre><pre class="playground"><code class="language-rust">use bit_field::*;

pub fn next_level(pte:usize)  -&gt; usize {
    let next_level_va = ((pte &gt;&gt;10)&lt;&lt;12) + 0xffffffff40000000 as usize;
    println!(&quot;next level va 0x{:x}&quot;, next_level_va);
    println!(&quot;next level pa level 0x{:x}&quot;, next_level_va - 0xffffffff40000000 as usize);

    next_level_va
}

pub fn va_to_pa(va:usize){
    println!(&quot;pa {:x}&quot;, va - 0xffffffff40000000);
}

pub fn page_index(va:usize){
    println!(&quot;p1_index {:?}  p2_index {:?}  p3_index {:?}&quot;, va.get_bits(12..21), va.get_bits(21..30), va.get_bits(30..39) );
}

pub fn p1_entry(va:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p2_entry = (satp + 8*va.get_bits(12..21)) as usize ;
    println!(&quot;p1_entry {:x}&quot;, p1_entry);
    p2_entry
}

pub fn p2_entry(va:usize, p1_table:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p2_entry = (p1_table + 8*va.get_bits(21..30)) as usize ;
    println!(&quot;p2_entry {:x}&quot;, p2_entry);

    p2_entry
}


pub fn p3_entry(va:usize: p2_table:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p3_entry = (p2_table + 8*va.get_bits(30..39)) as usize ;
    println!(&quot;p3_entry {:x}&quot;, p3_entry);

    p3_entry
}

fn main() {
    let va = 0xffffffffc02058de;
    page_index(va);
    

    p1_entry = p1_entry(0xffffffffc02058de);
    p2_table = next_level(p1_entry);

    p2_entry = p2_entry(0xffffffffc02058de, p2_table);
    p3_table = next_level(p2_entry);

    p3_entry = p1_entry(0xffffffffc02058de, p3_table);

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch4</strong></p>
<p><strong>实现mmap</strong></p>
<p>很简单...包装一下memory_set中insert_framed_area...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_mmap(start: usize, len: usize, port: usize) -&gt; isize {
    let mut permission = MapPermission::U;
    if port &amp; 0x1 != 0 {
        permission |= MapPermission::R;
    }
    if port &amp; 0x2 != 0 {
        permission |= MapPermission::W;
    }
    if port &amp; 0x4 != 0 {
        permission |= MapPermission::X;
    }

    let end = VirtAddr::from(VirtAddr(start + len));
    match insert_framed_area(start.into(), end, permission) {
        Ok(_) =&gt; (end.0 - start) as isize,
        Err(_) =&gt; -1,
    }
}

pub fn insert_framed_area(start: VirtAddr, end: VirtAddr, permission: MapPermission,){
    TASK_MANAGER.mmap(start, end, permission);
}

fn mmap(&amp;self, start: VirtAddr, end: VirtAddr,permission: MapPermission ){
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.tasks[current].memory_set.insert_framed_area(start, end, permission);
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>实现sys_spawn</strong></p>
<p><strong>由于tutori中没有实现内核线程(进程). 所以只能从当前进程中fork出来.再执行.</strong></p>
<p>拿到应用程序名字 -&gt; 从app_name获取应用程序地址 -&gt; get_app_data_by_name 接口中找到对应的ELF数据</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_spawn(path: *const u8) -&gt; isize {
    let path = translated_str(current_user_token(), path);
    if let Some(data) = get_app_data_by_name(path.as_str()) {
        let new_task = current_task().unwrap().fork();
        new_task.exec(data);
        let new_pid = new_task.pid.0;
        add_task(new_task);
        new_pid as isize
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>整理之前代码</strong></p>
<p>把用户程序和os放一个文件夹下管理. 配置vscode. 编写python脚本</p>
<p>在主目录下运行python app_build.py 来生成用户程序,链接脚本</p>
<p><strong>app_build.py</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import os
os.system('cd user &amp;&amp; cargo clean')
os.system('cd user &amp;&amp; python ./build.py')
os.system('cd user &amp;&amp; python ./objdump.py')
os.system('cd user &amp;&amp; python ./linker.py')
<span class="boring">}
</span></code></pre></pre>
<p><strong>build.py</strong></p>
<pre><code>import os
os.system('cd os &amp;&amp; cargo build')
os.system('cd os &amp;&amp; rust-objcopy target/riscv64gc-unknown-none-elf/debug/os --strip-all -O binary target/riscv64gc-unknown-none-elf/debug/kernel.bin')
</code></pre>
<p>配合vscode</p>
<p><strong>launch.json</strong></p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;launch&quot;,
            &quot;type&quot;: &quot;cppvsdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;qemu-system-riscv64.exe&quot;,
            &quot;args&quot;: [
                &quot;-machine&quot;,
                &quot;virt&quot;,
                &quot;-nographic&quot;,
                &quot;-no-reboot&quot;,
                &quot;-bios&quot;,
                &quot;default&quot;,
                &quot;-device&quot;,
                &quot;loader,file=${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/kernel.bin,addr=0x80200000&quot;,
            ],
            &quot;preLaunchTask&quot;: &quot;python&quot;,
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
        },        
        {
            &quot;name&quot;: &quot;launch-qemu&quot;,
            &quot;type&quot;: &quot;cppvsdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;qemu-system-riscv64.exe&quot;,
            &quot;args&quot;: [
                &quot;-machine&quot;,
                &quot;virt&quot;,
                &quot;-nographic&quot;,
                &quot;-no-reboot&quot;,
                &quot;-bios&quot;,
                &quot;default&quot;,
                &quot;-device&quot;,
                &quot;loader,file=${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/kernel.bin,addr=0x80200000&quot;,
                &quot;-s&quot;,
                &quot;-S&quot;
            ],
            &quot;preLaunchTask&quot;: &quot;copy&quot;,
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,
        },
        {
            &quot;name&quot;: &quot;qemu&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;miDebuggerServerAddress&quot;: &quot;127.0.0.1:1234&quot;,
            &quot;miDebuggerPath&quot;: &quot;D:/riscv64-unknown-elf-gcc-w64/bin/riscv64-unknown-elf-gdb.exe&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/os&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;logging&quot;: {
                &quot;engineLogging&quot;: false
            },
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Add gdbinit&quot;,
                    &quot;text&quot;: &quot;-interpreter-exec console \&quot;source -v D:/os/os/.gdbinit\&quot;&quot;
                }
            ]
        },

    ]
}
</code></pre>
<p><strong>tasks.json</strong></p>
<pre><code class="language-json">{
	&quot;version&quot;: &quot;2.0.0&quot;,
	&quot;tasks&quot;: [
		{
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;python&quot;,
			&quot;command&quot;:&quot;python ./build.py&quot;,
		},
        {
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;build&quot;,
			&quot;command&quot;:&quot;cargo build&quot;
		},
		{
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;copy&quot;,
			&quot;command&quot;:&quot;rust-objcopy target/riscv64gc-unknown-none-elf/debug/os --strip-all -O binary target/riscv64gc-unknown-none-elf/debug/kernel.bin&quot;,
			&quot;dependsOn&quot;:[&quot;build&quot;]
		}
	]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch6</strong></p>
<p>设计mail. 现在需要一个所有进程共享的数据结构.参考KERNEL_STACK.设置一个全局的数据结构来来管理邮箱</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mails(pub VecDeque&lt;Vec&lt;u8&gt;&gt;);

在没有多核的情况下.不需要提供互斥访问.所以不需要用类似Arc&lt;Mutex&lt;T&gt;&gt;的方法

和KernelStack一样把Mails放在TaskControlBlock中

<span class="boring">}
</span></code></pre></pre>
<p>读</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn readable(&amp;self) -&gt; bool {
    self.0.len() &gt; 0
}

pub fn read(&amp;mut self, buf: UserBuffer) -&gt; usize {
    let mut buf_iter = buf.into_iter();
    let mut read_size = 0usize;
    let mail = self.0.pop_front().unwrap();
    for c in mail {
        if let Some(byte_ref) = buf_iter.next() {
            unsafe { *byte_ref = c; }
            read_size += 1;
        } else {
            break;
        }
    }
    read_size
}
<span class="boring">}
</span></code></pre></pre>
<p>写</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn writable(&amp;self) -&gt; bool {
    self.0.len() &lt; MAX_MAILS_NUM
}

pub fn write(&amp;mut self, buf: UserBuffer) -&gt; usize {
    let mut write_size = 0usize;
    let mut mail: Vec&lt;u8&gt; = Vec::new();
    for c in buf {
        unsafe{ mail.push(*c); }
        write_size += 1;
    }
    self.0.push_back(mail);
    write_size
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ch7</strong></p>
<p><strong>文件系统</strong></p>
<p>文件系统的几个组要部分:</p>
<p>1.磁盘上的文件系统</p>
<p>2.磁盘块,在buffer中的磁盘块</p>
<p>3.内存中的buffer</p>
<p>(读写文件系统: 如果磁盘块在内存buffer中,就是直接读写内存, 如果磁盘块不在buffer中则需调用驱动直接读写磁盘并填入buffer中.)</p>
<p>4.os上的具体文件系统</p>
<p>5.os中的虚拟文件系统. 包装具体的文件系统</p>
<p>6.文件系统驱动.  可采用ramdisk.用内存中的一段区间来模拟磁盘.</p>
<p><strong>sys_open</strong></p>
<p>调用一下open_file.设置标记位.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_open(path: *const u8, flags: u32) -&gt; isize {
    let task = current_task().unwrap();
    let token = current_user_token();
    let path = translated_str(token, path);
    if let Some(inode) = open_file(
        path.as_str(),
        OpenFlags::from_bits(flags).unwrap()
    ) {
        let mut inner = task.acquire_inner_lock();
        let fd = inner.alloc_fd();
        inner.fd_table[fd] = Some(inode);
        fd as isize
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>linkat</strong></p>
<p>基本和create一样,只不过create需要alloc一个inode.这里需要找到inode</p>
<p>调用find_inode_id找到inode_id.</p>
<p>接下来参考Inode::create()中的写法. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.modify_disk_inode(|root_inode| {
    // append file in the dirent
    let file_count = (root_inode.size as usize) / DIRENT_SZ;
    let new_size = (file_count + 1) * DIRENT_SZ;
    // increase size
    self.increase_size(new_size as u32, root_inode, &amp;mut fs);
    // write dirent
    let dirent = DirEntry::new(name, new_inode_id);
    root_inode.write_at(
        file_count * DIRENT_SZ,
        dirent.as_bytes(),
        &amp;self.block_device,
    );
});
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.linkat(|root_inode| {
    let file_count = (root_inode.size as usize) / DIRENT_SZ;
    let new_size = (file_count + 1) * DIRENT_SZ;
    self.increase_size(new_size as u32, root_inode, &amp;mut fs);
    let dirent = DirEntry::new(new_name, inode_id);
    root_inode.write_at(
        file_count * DIRENT_SZ,
        dirent.as_bytes(),
        &amp;self.block_device,
    );
});
<span class="boring">}
</span></code></pre></pre>
<p><strong>unlinkat</strong></p>
<p>和ls很像.ls需要列举目录下所有文件. unlinkat也需要遍历目录来找到指定文件</p>
<p>ls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ls(&amp;self) -&gt; Vec&lt;String&gt; {
    let _fs_lock = self.fs.lock();
    self.read_disk_inode(|disk_inode| {
        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
        let mut v: Vec&lt;String&gt; = Vec::new();
        for i in 0..file_count {
            let mut dirent = DirEntry::empty();
            assert_eq!(
                disk_inode.read_at(
                    i * DIRENT_SZ,
                    dirent.as_bytes_mut(),
                    &amp;self.block_device,
                ),
                DIRENT_SZ,
            );
            if dirent.inode_number() != 0 {
                v.push(String::from(dirent.name()));
            }
        }
        v
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>unlinkat</p>
<p>如果文件名==name,则把当前文件写空.来实现unlink....</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn unlinkat(&amp;self, name: &amp;str) -&gt; isize {
    let file_remove = |disk_inode: &amp;mut DiskInode| {
        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
        let mut dirent = DirEntry::empty();
        for i in 0..file_count {

            disk_inode.read_at(DIRENT_SZ * i, dirent.as_bytes_mut(), &amp;self.block_device);

            if dirent.name() == name {
                disk_inode.write_at(
                    DIRENT_SZ * i,
                    DirEntry::empty().as_bytes_mut(),
                    &amp;self.block_device,
                );
                return 0;
            }
        }
        -1
    };
    self.modify_disk_inode(file_remove)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>整理</strong></p>
<p>user-shell</p>
<p>我们首先要能够通过键盘向终端程序中输入。也就是说，我们要实现一个用户程序，它能够接受键盘的输入，并将键盘输入的字符显示在屏幕上</p>
<p>这个用户程序需要的功能是：接受键盘输入（可以被称为“标准输入”）的一个字符。</p>
<p>需要 sys_read    以及用户程序能调用的getchar()</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// usr/rust/src/syscall.rs

enum SyscallId {
    Read = 63,
}

pub fn sys_read(fd: usize, base: *const u8, len: usize) -&gt; i64 {
    sys_call(SyscallId::Read, fd, base as usize, len, 0)
}

包装下sys_read

pub fn getchar() -&gt; u8 {
    let mut c = [0u8; 1];
    read(STDIN, &amp;mut c);
    c[0]
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>有了getchar()支持 我们就可以用一个loop来循环获得输入</strong></p>
<p>这个输入存在哪里?</p>
<p>这时就需要用户程序的动态内存分配. 和os内核中使用的一样,使用已经写好的库buddy_system_allocator</p>
<p>这样我们就可以用String数据结构来存获得的输入</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut line: String = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><strong>在有了上面的支持后,需要做的就是匹配输入,然后调用exec来运行不同的程序</strong></p>
<p>采用match来匹配</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() -&gt; i32 {
    println!(&quot;Rust user shell&quot;);
    let mut line: String = String::new();
    print!(&quot;&gt;&gt; &quot;);
    loop {
        let c = getchar();
        match c {

        }
    }
}
</code></pre></pre>
<table><tr><td bgcolor=#EFF5FF>
接下来要做的就是使用exec("用户程序名")来运行不同程序
<p>这要求exec能够接受一个字符串,并载入指定应用程序并运行</p>
<p>由于系统调用不支持传入整个字符串.只能传入字符串的地址,但是这个地址又是在用户程序的页表下的(采用了双页表设计,内核空间无法访问用户空间,如果是单页表下内核和用户使用同一个页表,可以直接获得字符串).所以需要在内核中获取用户程序的satp,并且手动查页表来获取字符串.</p>
<p>获取应用名之后,如何在内核空间载入app_data呢? 相比之前这里又多了一个类似TaskControlBlock 以及 Kernel_stack的数据结构APP_NAMES,里面保存了应用名字和数据的信息</p>
</td></tr></table>
<p><strong>整个sys_exec大概包括几个主要函数</strong></p>
<p><strong>1:获取当前用户页表基地址</strong></p>
<p><strong>2:手动查该页表获取字符串</strong></p>
<p><strong>3:用字符串找到应用数据,并载入运行</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_exec(path: *const u8) -&gt; isize {
    let token = current_user_token();
    let path = translated_str(token, path);
    if let Some(data) = get_app_data_by_name(path.as_str()) {
        let task = current_task().unwrap();
        task.exec(data);
        0
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>app linker 编写</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_app_names:
    .string &quot;exit&quot;
    .string &quot;user_shell&quot;
<span class="boring">}
</span></code></pre></pre>
<p>start = _app_names. 直到读取到'\0' (有待确认这里是否是编译器自动加上了'\0')  之后用类似memcpy保存到&amp;str中</p>
<p>_app_names按顺序保存在了一个vec中, 之后就可以用id来得到应用数据了</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_NAMES: Vec&lt;&amp;'static str&gt; = {
        let num_app = get_num_app();
        extern &quot;C&quot; { fn _app_names(); }
        let mut start = _app_names as usize as *const u8;
        let mut v = Vec::new();
        unsafe {
            for _ in 0..num_app {
                let mut end = start;
                while end.read_volatile() != '\0' as u8 {
                    end = end.add(1);
                }
                let slice = core::slice::from_raw_parts(start, end as usize - start as usize);
                let str = core::str::from_utf8(slice).unwrap();
                v.push(str);
                start = end.add(1);
            }
        }
        v
    };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>虚拟化</strong></p>
<p>没有头绪.找了一篇有代码的论文看看先.</p>
<p><a href="https://arxiv.org/pdf/2103.14951">A First Look at RISC-V Virtualization from anEmbedded Systems Perspective</a></p>
<p>论文仓库:<a href="https://github.com/mit-pdos/RVirt">https://github.com/mit-pdos/RVirt</a></p>
<p><strong>What Needs to be Virtualized?</strong></p>
<p>1.Supervisor architectural state (i.e. CSRs)</p>
<p>2.Memory</p>
<p>3.I/O and Interrupts</p>
<p><strong>Virtualizing Memory</strong></p>
<p>Two-Level Address Translation</p>
<p>-Original virtual addresses translated to guest physical addresses by VS-level page table</p>
<p>-Guest physical addresses translated to machine physical addresses by HS-level page table</p>
<p>Same page-table entry format as S-mode</p>
<p>Same page-table layouts as S-mode (Sv32, 39, 48, ...)</p>
<p><strong>Virtualizing I/O and Interrupts</strong></p>
<p>Software &amp; Timer interrupts use SBI (=&gt; trivial)</p>
<p>Use two-level paging scheme to trap MMIO accesses </p>
<p>-Sufficient to emulate PLIC and other MMIO devices</p>
<p>Could avoid extra traps into hypervisor with virtualization</p>
<p>-aware PLIC-Platform issue, outside scope of hypervisor ISA</p>
<p>Need I/O MMU to initiate DMAs without trap into hypervisor</p>
<p>-Platform issue, outside scope of hypervisor ISA</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>虚拟化层次</strong>
<img src="camp-daliy/./../Virtualization.png" alt="avatar" /></p>
<p>linux namespace cgroup</p>
<p>namesapce: 安全隔离  (MNT, UTS, IPC, PID, NET, User, Cgroup)</p>
<p>cgroup: 性能隔离 (task, cgroup, subsystem, hierarchy)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust笔记"><a class="header" href="#rust笔记">rust笔记</a></h1>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<h4 id="动态内存分配"><a class="header" href="#动态内存分配">动态内存分配</a></h4>
<blockquote>
<p>1.在堆的某处找到一块足够大的空位,把它标记为已使用,并返回一个表示该位置地址的指针.
2.跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的</p>
</blockquote>
<h3 id="所有权规则"><a class="header" href="#所有权规则">所有权规则</a></h3>
<blockquote>
<ol>
<li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<h3 id="移动和克隆"><a class="header" href="#移动和克隆">移动和克隆</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1; ---- 变量移动到了s2中, s1失效
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();  ---- 将堆中的'helle'复制了一份, s1,s2分别指向了不同的堆空间,
                           但是值都为'hello',释放的时候也被当成两个独立的资源
<span class="boring">}
</span></code></pre></pre>
<p>Rust 永远也不会自动创建数据的 “深拷贝”,也就是clone</p>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<h3 id="引用"><a class="header" href="#引用">引用 &amp;</a></h3>
<p>它们允许你使用值但不获取其所有权。</p>
<p>可变引用有一个很大的限制：在同一时间只能有一个对某一特定数据的可变引用</p>
<p>&amp;s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。</p>
<p>变量允许拥有多个可变引用，只是不能同时拥有：
在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
引用必须总是有效的。</p>
<p>我们希望能够在程序的一个位置指定某些代码，并只在程序的某处实际需要结果的时候执行这些代码。这正是闭包的用武之地！</p>
<p>生命周期避免了悬垂引用</p>
<p>被引用的对象比它的引用者存在的时间更短可能造成悬垂引用</p>
<h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//实现了FnMut
let mut x = 5;
{
    let mut square_x = || x *= x;
    square_x();
}
assert_eq!(x, 25);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;hello&quot;;

//x的所有权交给了闭包 equal_to_x
let equal_to_x = move |z| z == x;
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>Fn</code>类型闭包</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let square = |x| x * x;
assert_eq!(square(5), 25);

//使用Fn参数  
fn call_with_one&lt;F&gt;(func: F) -&gt; usize
    where F: Fn(usize) -&gt; usize {
    func(1)
}
let double = |x| x * 2;
assert_eq!(call_with_one(double), 2);
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>FnMut</code>类型闭包</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
{
    let mut square_x = || x *= x;
    square_x();
}
assert_eq!(x, 25);

//使用FnMut参数
fn do_twice&lt;F&gt;(mut func: F)
    where F: FnMut()
{
    func();
    func();
}

let mut x: usize = 1;
{
    let add_two_to_x = || x += 2;
    do_twice(add_two_to_x);
}
assert_eq!(x, 5);
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>FnOnce</code>类型闭包</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//使用FnONce参数
fn consume_with_relish&lt;F&gt;(func: F)
    where F: FnOnce() -&gt; String
{
    // `func` consumes its captured variables, so it cannot be run more
    // than once.
    println!(&quot;Consumed: {}&quot;, func());
///
    println!(&quot;Delicious!&quot;);
///
    // Attempting to invoke `func()` again will throw a `use of moved
    // value` error for `func`.
}
///
let x = String::from(&quot;x&quot;);
let consume_and_return_x = move || x;
consume_with_relish(consume_and_return_x);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rust学习记录"><a class="header" href="#-rust学习记录">🚧 rust学习记录</a></h1>
<h2 id="这里主要记录一些c实现的os一些常用数据结构已经操作在rust中怎么实现"><a class="header" href="#这里主要记录一些c实现的os一些常用数据结构已经操作在rust中怎么实现">这里主要记录一些c实现的os一些常用数据结构已经操作在rust中怎么实现</a></h2>
<p><strong>看一个c语言例子</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>以下是rust实现</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-foo"><a class="header" href="#-foo">🚧 foo</a></h1>
<p><strong>记录一些新技能</strong></p>
<p><strong>docker</strong>
在配置github+gitpod中学习了docker的基本用法包括image生成.container使用</p>
<p><br/> </br></p>
<p><strong>获取基础镜像</strong></p>
<p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像</p>
<pre><code class="language-shell">$ docker pull ubuntu
</code></pre>
<p><strong>启动容器</strong></p>
<pre><code>$ docker run -it ubuntu /bin/bash
</code></pre>
<p><strong>安装环境(略)</strong></p>
<p><strong>推送镜像到Docker Hub</strong></p>
<p>需要在docker hub上注册账户,创建仓库</p>
<p>登入docker</p>
<pre><code class="language-shell">$ docker login 
</code></pre>
<p>修改标签</p>
<pre><code class="language-shell">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
</code></pre>
<p>推送</p>
<pre><code class="language-shell">$ docker push username/repository:[tag]
</code></pre>
<p><strong>查看本地容器,镜像</strong></p>
<pre><code class="language-shell">$ docker images
$ docker ps -a
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

                <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
