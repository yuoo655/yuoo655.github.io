<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="compiler/2021-12-31.html">ğŸš§ ä»é›¶å®ç°riscvç¼–è¯‘å™¨ç³»åˆ—</a></li><li class="chapter-item expanded affix "><a href="scheduler/2021-1-4.html">ğŸš§ è¿›ç¨‹ã€çº¿ç¨‹ä¸åç¨‹</a></li><li class="chapter-item expanded affix "><a href="lkm/2021-12-29.html">ğŸš§ å†…æ ¸å¯åŠ è½½æ¨¡å—ç³»åˆ—</a></li><li class="chapter-item expanded affix "><a href="daliy/2021-10-25.html">ğŸš§ upcall</a></li><li class="chapter-item expanded affix "><a href="daliy/2021-10-20.html">ğŸš§ Futures in Rust</a></li><li class="chapter-item expanded affix "><a href="index.html">ğŸš§ 2021-os-camp</a></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">1.</strong> ğŸš§ tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="camp-daliy/7-6.html"><strong aria-hidden="true">1.1.</strong> 7.6 æŒ‡å®šç¨‹åºå†…å­˜å¸ƒå±€</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-7.html"><strong aria-hidden="true">1.2.</strong> 7.7 é“¾æ¥è„šæœ¬ç¼–å†™</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-8.html"><strong aria-hidden="true">1.3.</strong> 7.8 å®ç°å½©è‰²è¾“å‡º</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-9.html"><strong aria-hidden="true">1.4.</strong> 7.9 intelæ‰‹å†Œä¸­çš„å¤šæ ¸å¯åŠ¨</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-10.html"><strong aria-hidden="true">1.5.</strong> 7.10 å¤šæ ¸æ”¯æŒ</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-11.html"><strong aria-hidden="true">1.6.</strong> 7.11 ä¸­æ–­æœºåˆ¶æ¦‚å†µ</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-13.html"><strong aria-hidden="true">1.7.</strong> 7.13 ä¸­æ–­è¯¦ç»†å®ç°</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-14.html"><strong aria-hidden="true">1.8.</strong> 7.14 è¿è¡Œç”¨æˆ·ç¨‹åº</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-15.html"><strong aria-hidden="true">1.9.</strong> 7.15 è¿è¡Œç”¨æˆ·ç¨‹åºæ€»ç»“</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-16.html"><strong aria-hidden="true">1.10.</strong> 7.16 ç”¨æˆ·ç¨‹åºåˆ‡æ¢</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-17.html"><strong aria-hidden="true">1.11.</strong> 7.17 stride è°ƒåº¦ç®—æ³•</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-18.html"><strong aria-hidden="true">1.12.</strong> 7.18 ç‰©ç†å†…å­˜åˆ†é…</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-19.html"><strong aria-hidden="true">1.13.</strong> 7.19 é¡µè¡¨</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-20.html"><strong aria-hidden="true">1.14.</strong> 7.20 debug</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-21.html"><strong aria-hidden="true">1.15.</strong> 7.21</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-23.html"><strong aria-hidden="true">1.16.</strong> 7.23</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-24.html"><strong aria-hidden="true">1.17.</strong> 7.24 æ–‡ä»¶ç³»ç»Ÿ</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-25.html"><strong aria-hidden="true">1.18.</strong> 7.25</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-26.html"><strong aria-hidden="true">1.19.</strong> 7.26</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-27.html"><strong aria-hidden="true">1.20.</strong> 7.27</a></li></ol></li><li class="chapter-item expanded "><a href="async.html"><strong aria-hidden="true">2.</strong> ğŸš§ ç¬¬äºŒé˜¶æ®µå¼‚æ­¥os</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="camp-daliy/8-1~8-9.html"><strong aria-hidden="true">2.1.</strong> 8.1</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-9.html"><strong aria-hidden="true">2.2.</strong> 8.9</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-10.html"><strong aria-hidden="true">2.3.</strong> 8.10</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-11.html"><strong aria-hidden="true">2.4.</strong> 8.11</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-12.html"><strong aria-hidden="true">2.5.</strong> 8.12</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-13.html"><strong aria-hidden="true">2.6.</strong> 8.13</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-14.html"><strong aria-hidden="true">2.7.</strong> 8.14</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-15.html"><strong aria-hidden="true">2.8.</strong> 8.15</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-16.html"><strong aria-hidden="true">2.9.</strong> 8.16</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-17.html"><strong aria-hidden="true">2.10.</strong> 8.17</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-20.html"><strong aria-hidden="true">2.11.</strong> 8.20</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-21.html"><strong aria-hidden="true">2.12.</strong> 8.21</a></li><li class="chapter-item expanded "><a href="camp-daliy/8-29.html"><strong aria-hidden="true">2.13.</strong> 8.29</a></li><li class="chapter-item expanded "><a href="camp-daliy/9-16.html"><strong aria-hidden="true">2.14.</strong> 9.16</a></li><li class="chapter-item expanded "><a href="ecallè¯­ä¹‰æ‹“å±•.html"><strong aria-hidden="true">2.15.</strong> ecall</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">3.</strong> ğŸš§ rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="camp-daliy/7-2.html"><strong aria-hidden="true">3.1.</strong> 7.2</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-3.html"><strong aria-hidden="true">3.2.</strong> 7.3</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-4.html"><strong aria-hidden="true">3.3.</strong> 7.4</a></li><li class="chapter-item expanded "><a href="camp-daliy/7-5.html"><strong aria-hidden="true">3.4.</strong> 7.5</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">4.</strong> ğŸš§ c2rust</a></li><li class="chapter-item expanded "><a href="foo.html"><strong aria-hidden="true">5.</strong> ğŸš§ foo</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-ä»é›¶å®ç°riscvç¼–è¯‘å™¨ç³»åˆ—"><a class="header" href="#-ä»é›¶å®ç°riscvç¼–è¯‘å™¨ç³»åˆ—">ğŸš§ ä»é›¶å®ç°riscvç¼–è¯‘å™¨ç³»åˆ—</a></h1>
<h1 id="ç¼–è¯‘å™¨ç»„æˆ"><a class="header" href="#ç¼–è¯‘å™¨ç»„æˆ">ç¼–è¯‘å™¨ç»„æˆ</a></h1>
<p>æºç¨‹åº --&gt;   å‰ç«¯--&gt;ä¸­é—´è¡¨ç¤º--&gt;åç«¯   --&gt;ç›®æ ‡ç¨‹åº</p>
<p>å‰ç«¯: é¢„å¤„ç†, è¯æ³•åˆ†æ, è¯­æ³•åˆ†æ              (ç›®æ ‡æœºå™¨æ— å…³)</p>
<p>ä¸­é—´è¡¨ç¤º: æŠ½è±¡è¯­æ³•æ ‘, ä¸­é—´ä»£ç å½¢å¼, ä¸­é—´è¡¨ç¤ºä¼˜åŒ–</p>
<p>åç«¯: ç›®æ ‡æœºå™¨æè¿°, æŒ‡ä»¤é€‰æ‹©, æŒ‡ä»¤è°ƒåº¦, å¯„å­˜å™¨åˆ†é…, æ±‡ç¼–ä»£ç ç”Ÿæˆ (ç›®æ ‡æœºå™¨æœ‰å…³)</p>
<p>å‰ç«¯è¯­è¨€(c, c++, go, rust)</p>
<p>åç«¯ç›®æ ‡æœºå™¨(riscv, x86, arm)</p>
<p>æ±‡ç¼–å™¨, é“¾æ¥å™¨, è°ƒè¯•å™¨, è¿è¡Œåº“, ç›®æ ‡æ–‡ä»¶åˆ†æå·¥å…·ç­‰ä¸€ç³»åˆ—ç¨‹åº,ç»„æˆGUNå·¥å…·é“¾</p>
<p>gccæµç¨‹</p>
<p>hello.c -&gt; hello.i -&gt;è¯æ³•/è¯­æ³•åˆ†æ -&gt; ASTç”Ÿæˆ(hello.c.t(tree)) </p>
<p>-&gt; IRç”Ÿæˆ -&gt; IRä¼˜åŒ–(hello.c.*i(pa)) -&gt; RTLç”Ÿæˆ(hello.c.*i(tl)) </p>
<p>-&gt; RTLä¼˜åŒ– -&gt;æ±‡ç¼–ä»£ç ç”Ÿæˆ(hello.s)</p>
<p>è¯­æ³•åˆ†æçš„ä»»åŠ¡æ˜¯åˆ¤æ–­è¯æ³•åˆ†æç”Ÿæˆçš„tokenæ˜¯å¦æ˜¯ä¸€ä¸ªç¬¦åˆç¼–ç¨‹è¯­è¨€è¯­æ³•çš„å¥å­gccä¸­c_parserå®šä¹‰äº†cè¯­è¨€çš„è¯­æ³•ç»“æ„,é€šè¿‡c_parse*å‡½æ•°è¿›è¡Œè¯­æ³•åˆ†æ.</p>
<p>è¯­æ³•åˆ†æè¿‡ç¨‹</p>
<p>è¯­æ³•åˆ†æé¦–å…ˆä¼šè°ƒç”¨c_parse_initè¿›è¡Œåˆå§‹åŒ–, ç„¶åè°ƒç”¨c_parse_fileå¯¹è¯ç¬¦è¿›è¡Œåˆ¤æ–­å¹¶åˆ†æç¼–è¯‘åˆ¶å¯¼ç±»å‹,æ¥ç€è°ƒç”¨c_parser_translation_unitæ¥è¿›è¡Œè¯­æ³•æ¨å¯¼, æ¨å¯¼è¿‡ç¨‹ä¸­è°ƒç”¨c_parser_external_declarationæ¥åˆ¤æ–­tokenç±»å‹æ˜¯å¦æ­£ç¡®, å¹¶é»˜è®¤ä½¿ç”¨c_parser_declaration_or_fndefæ¥å¯¹tokenå£°æ˜è¿›è¡Œæ­£ç¡®æ€§æ£€æŸ¥.</p>
<p>åˆå§‹åŒ–-&gt;è½½å…¥token-&gt;è¯­æ³•æ¨å¯¼-&gt;åˆ¤æ–­tokenç±»å‹-&gt;å£°æ˜æ£€æŸ¥</p>
<p>æºç¨‹åº -&gt; è¯æ³•åˆ†æ(c_token) -&gt;(c_lex_one_token) tokens -&gt;(c_parser_peek_token)-&gt;è¯­æ³•åˆ†æ(c_parse) -&gt; è¯­æ³•åˆ†ææ ‘ç”Ÿæˆ</p>
<p>c_parser_declaration_or_fndefå¯¹tokenæµå¤„ç†å®Œæˆä»¥å,c-parser.cå¯¹å¤„ç†åçš„c_parserè¿›è¡Œåˆ†ç±»å¹¶æ„å»ºè¯­æ³•åˆ†ææ ‘</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-è¿›ç¨‹çº¿ç¨‹ä¸åç¨‹"><a class="header" href="#-è¿›ç¨‹çº¿ç¨‹ä¸åç¨‹">ğŸš§ è¿›ç¨‹ã€çº¿ç¨‹ä¸åç¨‹</a></h1>
<h2 id="ä»»åŠ¡ç®¡ç†è¿›ç¨‹çº¿ç¨‹ä¸åç¨‹"><a class="header" href="#ä»»åŠ¡ç®¡ç†è¿›ç¨‹çº¿ç¨‹ä¸åç¨‹">ä»»åŠ¡ç®¡ç†ï¼šè¿›ç¨‹ã€çº¿ç¨‹ä¸åç¨‹</a></h2>
<ul>
<li>è¿›ç¨‹ï¼šæ¯ä¸ªè¿›ç¨‹æœ‰ç‹¬ç«‹çš„åœ°å€ç©ºé—´ï¼Œå› æ­¤æœ‰é¡µè¡¨åˆ‡æ¢å¼€é”€ï¼›KPTI(kernel pagetable isolation)ä¸‹ï¼Œå†…æ ¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è¿›ç¨‹ï¼Œè¿˜å­˜åœ¨å¤šä¸ªç”¨æˆ·è¿›ç¨‹ã€‚åœ¨å¼‚æ­¥æ“ä½œç³»ç»Ÿä¸­ï¼Œæ“ä½œç³»ç»Ÿå†…æ ¸è¢«è§†ä¸ºä¸€ä¸ªç‹¬ç«‹çš„è¿›ç¨‹ï¼Œæœ‰è‡ªå·±çš„ç‹¬ç«‹çš„é¡µè¡¨ï¼›ç³»ç»Ÿè°ƒç”¨è¿‡ç¨‹ä¼šå˜æˆä¸€ç§ç‰¹æ®Šå’Œä¼˜åŒ–çš„è¿›ç¨‹åˆ‡æ¢ã€‚
<ul>
<li>ç±»ä¼¼äºä¼ ç»Ÿçš„æ“ä½œç³»ç»Ÿä¸­è¿›ç¨‹åˆ‡æ¢ä»£ç æ˜¯åœ¨ä¸¤ä¸ªè¿›ç¨‹ä¸­å…±äº«çš„ï¼ŒæŠŠå†…æ ¸è§†ä¸ºç‹¬ç«‹è¿›ç¨‹åï¼Œç³»ç»Ÿè°ƒç”¨ä¹Ÿæˆäº†è¿›ç¨‹åˆ‡æ¢ã€‚å¥½åƒæ¯ä¸ªç”¨æˆ·è¿›ç¨‹ä¸­è¿˜éœ€è¦æœ‰ä¸€æ®µå†…æ ¸æ€ä»£ç ï¼Œä»¥å®Œæˆåˆ‡æ¢è¿‡ç¨‹ã€‚</li>
</ul>
</li>
<li>çº¿ç¨‹ï¼šæ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹çš„ç”¨æˆ·æ ˆï¼Œåˆ‡æ¢æ—¶éœ€è¦ä¿å­˜å’Œæ¢å¤å…¨éƒ¨å¯„å­˜å™¨ã€‚ç”±äºå†…æ ¸ä¸ç”¨æˆ·çº¿ç¨‹ä¸åœ¨ä¸€ä¸ªåœ°å€ç©ºé—´ä¸­ï¼Œæ¯ä¸ªç”¨æˆ·çº¿ç¨‹åªæœ‰ç”¨æˆ·æ ˆï¼Œä¸å­˜åœ¨å¯¹åº”çš„å†…æ ¸æ ˆï¼›æ¯ä¸ªå†…æ ¸çº¿ç¨‹åªæœ‰å†…æ ¸æ ˆï¼Œä¸å­˜åœ¨å¯¹åº”çš„ç”¨æˆ·æ ˆã€‚</li>
<li>åç¨‹ï¼šå¯ä»¥ç†è§£ä¸ºçŠ¶æ€æœºè½¬ç§»å‡½æ•°ï¼Œæ‰§è¡Œæ—¶å…±ç”¨åŒä¸€ä¸ªæ ˆã€‚æ¯ä¸ªçº¿ç¨‹å†…å¯ä»¥æœ‰å¤šä¸ªåç¨‹ã€‚ç¼–è¯‘å™¨å°† async å‡½æ•°å˜æ¢æˆçŠ¶æ€æœºæ—¶ï¼Œå‡½æ•°ä¸­éœ€è¦è·¨è¶Š await çš„å˜é‡å°†å­˜æ”¾åœ¨ Future å¯¹è±¡ä¸­ï¼ˆä¸€èˆ¬åœ¨å †ä¸Šï¼‰ï¼Œå…¶å®ƒå˜é‡åªéœ€æ”¾åœ¨æ ˆä¸Šæˆ–å¯„å­˜å™¨ä¸­ã€‚</li>
</ul>
<h2 id="ç³»ç»Ÿä¸­è¿›ç¨‹çº¿ç¨‹åç¨‹çš„çŠ¶æ€åœ¨å¯ç”¨kptiä¸‹"><a class="header" href="#ç³»ç»Ÿä¸­è¿›ç¨‹çº¿ç¨‹åç¨‹çš„çŠ¶æ€åœ¨å¯ç”¨kptiä¸‹">ç³»ç»Ÿä¸­,è¿›ç¨‹,çº¿ç¨‹,åç¨‹çš„çŠ¶æ€.(åœ¨å¯ç”¨kptiä¸‹)</a></h2>
<p>1.ä¸€ä¸ªå†…æ ¸è¿›ç¨‹</p>
<p>2.å¤šä¸ªå¸¸é©»å†…æ ¸æ€çš„å†…æ ¸åç¨‹</p>
<p>3.å¤šä¸ªç”¨æˆ·è¿›ç¨‹,æ¯ä¸ªç”¨æˆ·è¿›ç¨‹ä¸‹åŒ…å«å¤šä¸ªç”¨æˆ·çº¿ç¨‹,æ¯ä¸ªç”¨æˆ·çº¿ç¨‹ä¸‹ç”±å¤šä¸ªç”¨æˆ·åç¨‹,è¿™äº›ç”¨æˆ·è¿›ç¨‹ä¼šåœ¨è¿è¡Œæ—¶ä¸æ–­æ¨ªè·³å…¥å†…æ ¸è¿›ç¨‹ä¸­.</p>
<h3 id="å‚è€ƒ-a-hrefhttpsgithubcomasync-kerneldocumentsblobf85ea19e02217fc5e111309354566b4880046e0fdesigndesignmdå¼‚æ­¥ç³»ç»Ÿè°ƒç”¨è®¾è®¡æ–¹æ¡ˆa"><a class="header" href="#å‚è€ƒ-a-hrefhttpsgithubcomasync-kerneldocumentsblobf85ea19e02217fc5e111309354566b4880046e0fdesigndesignmdå¼‚æ­¥ç³»ç»Ÿè°ƒç”¨è®¾è®¡æ–¹æ¡ˆa">å‚è€ƒ :<a href="https://github.com/async-kernel/documents/blob/f85ea19e02217fc5e111309354566b4880046e0f/design/design.md">å¼‚æ­¥ç³»ç»Ÿè°ƒç”¨è®¾è®¡æ–¹æ¡ˆ</a></a></h3>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-å†…æ ¸å¯åŠ è½½æ¨¡å—ç³»åˆ—"><a class="header" href="#-å†…æ ¸å¯åŠ è½½æ¨¡å—ç³»åˆ—">ğŸš§ å†…æ ¸å¯åŠ è½½æ¨¡å—ç³»åˆ—</a></h1>
<h1 id="gcc-gnu-compiler-collection"><a class="header" href="#gcc-gnu-compiler-collection">GCC (GNU Compiler Collection)</a></h1>
<p>gcc [options] [filenames]</p>
<p>å¸¸ç”¨é€‰é¡¹ 
-E  åˆ¶ä½œé¢„å¤„ç†
-c  åªç¼–è¯‘ä¸é“¾æ¥,ç”Ÿæˆç›®æ ‡æ–‡ä»¶&quot;.o&quot;
-S  ç”Ÿæˆæ±‡ç¼–ä»£ç 
-o  æŠŠè¾“å‡ºç”Ÿæˆåˆ°ç”±fileæŒ‡å®šæ–‡ä»¶åçš„æ–‡ä»¶ä¸­
-g åœ¨è¾“å‡ºçš„æ–‡ä»¶ä¸­åŠ å…¥æ”¯æŒè°ƒè¯•çš„ä¿¡æ¯
-v æ˜¾ç¤ºè¾“å‡ºè¯¦ç»†çš„å‘½ä»¤æ‰§è¡Œè¿‡ç¨‹ä¿¡æ¯</p>
<p>gccçš„ä¸»è¦æ‰§è¡Œæ­¥éª¤</p>
<p>1.ç¼–è¯‘(cc,ä»¥cè¯­è¨€ä¸ºä¾‹): </p>
<p>ç¼–è¯‘å™¨å®Œæˆ â€œé¢„å¤„ç†â€ å’Œ â€œç¼–è¯‘â€,â€œé¢„å¤„ç†â€ æŒ‡å¤„ç†æºæ–‡ä»¶ä¸­ä»¥ â€œ#â€ å¼€å¤´çš„é¢„å¤„ç†æŒ‡ä»¤,è­¬å¦‚ #includeã€#define ç­‰ï¼›</p>
<p>â€œç¼–è¯‘â€ åˆ™é’ˆå¯¹é¢„å¤„ç†çš„ç»“æœè¿›è¡Œä¸€ç³»åˆ—çš„è¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æ,ä¼˜åŒ–åç”Ÿæˆæ±‡ç¼–æŒ‡ä»¤,å­˜æ”¾åœ¨ .o ä¸ºåç¼€çš„ç›®æ ‡æ–‡ä»¶ä¸­ã€‚</p>
<p>2.æ±‡ç¼–ï¼ˆasï¼‰:</p>
<p>æ±‡ç¼–å™¨å°†æ±‡ç¼–è¯­è¨€ä»£ç è½¬æ¢ä¸ºæœºå™¨ï¼ˆCPUï¼‰å¯ä»¥æ‰§è¡Œçš„æŒ‡ä»¤ã€‚</p>
<p>3.é“¾æ¥ï¼ˆldï¼‰:</p>
<p>é“¾æ¥å™¨å°†æ±‡ç¼–å™¨ç”Ÿæˆçš„ç›®æ ‡æ–‡ä»¶å’Œä¸€äº›æ ‡å‡†åº“ï¼ˆè­¬å¦‚ libcï¼‰æ–‡ä»¶ç»„åˆ,å½¢æˆæœ€ç»ˆå¯æ‰§è¡Œçš„åº”ç”¨ç¨‹åºã€‚</p>
<p>gcc -E foo.c -o foo.i(compiler/cc)</p>
<p>gcc -S foo.i -o foo.s(compiler/cc)</p>
<p>gcc -c foo.s -o foo.o(assembler/as)</p>
<p>ld foo.o -o a.out(linker/ld)</p>
<p>GCC æ¶‰åŠçš„æ–‡ä»¶ç±»å‹
â€¢ .cï¼šC æºæ–‡ä»¶
â€¢ .cc/.cxx/.cppï¼šC++ æºæ–‡ä»¶
â€¢ .iï¼šç»è¿‡é¢„å¤„ç†çš„ C æºæ–‡ä»¶
â€¢ .s/.Sï¼šæ±‡ç¼–è¯­è¨€æºæ–‡ä»¶
â€¢ .hï¼šå¤´ï¼ˆheaderï¼‰æ–‡ä»¶
â€¢ .oï¼šç›®æ ‡ï¼ˆobjectï¼‰æ–‡ä»¶
â€¢ .a/.soï¼šç¼–è¯‘åçš„é™æ€åº“ï¼ˆarchiveï¼‰æ–‡ä»¶å’Œå…±äº«åº“
ï¼ˆshared objectï¼‰æ–‡ä»¶
â€¢ a.outï¼šå¯æ‰§è¡Œæ–‡ä»¶</p>
<h1 id="elf-ä»‹ç»"><a class="header" href="#elf-ä»‹ç»">ELF ä»‹ç»</a></h1>
<p>ELFï¼ˆExecutable Linkable Formatï¼‰æ˜¯ä¸€ç§ Unix-like ç³»ç»Ÿä¸Šçš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼æ ‡å‡†ã€‚</p>
<p>ELFæ–‡ä»¶ç±»å‹</p>
<p>1.å¯é‡å®šä½æ–‡ä»¶ï¼ˆRelocatable Fileï¼‰ å†…å®¹åŒ…å«äº†ä»£ç å’Œæ•°æ®,å¯ä»¥è¢«é“¾æ¥æˆå¯æ‰§è¡Œæ–‡ä»¶æˆ–å…±äº«ç›®æ ‡æ–‡ä»¶ã€‚  å¦‚Linux ä¸Šçš„.oæ–‡ä»¶</p>
<p>2.å¯æ‰§è¡Œæ–‡ä»¶ï¼ˆExecutable Fileï¼‰ å¯ä»¥ç›´æ¥æ‰§è¡Œçš„ç¨‹åº  å¦‚Linuxä¸Šçš„a.out</p>
<p>3.å…±äº«ç›®æ ‡æ–‡ä»¶ï¼ˆShared Object Fileï¼‰ å†…å®¹åŒ…å«äº†ä»£ç å’Œæ•°æ®,å¯ä»¥ä½œä¸ºé“¾æ¥å™¨çš„è¾“å…¥,åœ¨é“¾æ¥é˜¶æ®µå’Œå…¶ä»–çš„ Relocatable Fileæˆ–è€… Shared Object Fileä¸€èµ·é“¾æ¥æˆæ–°çš„ Object Fileï¼›æˆ–è€…åœ¨è¿è¡Œé˜¶æ®µ,ä½œä¸ºåŠ¨æ€é“¾æ¥å™¨çš„è¾“å…¥,å’ŒExecutable File ç»“åˆ,ä½œä¸ºè¿›ç¨‹çš„ä¸€éƒ¨åˆ†æ¥è¿è¡Œ  å¦‚Linuxä¸Šçš„.so</p>
<p>4.æ ¸å¿ƒè½¬å‚¨æ–‡ä»¶ï¼ˆCore Dump Fileï¼‰è¿›ç¨‹æ„å¤–ç»ˆæ­¢æ—¶ï¼Œç³»ç»Ÿå¯ä»¥å°†è¯¥è¿›ç¨‹çš„éƒ¨åˆ†å†…å®¹å’Œç»ˆæ­¢æ—¶çš„å…¶ä»–çŠ¶æ€ä¿¡æ¯ä¿å­˜åˆ°è¯¥æ–‡ä»¶ä¸­ä»¥ä¾›è°ƒè¯•åˆ†æã€‚ Linuxä¸Šçš„core æ–‡ä»¶</p>
<p><img src="lkm/./../elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.PNG" alt="avatar" /></p>
<h1 id="é“¾æ¥å™¨"><a class="header" href="#é“¾æ¥å™¨">é“¾æ¥å™¨</a></h1>
<p>é“¾æ¥å™¨æ“ä½œçš„å¯¹è±¡</p>
<p>ç›®æ ‡æ–‡ä»¶å°†å…¶ä¸­ç¼–è¯‘åçš„æœºå™¨æŒ‡ä»¤ä»£ç ,æ•°æ®,ç¬¦å·è¡¨,è°ƒå¼ä¿¡æ¯ç­‰ä»¥èŠ‚(section)å­˜å‚¨</p>
<p>ä»£ç æ®µ(.text) : ç¨‹åºæºä»£ç ç¼–è¯‘åçš„æœºå™¨æŒ‡ä»¤å­˜æ”¾ä½ç½®
æ•°æ®æ®µ(.data) : åˆå§‹åŒ–ä¸ä¸º0çš„å…¨å±€å’Œé™æ€æ•°æ®å­˜æ”¾ä½ç½®
bssæ®µ(.bss) : æœªåˆå§‹åŒ–æˆ–åˆå§‹åŒ–ä¸º0çš„å…¨å±€å’Œé™æ€æ•°æ®å­˜æ”¾ä½ç½®</p>
<p><img src="lkm/./../execfile.gif" alt="avatar" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-upcall"><a class="header" href="#-upcall">ğŸš§ upcall</a></h1>
<p>å†…æ ¸å‚ä¸è°ƒåº¦çš„æ–¹å¼åˆ†ä¸¤ç§æƒ…å†µ:</p>
<p>1.å†…æ ¸å’Œç”¨æˆ·å…±äº«åç¨‹é˜Ÿåˆ—,è¿™æ˜¯tornado-osçš„åšæ³•.è¿™æ—¶å€™åç¨‹æ‰§è¡Œå™¨,å¯ä»¥ç›´æ¥æ”¾åœ¨å†…æ ¸ä¸­.åªéœ€ç”¨çº¿ç¨‹åŒ…è£…åç¨‹å³å¯.</p>
<p>2.å†…æ ¸ä»…æœ‰éƒ¨åˆ†åç¨‹ä¿¡æ¯.(å†…æ ¸ä¸­æ— ç”¨æˆ·åç¨‹é˜Ÿåˆ—)---&gt;å¦‚åªæœ‰æ¯ä¸ªè¿›ç¨‹ä¸‹æœ€é«˜ä¼˜å…ˆçº§åç¨‹çš„ä¼˜å…ˆçº§.è¿™æ—¶å†…æ ¸è°ƒåº¦åç¨‹çš„æ–¹å¼åªèƒ½æ˜¯è°ƒåº¦åç¨‹æ‰€åœ¨çš„çº¿ç¨‹æˆ–è€…è¿›ç¨‹---&gt;å¦‚åœ¨åç¨‹æ‰§è¡Œå™¨ä¸­è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡å‰,æ£€æŸ¥å†…æ ¸æä¾›çš„è°ƒåº¦ä¿¡æ¯.
æ€»ä½“æ¥è¯´. è¿™ç›¸å½“äºä¸€æ¬¡upcall.å³å†…æ ¸å‘ç”¨æˆ·æä¾›äº†ä¸€ä¸ªhint.ç”¨æˆ·æ‹¿åˆ°ä¹‹åå°±ä¼šå¯¹æ­¤åšå‡ºååº”.(handle_upcall)
ä¾‹:sosp21-ghostä¸­çš„æ¨¡å‹
<img src="daliy/./../sosp21-ghost.PNG" alt="avatar" /></p>
<p>å†…æ ¸å‚ä¸è°ƒåº¦åç¨‹çš„ç»ˆæè¿‡ç¨‹(æœªè€ƒè™‘ç»“åˆç”¨æˆ·æ€ä¸­æ–­)
ç»ˆæç›®æ ‡:æœ‰ç´§æ€¥äº‹ä»¶æ—¶,åç¨‹èƒ½ä¸»åŠ¨åˆ‡æ¢.</p>
<p>å¯èƒ½çš„è¿‡ç¨‹---&gt;å½“ä¸€ä¸ªç´§æ€¥äº‹ä»¶å‡ºç°æ—¶,å¦‚é¼ æ ‡,é”®ç›˜ä¸­æ–­,å†…æ ¸ä¸­çš„ä¸­æ–­å¤„ç†å‡½æ•°,è¿›å…¥ç”¨æˆ·ç©ºé—´,å†ä½¿å®ƒæ‰§è¡Œå®Œå½“å‰åç¨‹åä¾¿ä¸»åŠ¨è®©å‡º,ç„¶åæ‰§è¡Œç´§æ€¥åç¨‹.</p>
<p>æ³¨:
1.åº”ç”¨åœºæ™¯æ˜¯é«˜æ€§èƒ½æœåŠ¡å™¨,å¤šä¸ºioå¯†é›†å‹ç¨‹åº,æ‰§è¡Œå½“å‰åç¨‹ä¸ä¼šèŠ±è´¹å¾ˆå¤šæ—¶é—´.
2.å¥½å¤„æ˜¯ä¸éœ€è¦ä¿å­˜çŠ¶æ€.(å› ä¸ºåç¨‹æ˜¯ä¸»åŠ¨è®©å‡ºçš„). </p>
<p>éš¾ç‚¹:è¢«æ‰“æ–­çš„åç¨‹æ²¡æœ‰æ‰§è¡Œå®Œï¼Œç›´æ¥è¿›å…¥äº†ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œæ­¤æ—¶å®ƒçš„æ‰§è¡ŒçŠ¶æ€è¿˜åœ¨æ ˆä¸Šï¼Œå¦‚æœä¸ä»ä¸­æ–­å¤„ç†å‡½æ•°è¿”å›ï¼Œé‚£å®ƒå°±æ²¡æ³•æ‰§è¡Œäº†.</p>
<p>å¯èƒ½çš„å¤„ç†æ–¹æ³•(è„‘æ´ç³»åˆ—): åç¨‹çš„æ‰§è¡Œå™¨ä¸­æœ‰ä¸€ä¸ªupcall_handler(ç±»ä¼¼å†…æ ¸ä¸­çš„syscall_handler).å†…æ ¸ä¸­çš„ä¸­æ–­å¤„ç†å‡½æ•°,ä¼šå‘ç”¨æˆ·å‘ä¸€ä¸ªupcall.ç„¶åç«‹å³è¿”å›è¢«æ‰“æ–­çš„åç¨‹.
è¢«æ‰“æ–­çš„åç¨‹æ‰§è¡Œå®Œå½“å‰åç¨‹ä¹‹åä¾¿ä¼šæ£€æŸ¥æ˜¯å¦æœ‰upcall. å¦‚æœæœ‰ä¾¿åšç›¸åº”çš„å¤„ç†.....è¿™ä¸ªå¤„ç†å…·ä½“é•¿ä»€ä¹ˆæ ·è¿˜æ²¡æƒ³æ¸…æ¥š.ä»¥åŠè¿™äº›å¤„ç†æ˜¯å¦èƒ½åœ¨ç”¨æˆ·æ€è¿è¡Œ.  æ­¤å¤„åº”@å°¤äºˆé˜³.ç”¨æˆ·æ€ä¸­æ–­ç›¸å…³å†…å®¹(åº”è¯¥æ˜¯æ²¡æœ‰é™åˆ¶çš„. å› ä¸ºç”¨æˆ·æ€ä¸­æ–­æ”¯æŒå¤–éƒ¨ä¸­æ–­.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-futures-in-rust"><a class="header" href="#-futures-in-rust">ğŸš§ Futures in Rust</a></h1>
<h1 id="å®˜æ–¹æ–‡æ¡£ä¸­å¯¹äºfutureçš„æè¿°"><a class="header" href="#å®˜æ–¹æ–‡æ¡£ä¸­å¯¹äºfutureçš„æè¿°">å®˜æ–¹æ–‡æ¡£ä¸­å¯¹äºFutureçš„æè¿°</a></h1>
<p>When a future is not ready yet, <code>poll</code> returns <code>Poll::Pending</code> and
stores a clone of the [<code>Waker</code>] copied from the current [<code>Context</code>].
This [<code>Waker</code>] is then woken once the future can make progress.
For example, a future waiting for a socket to become
readable would call <code>.clone()</code> on the [<code>Waker</code>] and store it.
When a signal arrives elsewhere indicating that the socket is readable,
[<code>Waker::wake</code>] is called and the socket future's task is awoken.
Once a task has been woken up, it should attempt to <code>poll</code> the future
again, which may or may not produce a final value.</p>
<p>Futures alone are <em>inert</em>; they must be <em>actively</em> <code>poll</code>ed to make
progress, meaning that each time the current task is woken up, it should
actively re-<code>poll</code> pending futures that it still has an interest in.</p>
<p>The <code>poll</code> function is not called repeatedly in a tight loop -- instead,
it should only be called when the future indicates that it is ready to
make progress (by calling <code>wake()</code>). If you're familiar with the
<code>poll(2)</code> or <code>select(2)</code> syscalls on Unix it's worth noting that futures
typically do <em>not</em> suffer the same problems of &quot;all wakeups must poll
all events&quot;; they are more like <code>epoll(4)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="os-camp-2021-æ¯æ—¥å­¦ä¹ å®è·µè¿‡ç¨‹è®°å½•"><a class="header" href="#os-camp-2021-æ¯æ—¥å­¦ä¹ å®è·µè¿‡ç¨‹è®°å½•">OS Camp 2021 æ¯æ—¥å­¦ä¹ å®è·µè¿‡ç¨‹è®°å½•</a></h2>
<p>ç¬¬ä¸€é˜¶æ®µä»“åº“é“¾æ¥:<a href="https://codechina.csdn.net/weixin_49256325/os_camp">https://codechina.csdn.net/weixin_49256325/os_camp</a></p>
<p>ç¬¬ä¸€é˜¶æ®µä»“åº“é“¾æ¥:<a href="https://github.com/yuoo655/async_os">https://github.com/yuoo655/async_os</a></p>
<p><strong>ä¸ƒæœˆ</strong></p>
<table><thead><tr><th>Mon</th><th>Tues</th><th>Wed</th><th>Thur</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody>
<tr><td></td><td></td><td>1 <br>(<a href="c2rust.html">C2RUST</a>)</td><td>2 <br>(<a href="daliy/7-2.html">D1</a>)</td><td>3 <br>(<a href="daliy/7-3.html">D2</a>)</td><td>4 <br>(<a href="daliy/7-4.html">D3</a>)</td><td>5 <br>(<a href="daliy/7-5.html">D4</a>)</td></tr>
<tr><td>6<br>(<a href="daliy/7-6.html">D5</a>)</td><td>7 <br>(<a href="daliy/7-7.html">D6</a>)</td><td>8 <br>(<a href="daliy/7-8.html">D7</a>)</td><td>9  <br>(<a href="daliy/7-10.html">D9</a>)</td><td>10 <br> (<a href="daliy/7-10.html">D9</a>)</td><td>11 <br></td><td>12 <br></td></tr>
<tr><td>13<br>(<a href="daliy/7-13.html">D12</a>)</td><td>14 <br>(<a href="daliy/7-14.html">D13</a>)</td><td>15 <br>(<a href="daliy/7-15.html">D14</a>)</td><td>16 <br>(<a href="daliy/7-16.html">D15</a>)</td><td>17 <br>(<a href="daliy/7-17.html">D16</a>)</td><td>18 <br>(<a href="daliy/7-18.html">D17</a>)</td><td>19<br>(<a href="daliy/7-18.html">D18</a>)</td></tr>
<tr><td>20<br>(<a href="daliy/7-19.html">D19</a>)</td><td>21 <br>(<a href="daliy/7-20.html">D20</a>)</td><td>22 <br>(<a href="daliy/7-23.html">D22</a>)</td><td>23 <br>(<a href="daliy/7-23.html">D23</a>)</td><td>24 <br>(<a href="daliy/7-24.html">D24</a>)</td><td>25 <br>(<a href="daliy/7-25.html">D25</a>)</td><td>26(<a href="daliy/7-26.html">D26</a>)</td></tr>
<tr><td>27<br>(<a href="daliy/7-27.html">D27</a>)</td><td>28 <br></td><td>29 <br></td><td>30 <br></td><td>31 <br></td><td></td><td></td></tr>
</tbody></table>
<p><strong>å…«æœˆ</strong></p>
<table><thead><tr><th>Mon</th><th>Tues</th><th>Wed</th><th>Thur</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td></td><td></td><td>1<br>(<a href="daliy/8-1%7E8.9.html">D31</a>)</td><td>2  <br></td></tr>
<tr><td>3 <br></td><td>4 <br></td><td>5  <br></td><td>6  <br></td><td>7  <br></td><td>8  <br></td><td>9<br>(<a href="daliy/8-9.html">D40</a>)</td></tr>
<tr><td>10<br>(<a href="daliy/8-10.html">D41</a>)</td><td>11<br>(<a href="daliy/8-11.html">D42</a>)</td><td>12 <br>(<a href="daliy/8-12.html">D43</a>)</td><td>13<br>(<a href="daliy/8-13.html">D44</a>)</td><td>14<br>(<a href="daliy/8-14.html">D45</a>)</td><td>15<br>(<a href="daliy/8-15.html">D46</a>)</td><td>16 <br></td></tr>
<tr><td>17<br></td><td>18<br></td><td>19 <br></td><td>20 <br></td><td>21 <br></td><td>22 <br></td><td>23 <br></td></tr>
<tr><td>24<br></td><td>25<br></td><td>26 <br></td><td>27 <br></td><td>28 <br></td><td>29 <br></td><td>30 <br></td></tr>
<tr><td>31<br></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h2 id="a-hrefdaliy5c7-1htmlc2rustaä¸»è¦è®°å½•ç§»æ¤filexä¸­ä¸€äº›cè¯­è¨€ä»£ç è½¬æ¢ä¸ºrustä»£ç çš„ä¸€äº›å°è¯•"><a class="header" href="#a-hrefdaliy5c7-1htmlc2rustaä¸»è¦è®°å½•ç§»æ¤filexä¸­ä¸€äº›cè¯­è¨€ä»£ç è½¬æ¢ä¸ºrustä»£ç çš„ä¸€äº›å°è¯•"><a href="daliy%5C7-1.html">c2rust</a>ä¸»è¦è®°å½•ç§»æ¤filexä¸­ä¸€äº›cè¯­è¨€ä»£ç è½¬æ¢ä¸ºrustä»£ç çš„ä¸€äº›å°è¯•</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•"><a class="header" href="#-rustå­¦ä¹ è®°å½•">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="76"><a class="header" href="#76">7.6</a></h1>
<p><strong>å¼€å§‹tutorial!</strong></p>
<p><strong>ä½¿ç”¨é“¾æ¥è„šæœ¬æŒ‡å®šç¨‹åºå†…å­˜å¸ƒå±€</strong></p>
<p>ä¸€èˆ¬æ¥è¯´ï¼Œä¸€ä¸ªç¨‹åºæŒ‰ç…§åŠŸèƒ½ä¸åŒä¼šåˆ†ä¸ºä¸‹é¢è¿™äº›æ®µï¼š</p>
<table><tr><td bgcolor=#EFF5FF>
.text æ®µï¼Œå³ä»£ç æ®µï¼Œå­˜æ”¾ä»£ç  å‡ºé”™æ—¶å€™çš„eipå¾€å¾€åœ¨è¿™ä¸ªæ®µ.æŒ‡å‘æŸä¸€æ¡è¯­å¥.ä»¥æ­¤æ¥å®šä½é—®é¢˜ï¼›
<p>.rodata æ®µï¼Œå³åªè¯»æ•°æ®æ®µï¼Œé¡¾åæ€ä¹‰é‡Œé¢å­˜æ”¾åªè¯»æ•°æ®ï¼Œé€šå¸¸æ˜¯ç¨‹åºä¸­çš„å¸¸é‡ï¼›</p>
<p>.data æ®µï¼Œå­˜æ”¾è¢«åˆå§‹åŒ–çš„å¯è¯»å†™æ•°æ®ï¼Œé€šå¸¸ä¿å­˜ç¨‹åºä¸­çš„å…¨å±€å˜é‡ï¼›</p>
<p>.bss æ®µï¼Œå­˜æ”¾è¢«åˆå§‹åŒ–ä¸º 00 çš„å¯è¯»å†™æ•°æ®ï¼Œä¸ .data æ®µçš„ä¸åŒä¹‹å¤„åœ¨äºæˆ‘ä»¬çŸ¥é“å®ƒè¦è¢«åˆå§‹åŒ–ä¸º 00 ï¼Œå› æ­¤åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­åªéœ€è®°å½•è¿™ä¸ªæ®µçš„å¤§å°ä»¥åŠæ‰€åœ¨ä½ç½®å³å¯ï¼Œè€Œä¸ç”¨è®°å½•é‡Œé¢çš„æ•°æ®ã€‚</p>
<p>stack ï¼Œå³æ ˆï¼Œç”¨æ¥å­˜å‚¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­çš„å±€éƒ¨å˜é‡ï¼Œä»¥åŠè´Ÿè´£å‡½æ•°è°ƒç”¨æ—¶çš„å„ç§æœºåˆ¶ã€‚å®ƒä»é«˜åœ°å€å‘ä½åœ°å€å¢é•¿ï¼›</p>
<p>heap ï¼Œå³å †ï¼Œç”¨æ¥æ”¯æŒç¨‹åº<b><font color=#42ACF4>è¿è¡Œè¿‡ç¨‹</font></b>ä¸­å†…å­˜çš„åŠ¨æ€åˆ†é…ï¼Œæ¯”å¦‚è¯´ä½ è¦è¯»è¿›æ¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåœ¨ä½ å†™ç¨‹åºçš„æ—¶å€™ä½ ä¹Ÿä¸çŸ¥é“å®ƒçš„é•¿åº¦ç©¶ç«Ÿä¸ºå¤šå°‘ï¼Œäºæ˜¯ä½ åªèƒ½åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼ŒçŸ¥é“äº†å­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹åï¼Œå†åœ¨å †ä¸­ç»™è¿™ä¸ªå­—ç¬¦ä¸²åˆ†é…å†…å­˜ã€‚</p>
</td></tr></table>
<p>é“¾æ¥è„šæœ¬ç¤ºä¾‹:</p>
<pre><code class="language-linker">
SECTIONS
{
. = 0x10000;
.text : { *(.text) }
. = 0x8000000;
.data : { *(.data) }
.bss : { *(.bss) }
}
</code></pre>
<p><b></b>
. è¡¨ç¤ºèµ·å§‹åœ°å€ å¦‚æœæ²¡æœ‰è¿™ä¸ªåœ°å€ï¼Œé»˜è®¤è¯¥ç¬¦å·çš„å€¼ä¸º0</p>
<p>.text : { *(.text) } : å°†æ‰€æœ‰(*ç¬¦å·ä»£è¡¨ä»»æ„è¾“å…¥æ–‡ä»¶)æ–‡ä»¶çš„.text sectionåˆå¹¶æˆä¸€ä¸ª.text section,è¯¥sectionçš„åœ°å€ç”±å®šä½å™¨ç¬¦å·çš„å€¼æŒ‡å®š, å³0x10000.</p>
<p>. = 0x8000000 ï¼šæŠŠå®šä½å™¨ç¬¦å·ç½®ä¸º0x8000000</p>
<p>.data : { *(.data) } : åŒä¸Š</p>
<p>.bss : { *(.bss) } :  åŒä¸Š</p>
<p><strong>å…¶ä»–å‘½ä»¤</strong>
ENTRY(SYMBOL) :å°†ç¬¦å·SYMBOLçš„å€¼è®¾ç½®æˆå…¥å£åœ°å€ã€‚</p>
<p>INCLUDE filename : åŒ…å«å…¶ä»–åä¸ºfilenameçš„é“¾æ¥è„šæœ¬</p>
<p>INPUT(files): å°†æ‹¬å·å†…çš„æ–‡ä»¶åšä¸ºé“¾æ¥è¿‡ç¨‹çš„è¾“å…¥æ–‡ä»¶</p>
<p>GROUP(files) : æŒ‡å®šéœ€è¦é‡å¤æœç´¢ç¬¦å·å®šä¹‰çš„å¤šä¸ªè¾“å…¥æ–‡ä»¶</p>
<p>OUTPUT(FILENAME) : å®šä¹‰è¾“å‡ºæ–‡ä»¶çš„åå­—</p>
<p>SEARCH_DIR(PATH) ï¼šå®šä¹‰æœç´¢è·¯å¾„ï¼Œ</p>
<p>OUTPUT_ARCH() : è®¾ç½®è¾“å‡ºæ–‡ä»¶çš„ä½“ç³»ç»“æ„</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>pythonç”Ÿæˆé“¾æ¥è„šæœ¬,ä»¥åŠç”¨æˆ·ç¨‹åºbuild</strong></p>
<p>å¤šä¸ªç”¨æˆ·ç¨‹åºbuild</p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()
for app in apps:
    app = app[:app.find('.')]
    lines = []
    lines_before = []
    with open(linker, 'r') as f:
        for line in f.readlines():
            lines_before.append(line)
            line = line.replace(hex(base_address), hex(base_address+step*app_id))
            lines.append(line)
    with open(linker, 'w+') as f:
        f.writelines(lines)
    os.system('cargo build --bin %s --release' % app)
    print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
    with open(linker, 'w+') as f:
        f.writelines(lines_before)
    app_id = app_id + 1

</code></pre>
<p><strong>ç”Ÿæˆbinæ–‡ä»¶...objcopy</strong></p>
<pre><code class="language-python">import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()

for app in apps:
    app = app.strip('.rs')
    os.system('rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/%s --strip-all -O binary  target/riscv64gc-unknown-none-elf/release/%s.bin'%(app,app))
</code></pre>
<p><strong>ç”Ÿæˆé“¾æ¥è„šæœ¬link_app.S  ç›®å½•ä¸‹æ‰€æœ‰binæ–‡ä»¶å†™è¿›é“¾æ¥è„šæœ¬</strong></p>
<pre><code class="language-python">import os


f = open('link_app.S', 'w')

f.writelines(&quot;    .align 3\n&quot;)
f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global _num_app\n&quot;)
f.writelines(&quot;_num_app:\n&quot;)
apps = os.listdir('target/riscv64gc-unknown-none-elf/release')
num = 0

bin_list = []
for app in apps:
    if 'bin' in app:
        num += 1
        bin_list.append(app)

f.writelines(&quot;    .quad %s\n&quot; %len(bin_list))

count  = 0
for app in bin_list:
    f.writelines(&quot;    .quad app_%s_start\n&quot; %count)
    count += 1

f.writelines(&quot;\n&quot;)

f.writelines(&quot;    .section .data\n&quot;)
f.writelines(&quot;    .global app_0_start\n&quot;)
f.writelines(&quot;    .global app_0_end\n&quot;)

for i in range(len(bin_list)):
    f.writelines(&quot;app_%s_start:\n&quot; %i)
    f.writelines(&quot;    .incbin \&quot;../test/target/riscv64gc-unknown-none-elf/release/%s\&quot;\n&quot; %bin_list[i])
    f.writelines(&quot;app_%s_end:\n\n&quot; %i)
    
f.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å½©è‰²è¾“å‡º</strong></p>
<p>ç”¨printå®åŒ…è£… info debug error. åŠ ç‚¹å‚æ•°å°±èƒ½æ˜¾ç¤ºå‡ºä¸åŒé¢œè‰²</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! print {
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print(format_args!($($arg)*));
    });
}

#[macro_export]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;{}\n&quot;, format_args!($($arg)*)));
}


#[macro_export]
macro_rules! info {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[31m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}

#[macro_export]
macro_rules! debug {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[32m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}

#[macro_export]
macro_rules! error {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ($crate::print!(&quot;\x1b[34m{}\x1b[0m\n&quot;, format_args!($($arg)*)));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ"><a class="header" href="#æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ">æ“ä½œç³»ç»Ÿå¤šæ ¸æ”¯æŒ</a></h1>
<p>åœ¨intelæ‰‹å†Œ8.4 MULTIPLE-PROCESSOR (MP) INITIALIZATION å¯æŸ¥åˆ°å¤šæ ¸å¯åŠ¨ç›¸å…³ä¿¡æ¯.</p>
<font size = 3> 
8.4.1 BSP and AP Processors
The MP initialization protocol defines two classes of processors: the bootstrap processor (BSP) and the application
processors (APs). Following a power-up or RESET of an MP system, system hardware dynamically selects one of the
processors on the system bus as the BSP. The remaining processors are designated as APs.
As part of the BSP selection mechanism, the BSP flag is set in the IA32_APIC_BASE MSR (see Figure 10-5) of the
BSP, indicating that it is the BSP. This flag is cleared for all other processors.
The BSP executes the BIOSâ€™s boot-strap code to configure the APIC environment, sets up system-wide data structures, and starts and initializes the APs. When the BSP and APs are initialized, the BSP then begins executing the
operating-system initialization code.
</font>
<br></br>
<font size = 3> 
Following a power-up or reset, the APs complete a minimal self-configuration, then wait for a startup signal (a SIPI
message) from the BSP processor. Upon receiving a SIPI message, an AP executes the BIOS AP configuration code,
which ends with the AP being placed in halt state.
For Intel 64 and IA-32 processors supporting Intel Hyper-Threading Technology, the MP initialization protocol treats
each of the logical processors on the system bus or coherent link domain as a separate processor (with a unique
APIC ID). During boot-up, one of the logical processors is selected as the BSP and the remainder of the logical
processors are designated as APs.
</font>
<p>åœ¨å¯åŠ¨æ—¶å€™.ä¼šé€‰å‡ºä¸€ä¸ªæ ¸ä½œä¸ºBSP. åŒæ—¶è®¾ç½®å…¶ä»–æ ¸(APs)çš„flagä¿¡æ¯.ç„¶åç”±BSPæ¥æ‰§è¡Œåˆå§‹åŒ–å…¶ä»–æ ¸(APs). å½“BSPå’ŒAPséƒ½åˆå§‹åŒ–å®Œæˆå,ç”±BSPæ¥æ‰§è¡Œç³»ç»Ÿåˆå§‹åŒ–ä»£ç </p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å­¦ä¹ å¤šæ ¸å¯åŠ¨æ”¯æŒ</strong></p>
<p><strong>å‚è€ƒå·²æœ‰çš„å®ç°</strong></p>
<p>ä¸»è¦çœ‹é“¾æ¥è„šæœ¬ä¸­æŒ‡å®šçš„å…¥å£æ±‡ç¼–ä»£ç ,ä»¥åŠæ¥ä¸‹æ¥è·³è½¬åˆ°çš„ä»£ç </p>
<p>1.rcore</p>
<pre><code class="language-x86asm">    .section .text.entry
    .globl _start
_start:
    # a0 == hartid
    # pc == 0x80200000
    # sp == 0x800xxxxx

    # 1. set sp
    # sp = bootstack + (hartid + 1) * 0x10000
    add     t0, a0, 1
    slli    t0, t0, 14
    lui     sp, %hi(bootstack)
    add     sp, sp, t0

....(ç•¥)

    # 3. jump to rust_main (absolute address)
    lui     t0, %hi(rust_main)
    addi    t0, t0, %lo(rust_main)
    jr      t0

    .section .bss.stack
    .align 12   # page align
    .global bootstack
bootstack:
    .space 4096 * 4 * 8
    .global bootstacktop
bootstacktop:

    .section .data
    .align 12   # page align
....(ç•¥)
</code></pre>
<p><strong>åŠ è½½å¸¸é‡åˆ°æŸå¯„å­˜å™¨å¸¸ç”¨çš„æ±‡ç¼–ä»£ç </strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(constant)
addi    t0, t0, %lo(constant)
</code></pre>
<p><strong>åŠ è½½ç»å¯¹åœ°å€åˆ°æŸå¯„å­˜å™¨</strong></p>
<pre><code class="language-x86asm">lui     t0, %hi(address)
addi    t0, t0, %lo(address)
</code></pre>
<p><strong>æœ‰äº†è¿™ä¸ªåŸºç¡€è¿™æ®µä»£ç å°±å¥½ç†è§£äº†</strong>
ä¸ºå½“å‰æ ¸å¿ƒè®¾ç½®ä¸€ä¸ªæ ˆ,åœ°å€ä¸º:sp = bootstack + (hartid + 1) * 0x10000
å†è·³è½¬åˆ°rust_main....</p>
<p><strong>next:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn rust_main(hartid: usize, device_tree_paddr: usize) -&gt; ! {
    let device_tree_vaddr = phys_to_virt(device_tree_paddr);

    unsafe {
        cpu::set_cpu_id(hartid);
    }

    if hartid != BOOT_HART_ID {
        while !AP_CAN_INIT.load(Ordering::Relaxed) {}
        others_main(hartid);
    }

    unsafe {
        memory::clear_bss();
    }

    println!(
        &quot;Hello RISCV! in hart {}, device tree @ {:#x}&quot;,
        hartid, device_tree_vaddr
    );

    crate::logging::init();
    unsafe {
        trapframe::init();
    }
    memory::init(device_tree_vaddr);
    timer::init();
    // FIXME: init driver on u540
    #[cfg(not(any(feature = &quot;board_u540&quot;)))]
    board::init(device_tree_vaddr);
    unsafe {
        board::init_external_interrupt();
    }
    crate::process::init();

    AP_CAN_INIT.store(true, Ordering::Relaxed);
    crate::kmain();
}

fn others_main(hartid: usize) -&gt; ! {
    unsafe {
        trapframe::init();
    }
    memory::init_other();
    timer::init();
    info!(&quot;Hello RISCV! in hart {}&quot;, hartid);
    crate::kmain();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>rust_mainçš„å¤šæ ¸å¤„ç†</strong></p>
<p>1.è®¾ç½®thread_pointerä¸ºhartid</p>
<p>2.é¦–å…ˆè®©hartid = BOOT_HART_IDæ‰§è¡Œå®Œrust_main,åŒæ—¶å¦‚æœå…¶ä»–hartè¿›å…¥åˆ°æ­¤å‡½æ•°åˆ™å¾ªç¯ç­‰å¾….ç›´åˆ°BST(boot_hart)æ‰§è¡Œå¯åŠ¨ä»£ç ,å¹¶è®¾ç½®åŸå­æ“ä½œæ“ä½œAP_CAN_INIT.store(true, Ordering::Relaxed)å,å†æ‰§è¡Œå…¶ä»–hartçš„åˆå§‹åŒ–æ“ä½œ.</p>
<p>è¿™é‡Œç”¨åˆ°äº†rustä¸­çš„atomicåŸºæœ¬ç”¨æ³•å¦‚ä¸‹:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicBool, Ordering};
let some_bool = AtomicBool::new(true);
some_bool.store(false, Ordering::Relaxed);
assert_eq!(some_bool.load(Ordering::Relaxed), false);
<span class="boring">}
</span></code></pre></pre>
<table><td bgcolor=#EFF5FF>
ç”³è¯·ä¸€ä¸ªåŸå­å‹boolå˜é‡åˆå§‹åŒ–ä¸ºtrue. AtomicBool::new(true)
<p>load(Ordering::Relaxed)æ¥è·å¾—å˜é‡å€¼</p>
<p>store(false, Ordering::Relaxed)æ¥æ”¹å˜å€¼</p>
</td></table>
<p><strong>å¤šæ ¸å¯åŠ¨æ¦‚æ‹¬</strong></p>
<p>1.è®©ä¸»æ ¸(BST)æ‰§è¡Œå®Œå¯åŠ¨ä»£ç .åŒæ—¶è®¾ç½®åŸå­æ“ä½œè®©å…¶ä»–æ ¸ç­‰å¾….ç„¶åæ‰§è¡Œå…¶ä»–æ ¸(AP)çš„å¯åŠ¨ä»£ç .</p>
<p>2.ä¸ºæ¯ä¸ªæ ¸è®¾ç½®å¥½æ ˆ</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å®ç°ä¸­æ–­æœºåˆ¶</strong></p>
<p>å†…æ ¸æ ˆ:å›ºå®šå¤§å°,æ¯ä¸ªè¿›ç¨‹,çº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªå†…æ ¸æ ˆ.å†…æ ¸æ ˆæ˜¯è¿›ç¨‹,çº¿ç¨‹åœ¨å†…æ ¸æ€ä¸‹æ‰€ä½¿ç”¨çš„æ ˆ.åœ¨ç”¨æˆ·æ€ä¸‹cpuçš„spæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ç”¨æˆ·æ ˆçš„æ ˆé¡¶.å†…æ ¸æ€ä¸‹æŒ‡å®šå†…æ ¸æ ˆçš„æ ˆé¡¶.</p>
<p><strong>ä¸­æ–­å®ç°æ€è·¯</strong></p>
<table><tr><td bgcolor=#EFF5FF>
1.åŒºåˆ†æ˜¯ä»ç”¨æˆ·æ€è¿˜æ˜¯å†…æ ¸æ€ä¸­æ–­, ä¿å­˜32ä¸ªé€šç”¨å¯„å­˜å™¨ä»¥åŠä¸€äº›æ§åˆ¶ä¸çŠ¶æ€å¯„å­˜å™¨csr.ç„¶åè·³è½¬åˆ°ä¸­æ–­å¤„ç†å‡½æ•°  æ­¤éƒ¨åˆ†ç”¨æ±‡ç¼–è¯­è¨€å†™
<p>2.è¿›å…¥ä¸­æ–­å¤„ç†å‡½æ•°,printä¸­æ–­æ¥æº(ç”¨æˆ·æ€orå†…æ ¸æ€) å½“å‰ä¸­æ–­æŒ‡ä»¤(pc) ä¸­æ–­åŸå› (è¯»å–scauseå¯„å­˜å™¨)
# å¦‚æœä»å†…æ ¸æ€è¿›å…¥ä¸­æ–­ï¼Œ sstatus çš„ SPP ä½è¢«ç¡¬ä»¶è®¾ä¸º 1
# å¦‚æœä»ç”¨æˆ·æ€è¿›å…¥ä¸­æ–­ï¼Œ sstatus çš„ SPP ä½è¢«ç¡¬ä»¶è®¾ä¸º 0</p>
<p>3.æ¢å¤ä¸Šä¸‹æ–‡. æ¢å¤32ä¸ªé€šç”¨å¯„å­˜å™¨,ä»¥åŠä¸€äº›csrå¯„å­˜å™¨.</p>
</td></tr></table>
<p>æŒ‰ç…§ TrapContext ç»“æ„ä½“çš„å†…å­˜å¸ƒå±€ï¼Œå®ƒä»ä½åœ°å€åˆ°é«˜åœ°å€åˆ†åˆ«æŒ‰é¡ºåºæ”¾ç½® x0~x31ï¼Œæœ€åæ˜¯ sstatus å’Œ sepc ã€‚å› æ­¤é€šç”¨å¯„å­˜å™¨ xn åº”è¯¥è¢«ä¿å­˜åœ¨åœ°å€åŒºé—´ [sp+8n,sp+8(n+1)) ã€‚ åœ¨è¿™é‡Œæˆ‘ä»¬æ­£æ˜¯è¿™æ ·åŸºäº sp æ¥ä¿å­˜è¿™äº›é€šç”¨å¯„å­˜å™¨çš„ã€‚
(ä¸»è¦ä¿å­˜trapframeä¸­å†…å®¹)ä¿å­˜32ä¸ªé€šç”¨å¯„å­˜å™¨ä»¥åŠä¸€äº›æ§åˆ¶ä¸çŠ¶æ€å¯„å­˜å™¨csr æ­¤éƒ¨åˆ†ä¸trapframeç»“æ„ä½“ä¸€è‡´. æ¢å¤æ—¶åªè¦æŠŠç»“æ„ä½“æŒ‡é’ˆæŒ‡å‘spå°±èƒ½æ¢å¤trapframe</p>
<p>csrrw rd, csr, rs å¯ä»¥å°† CSR å½“å‰çš„å€¼è¯»åˆ°é€šç”¨å¯„å­˜å™¨ rd ä¸­ï¼Œç„¶åå°† é€šç”¨å¯„å­˜å™¨ rs çš„å€¼å†™å…¥è¯¥ CSR ã€‚å› æ­¤è¿™é‡Œèµ·åˆ°çš„æ˜¯äº¤æ¢ sscratch å’Œ sp çš„æ•ˆæœã€‚åœ¨è¿™ä¸€è¡Œä¹‹å‰ sp æŒ‡å‘ç”¨æˆ·æ ˆï¼Œ sscratch æŒ‡å‘å†…æ ¸æ ˆï¼Œç°åœ¨ sp æŒ‡å‘å†…æ ¸æ ˆï¼Œ sscratch æŒ‡å‘ç”¨æˆ·æ ˆã€‚</p>
<hr />
<p>ä»ç”¨æˆ·æ€ä¸­æ–­æ—¶,spæŒ‡å‘å†…æ ¸æ ˆ.ç„¶ååœ¨sp[...]åŒºé—´ä¸­ä¿å­˜trapcontextå†…å®¹</p>
<p><strong>ç–‘é—®</strong>:(ä¸­æ–­å¤„ç†ç¨‹åºç”¨çš„ä¹Ÿæ˜¯å†…æ ¸æ ˆ,éš¾é“æ‰§è¡Œæµä¸ä¼šæ”¹å˜å†…æ ¸æ ˆä¸­çš„å†…å®¹å—? é‚£ä¿å­˜äº†è¿˜æœ‰ä»€ä¹ˆæ„ä¹‰. è¯¥æ‰§è¡Œæµä»…ä¼šæ”¹åŠ¨trapcontextä¸­çš„å†…å®¹å—?)</p>
<p><strong>åˆ†æ</strong>:spæ°¸è¿œæŒ‡å‘æ‰§è¡Œæµä¸­çš„æ ˆ.æ‰€ä»¥ä¸­æ–­å¤„ç†ç¨‹åºè¿è¡Œæ—¶å€™å¹¶ä¸ä¼šå¹²æ‰°åˆ°åŸæœ¬ä¿æŒçš„å†…å®¹</p>
<p>more:å†…æ ¸æ ˆå¯ä»¥ç†è§£ä¸ºæ˜¯ä¸€ä¸ªä¸­æ–­å‘ç”Ÿæ—¶ä¸´æ—¶å­˜æ”¾é€šç”¨å¯„å­˜å™¨ä»¥åŠæŒ‡ä»¤ä¸çŠ¶æ€å¯„å­˜å™¨ä¿¡æ¯çš„æ ˆ. å®é™…å†…æ ¸åœ¨æ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°æ—¶å¹¶ä¸ä¼šç”¨åˆ°è¯¥æ ˆ(æŒ‡çš„æ˜¯ä¸ä¿®æ”¹.è¿˜æ˜¯å¯ä»¥ä»ä¸­è¯»å–ä¸€äº›ä¿¡æ¯),å†…æ ¸æ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°æ—¶æ‰€ä½¿ç”¨çš„æ ˆæ˜¯sp.(åœ¨ä»»ä½•æ‰§è¡Œæµä¸­ä½¿ç”¨çš„æ ˆéƒ½åº”è¯¥æ˜¯sp)</p>
<hr />
<p><strong>addi sp, sp, -34*8</strong>ä¸ºä»€ä¹ˆè¿™æ¡æŒ‡ä»¤å¯ä»¥è¡¨ç¤ºåˆ†é…äº†æ ˆå¸§. spæŒ‡å‘çš„æ˜¯æ ˆé¡¶. æ ˆå‘ä½åœ°å€å¢é•¿,ç°åœ¨å‡å°‘spçš„å€¼æ„å‘³ç€æ ˆé¡¶çš„æé«˜.ç›¸å½“äºåˆ†é…äº†ç©ºé—´</p>
<hr />
<p><strong>æ—¶é’Ÿä¸­æ–­</strong></p>
<p>ç›¸å…³å¯„å­˜å™¨ mtime  â€‹mtimecmp   mie  sie sip</p>
<p>SI(Software Interrupt)ï¼Œè½¯ä»¶ä¸­æ–­
TI(Timer Interrupt)ï¼Œæ—¶é’Ÿä¸­æ–­
EI(External Interrupt)ï¼Œå¤–éƒ¨ä¸­æ–­</p>
<p>â€‹mtimecmp â€‹= â€‹mtime â€‹+ â€‹Xâ€‹
A timer interrupt (if enabled) is generated whenever â€‹mtime â€‹is greater than or equal to the valuein the â€‹mtimecmp â€‹register. Therefore, to generate a timer interrupt after â€‹X â€‹cycles, one can updatemtimecmp â€‹register as follows: â€‹mtimecmp â€‹= â€‹mtime â€‹+ â€‹Xâ€‹.</p>
<p>// æ ¹æ®ä¸­æ–­åŸå› åˆ†ç±»è®¨è®º</p>
<pre><code>// åªèƒ½å½“æ¯ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­è§¦å‘æ—¶
// è®¾ç½®ä¸‹ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­çš„è§¦å‘æ—¶é—´
// è®¾ç½®ä¸ºå½“å‰æ—¶é—´åŠ ä¸Š TIMEBASE
// è¿™æ¬¡è°ƒç”¨ç”¨æ¥é¢„å¤„ç†
</code></pre>
<p>æ ¹ç»scause åŒºåˆ†ä¸­æ–­ç±»åˆ«.   è¯¥æœ‰ä¸åŒçš„å¤„ç†äº†   ä»¥åŠè®¾ç½®å¤šå°‘cycleè§¦å‘ä¸€æ¬¡æ—¶é’Ÿä¸­æ–­</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ä¸­æ–­å…·ä½“å®ç°</strong></p>
<p><strong>æ•´ç†ä¸‹ä¸­æ–­æ“ä½œç›¸å…³çš„csrå¯„å­˜å™¨</strong></p>
<blockquote>
<p><strong>sepc</strong>:å‘ç”Ÿå¼‚å¸¸çš„æŒ‡ä»¤çš„pcè¢«å­˜å…¥sepc. æˆ‘ä»¬éœ€è¦è¯»å–ä»–æ¥è·å¾—bugä¿¡æ¯.</p>
<p><strong>stvec</strong>:riscvå¤„ç†å™¨trapåè·³å…¥çš„PCåœ°å€ç”±ä¸€ä¸ªå«åšæœºå™¨æ¨¡å¼å¼‚å¸¸å…¥å£åŸºåœ°å€å¯„å­˜å™¨mtvecçš„csrå¯„å­˜å™¨æŒ‡å®š. mtvecæ˜¯ä¸€ä¸ªå¯è¯»å¯å†™çš„å¯„å­˜å™¨, è½¯ä»¶å¯ä»¥ç¼–ç¨‹è®¾å®šå®ƒçš„å€¼.åœ¨Sæ¨¡å¼ä¸‹ç”¨åˆ°çš„å¯„å­˜å™¨å³ä¸ºstvec.æˆ‘ä»¬éœ€è¦ç”¨å†™stvecæ¥è·³è½¬åˆ°ä¸­æ–­å¤„ç†ä»£ç .trap.asmä¸­çš„__alltrapså¤„</p>
<p><strong>scaues</strong>:å®ƒä¼šè®°å½•ä¸­æ–­å‘ç”Ÿçš„åŸå› , éœ€è¦ç”¨è¯»å–è¯¥å¯„å­˜å™¨æ¥æ ¹æ®ä¸åŒç±»å‹ä¸­æ–­æ‰§è¡Œä¸åŒå¤„ç†ä»£ç </p>
<p><strong>sstatus</strong>:éœ€è¦è®¾ç½®å®ƒçš„sieä½æ¥ä½¿èƒ½ä¸­æ–­</p>
</blockquote>
<p><strong>å¦‚ä½•è¯»å†™csrå¯„å­˜å™¨</strong></p>
<p>è¯»å†™satpå¯„å­˜å™¨ä¸ºä¾‹:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, satp&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn write(x: usize) {
    llvm_asm!(&quot;csrw satp, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆå§‹åŒ–ä¸­æ–­</strong></p>
<p>åœ¨å¤„ç†å™¨çš„ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­,ä¸€æ—¦å‘ç”Ÿå¼‚å¸¸,åˆ™ç»ˆæ­¢å½“å‰çš„ç¨‹åºæµ,å¤„ç†å™¨è¢«å¼ºè¡Œè·³è½¬åˆ°ä¸€ä¸ªæ–°çš„PCåœ°å€ã€‚</p>
<p>åœ¨riscvä¸­Sæ€è¯¥åœ°å€ç”±stvecæŒ‡å®šstvecä½2ä½ä½modeåŸŸ,é«˜30ä½æ˜¯baseåŸŸ.</p>
<p>å½“<strong>MODE</strong>=0ï¼Œè®¾ç½®ä¸º Direct æ¨¡å¼æ—¶ï¼Œåˆ™æ‰€æœ‰çš„å¼‚å¸¸å“åº”æ—¶å¤„ç†å™¨å‡è·³è½¬åˆ°baseå€¼æŒ‡ç¤ºçš„pcåœ°å€ã€‚</p>
<p>å½“<strong>MODE=1</strong>æ—¶ï¼Œè®¾ç½®ä¸º Vectored æ¨¡å¼æ—¶ï¼Œé‡åˆ°ä¸­æ–­æˆ‘ä»¬ä¼šè¿›è¡Œè·³è½¬å¦‚ä¸‹ï¼šPC-&gt;BASE + 4 x causeã€‚è€Œè¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€å°†å„ä¸­æ–­å¤„ç†ç¨‹åºæ”¾åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œå¹¶è®¾ç½®å¥½ stvec ï¼Œé‡åˆ°ä¸­æ–­çš„æ—¶å€™ç¡¬ä»¶æ ¹æ®ä¸­æ–­åŸå› å°±ä¼šè‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”çš„ä¸­æ–­å¤„ç†ç¨‹åºäº†</p>
<p>åœ¨æ­¤æˆ‘ä»¬é€‰æ‹©Directæ¨¡å¼.è·³è½¬åˆ°ç»Ÿä¸€åœ°å€è¿›è¡Œå¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init() {
    unsafe {
        extern &quot;C&quot; {
            fn __alltraps();
        }
        //è®¾ç½®trapè·³è½¬åˆ°ç»Ÿä¸€åœ°å€ __alltrapså¤„
        println!(&quot;trap init--------------&quot;);
        stvec::write(__alltraps as usize);
        sstatus::set_sie();
    }
    println!(&quot;++++ setup interrupt! ++++&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>stvec</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub unsafe fn _write(x: usize) {
    llvm_asm!(&quot;csrw stvec, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);
}
//0ä¸ºè®¾ç½®æˆDirectæ¨¡å¼
#[inline]
pub unsafe fn write(addr: usize) {
    _write(addr + 0 as usize);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>sstatus</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIE: usize = 1 &lt;&lt; 1;  // supervisor interrupt enable
#[inline]
pub fn write(x: usize) {
    unsafe {llvm_asm!(&quot;csrw sstatus, $0&quot;::&quot;r&quot;(x)::&quot;volatile&quot;);}
}

#[inline]
pub fn read() -&gt; usize {
    let ret: usize;
    unsafe {llvm_asm!(&quot;csrr $0, sstatus&quot;:&quot;=r&quot;(ret):::&quot;volatile&quot;);}
    ret
}

#[inline]
pub fn set_sie() {
    write(read() | SIE);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>__alltrap</strong></p>
<pre><code class="language-x86asm">__alltraps:
    csrrw sp, sscratch, sp       äº¤æ¢ç”¨æˆ·æ ˆå’Œå†…æ ¸æ ˆ
    addi sp, sp, -34*8           åœ¨å†…æ ¸æ ˆä¸Šåˆ†é…ä¸€ä¸ªtrapcontextå¤§å°çš„æ ˆå¸§
    
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct TrapContext {
    // 32ä¸ªé€šç”¨å¯„å­˜å™¨ 
    pub x: [usize; 32], 
    // å‡ ä¸ªç›¸å…³csrå¯„å­˜å™¨
    pub sstatus: usize,
    pub sepc: usize,
    pub stval: usize,
    pub scause: usize,
    //å…±éœ€(32+4)*8çš„æ ˆç©ºé—´
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>trap.asm</strong></p>
<pre><code class="language-x86asm">	.section .text
	.globl __alltraps
__alltraps:
	SAVE_ALL
	mv a0, sp
	jal trap_handler

	.globl __trapret
__trapret:
	RESTORE_ALL
	sret

.equ XLENB, 8
.macro LOAD a1, a2
	ld \a1, \a2*XLENB(sp)
.endm

.macro STORE a1, a2
	sd \a1, \a2*XLENB(sp)
.endm
</code></pre>
<p><strong>save_allå’Œrestore_all</strong></p>
<pre><code class="language-x86asm">
.macro SAVE_ALL
	csrrw sp, sscratch, sp
	addi sp, sp, -36*XLENB
	STORE x1, 1
	STORE x3, 3
...
    STORE x30, 30
    STORE x31, 31

	csrrw s0, sscratch, x0
	csrr s1, sstatus
	csrr s2, sepc
	csrr s3, stval
	csrr s4, scause
	
	STORE s0, 2
	STORE s1, 32
	STORE s2, 33
	STORE s3, 34
	STORE s4, 35
.endm
</code></pre>
<pre><code class="language-x86asm">.macro RESTORE_ALL
	LOAD s1, 32
	LOAD s2, 33
	andi s0, s1, 1 &lt;&lt; 8
    csrw sstatus, s1
    csrw sepc, s2
	LOAD x1, 1
	LOAD x3, 3
...
    LOAD x30, 30
    LOAD x31, 31

	LOAD x2, 2
.endm
</code></pre>
<p>åˆ†åˆ«ç”¨ldå’Œsdæ¥ä¿å­˜é€šç”¨å¯„å­˜å™¨.64ä½æ•°æ®éœ€è¦8å­—èŠ‚ç©ºé—´å­˜å‚¨.ç”¨å¯„å­˜å™¨ç¼–å·*8(sp)æ¥å­˜æ”¾åˆ°trapcontextä¸­ç›¸åº”ä½ç½®å»
åŒºåˆ†æ˜¯ä»ç”¨æˆ·æ€ä¸­æ–­è¿˜æ˜¯ä»å†…æ ¸æ€ä¸­æ–­.åªéœ€åˆ¤æ–­spæ˜¯å¦ä¸º0.sp!=0åˆ™æ˜¯ä»ç”¨æˆ·æ€è¿›å…¥ä¸­æ–­.sp=0åˆ™æ˜¯ä»å†…æ ¸æ€è¿›å…¥ä¸­æ–­.æ— éœ€åˆ‡æ¢æ ˆ</p>
<p>å®ç°ä¸­æ–­å¤„ç†å‡½æ•°trap_handler</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    match cause {

        3 =&gt; breakpoint(&amp;mut tf.sepc),
        5 =&gt; super_timer(),
        12 =&gt; page_fault(tf),
        13 =&gt; page_fault(tf),
        15 =&gt; page_fault(tf),
        _ =&gt; println!(&quot;undefined trap!&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>1.æ‰“å°å‡ºä¸­æ–­ç±»å‹,ä»¥åŠè§¦å‘ä¸­æ–­æŒ‡å®šçš„pcå€¼.ä»¥ä¾¿ä»¥åè°ƒè¯•</p>
<p>2.æ ¹æ®causeä¸åŒåˆ†åˆ«è¿›è¡Œä¸åŒçš„å¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>å¦‚æœæ˜¯æ–­ç‚¹åˆ™æ‰“å°æ–­ç‚¹pc. ç„¶åpc+2.æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ (riscv64æŒ‡å®šé•¿åº¦ä¸º4å­—èŠ‚.åŸæ¥åº”è¯¥æ˜¯sepc+4.ä½†æ˜¯ç¼–è¯‘å™¨çš„è¡Œä¸ºä¼šå‹ç¼©.æ‰€ä»¥ä¿®æ­£ä¸ºsepc+2)
fn breakpoint(sepc: &amp;mut usize) {
    println!(&quot;a breakpoint epc:0x{:x}&quot;, sepc);
    *sepc += 2;
}

æ¯æ¬¡è§¦å‘æ—¶é’Ÿä¸­æ–­TICKS+1.è§¦å‘100æ¬¡æ‰“å°ä¸€æ¬¡.
fn super_timer() {
    clock_set_next_event();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}

//page_fault
fn page_fault(tf: &amp;mut TrapContext) {
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    println!(&quot;{:?} va = {:#x} instruction = {:#x}&quot;, cause, tf.stval, tf.sepc);
    panic!(&quot;page fault!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>è‡³æ­¤trapå¯ä»¥å¯ä»¥æ­£å¸¸å·¥ä½œ</strong></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è¿è¡Œåº”ç”¨ç¨‹åº</strong></p>
<p><strong>å°†åº”ç”¨ç¨‹åºé“¾æ¥åˆ°å†…æ ¸</strong></p>
<p>link_app.S</p>
<pre><code class="language-x86asm">    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 3
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_2_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;
app_1_end:

    .section .data
    .global app_2_start
    .global app_2_end
app_2_start:
    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;
app_2_end:

</code></pre>
<p><strong>.incbin</strong></p>
<table><tr><td bgcolor=#EFF5FF>
The incbin directive includes file verbatim at the current location. You can control the search paths used with the -I command-line option (refer to Chapter 3 Command-Line Options). Quotation marks are required around file.
<p>The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user's responsibility to make sure that proper alignment is provided both before and after the incbin directive.</p>
</td></tr></table>
<p><strong>.quad</strong></p>
<p>ç”¨æ¥å®šä¹‰ä¸€ä¸ª8å­—èŠ‚. åœ°å€ä¸ºå„ä¸ªåº”ç”¨ç¨‹åºèµ·å§‹åœ°å€</p>
<p>num_app_ptr[x] æ¥å¾—åˆ°_num_appä¸­å®šä¹‰çš„åº”ç”¨ç¨‹åºèµ·å§‹åœ°å€</p>
<p>ç„¶åç”¨copy_from_sliceæ¥å®ç°ç±»ä¼¼memcpyçš„åŠŸèƒ½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_MANAGER: AppManager = AppManager {
        inner: RefCell::new({
            extern &quot;C&quot; { fn _num_app(); }
            let num_app_ptr = _num_app as usize as *const usize;
            let num_app = unsafe { num_app_ptr.read_volatile() };
            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];
            let app_start_raw: &amp;[usize] = unsafe {
                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
            };
            app_start[..=num_app].copy_from_slice(app_start_raw);
            AppManagerInner {
                num_app,
                current_app: 0,
                app_start,
            }
        }),
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>æŠŠåº”ç”¨ç¨‹åºçš„ä»£ç å’Œæ•°æ®å­˜åœ¨äº†app_startçš„æ•°ç»„ä¹‹å.ç„¶ååˆ©ç”¨trapè¿”å›åœ¨å†…æ ¸æ ˆä¸Šå‹å…¥è®¾ç½®å¥½çš„æ ˆ
riscvå‡½æ•°è°ƒç”¨è§„å®šç¬¬ä¸€ä¸ªå‚æ•°æ”¾åœ¨a0ä¸­. åˆ©ç”¨è¿™ç‚¹trap.asm ä¸­ __trapret mv sp, a0  å¯ä»¥è®©æˆ‘ä»¬å‹å…¥æˆ‘ä»¬è®¾ç½®å¥½çš„æ ˆ
æ ˆè®¾ç½®:</p>
<p>1.sspè®¾ç½®ä¸ºuser</p>
<p>2.sepcè®¾ç½®ä¸ºåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TrapContext {
    pub fn set_sp(&amp;mut self, sp: usize) { self.x[2] = sp; }
    pub fn app_init_context(entry: usize, sp: usize) -&gt; Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
        };
        cx.set_sp(sp);
        cx
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ç”±äºåœ¨ RISC-V ä¸­æ ˆæ˜¯å‘ä¸‹å¢é•¿çš„, æ ˆé¡¶åœ°å€ = èµ·å§‹åœ°å€+æ ˆå¤§å°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl KernelStack {
    fn get_sp(&amp;self) -&gt; usize {
        self.data.as_ptr() as usize + KERNEL_STACK_SIZE
    }
    pub fn push_context(&amp;self, cx: TrapContext) -&gt; &amp;'static mut TrapContext {
        let cx_ptr = (self.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) as *mut TrapContext;
        unsafe { *cx_ptr = cx; }
        unsafe { cx_ptr.as_mut().unwrap() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¤„ç†ç³»ç»Ÿè°ƒç”¨</strong></p>
<p>ç³»ç»Ÿè°ƒç”¨:é€šè¿‡æŸ¥riscvæ‰‹å†Œ Environment call from U-mode ä¸ºå¼‚å¸¸.å¼‚å¸¸å·ä¸º8</p>
<p>åœ¨traphandlerä¸­åŠ å…¥å¯¹ç³»ç»Ÿè°ƒç”¨å¤„ç†</p>
<p>é€šè¿‡è¯»å–scauseçš„ç¬¬64ä½æ¥åŒºåˆ†æ˜¯ä¸­æ–­è¿˜æ˜¯å¼‚å¸¸, ç„¶åè§†ä¸åŒæƒ…å†µè¿›è¡Œå¤„ç†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
    let cause = scause::read().get_bits(0..15) as u64;
    let epc = sepc::read();
    // println!(&quot;trap: cause: {:#}, epc:{:#x}&quot;, cause, epc);
    let tmp = scause::read().get_bit(63);
    //tmp  åŒºåˆ†ä¸­æ–­è¿˜æ˜¯å¼‚å¸¸
    if tmp == true {
        match cause {
            _ =&gt; println!(&quot;undefined trap!&quot;)
        }
        tf
    }else{
        match cause {
            2 =&gt; {
                println!(&quot;[kernel] IllegalInstruction in application, core dumped.&quot;);
                run_next_app();
            }
            3 =&gt; breakpoint(&amp;mut tf.sepc),
            5 =&gt; super_timer(),
            // 12 =&gt; page_fault(tf),
            // 13 =&gt; page_fault(tf),
            7 | 15 =&gt; {
                println!(&quot;[kernel] PageFault in application, core dumped.&quot;);
                run_next_app();
            }   
            8 =&gt; user_syscall(tf),
            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æœ€ç»ˆå¾—åˆ°é¢„å–ç»“æœ~~</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>++++ setup interrupt! ++++
[kernel] num_app = 3
[kernel] app_0 [0x80210654, 0x802119e4)
[kernel] app_1 [0x802119e4, 0x80212e14)
[kernel] app_2 [0x80212e14, 0x802143ac)
[kernel] Loading app_0
[kernel] Loading app_0 finished
Hello, world!
[kernel] IllegalInstruction in application, core dumped.
[kernel] Loading app_1
[kernel] Loading app_1 finished
Into Test store_fault, we will insert an invalid store operation...
Kernel should kill this application!
[kernel] PageFault in application, core dumped.
[kernel] Loading app_2
[kernel] Loading app_2 finished
3^10000=5079
3^20000=8202
3^30000=8824
3^40000=5750
3^50000=3824
3^60000=8516
3^70000=2510
3^80000=9379
3^90000=2621
3^100000=2749
Test power OK!
[kernel] Application exited with code 0
panicked at 'All applications completed!', src\batch.rs:61:13
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è¿è¡Œåº”ç”¨ç¨‹åºæ€»ç»“</strong></p>
<p><strong>1.ç¼–å†™åº”ç”¨ç¨‹åº</strong></p>
<p>ç¼–å†™ç”¨æˆ·æ€syscall. å°±å¦‚åŒosè°ƒç”¨sbicallç±»ä¼¼!</p>
<p>é€šè¿‡linkeré“¾æ¥è„šæœ¬.æ¥æŒ‡å®šåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<p><strong>2.é“¾æ¥åº”ç”¨ç¨‹åº</strong></p>
<p>.quad æ¥æŒ‡å®šä¸€ä¸ª8å­—èŠ‚åœ°å€</p>
<p>.incbin æ¥è½½å…¥ä¸€ä¸ªæ–‡ä»¶</p>
<p><strong>3.åœ¨å†…æ ¸ä¸­è½½å…¥åº”ç”¨ç¨‹åº</strong></p>
<p>é€šè¿‡from_raw_parts_mut å’Œ copy_from_slice æ¥å®ç°ç±»ä¼¼memcpyåŠŸèƒ½</p>
<p><strong>4.ä¸ºåº”ç”¨ç¨‹åºè®¾ç½®å¥½TrapContext</strong></p>
<p>1.sspè®¾ç½®ä¸ºuser</p>
<p>2.sepcè®¾ç½®ä¸ºåº”ç”¨ç¨‹åºå…¥å£åœ°å€</p>
<p><strong>5.åˆ©ç”¨trapretæ¥æŠŠè®¾ç½®å¥½çš„TrapContextå‹å…¥åˆ°å†…æ ¸æ ˆä¸­</strong></p>
<p><strong>6.ä¸­æ–­ä¸­åŠ å…¥å¯¹ç³»ç»Ÿè°ƒç”¨æ”¯æŒ</strong></p>
<p>1.Environment call from U-mode</p>
<p><strong>7.é€‰æ‹©ä½•æ—¶è¿è¡Œåº”ç”¨ç¨‹åº</strong></p>
<p>è°ƒåº¦å™¨ç›¸å…³.å®éªŒæš‚æ—¶æœªæ¶‰åŠ.åªæ˜¯é€šè¿‡äººä¸ºè§¦å‘å¼‚å¸¸æŒ‡ä»¤æ¥è¿›å…¥ä¸­æ–­,ç„¶ååœ¨ä¸­æ–­å¤„ç†ä¸­è¿è¡Œä¸‹ä¸€ä¸ªåº”ç”¨ç¨‹åº</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ç¬¬ä¸‰ç« </strong></p>
<p><strong>å¤šé“ç¨‹åºæ”¾ç½®ä¸åŠ è½½</strong></p>
<p>å’Œä¸Šä¸€ç« ä¸åŒçš„æ˜¯appå…¶å®åœ°å€è¢«åŠ è½½åˆ°äº†APP_BASE_ADDRESS + app_id * APP_SIZE_LIMITä½ç½®ä¸Š</p>
<p><strong>ä»»åŠ¡åˆ‡æ¢</strong></p>
<p>åœ¨å¤„ç†trapæ—¶.æˆ‘ä»¬éœ€è¦åˆ‡æ¢æˆå†…æ ¸æ ˆ.è€Œåœ¨ç”¨æˆ·ç¨‹åºåˆ‡æ¢æ—¶,æˆ‘ä»¬éœ€è¦åˆ‡æ¢çš„å¦ä¸€ä¸ªç¨‹åºçš„æ ˆ.</p>
<p>å½“å‰ä»»åŠ¡åˆ‡æ¢çš„æœ¬è´¨æ˜¯å‡½æ•°è°ƒç”¨,æˆ‘ä»¬éœ€è¦ä¿å­˜çš„æ˜¯riscvå‡½æ•°è°ƒç”¨è§„å®šä¸­caller-savedçš„å¯„å­˜å™¨.s0~s11</p>
<p>ä¿å­˜å¥½å½“å‰ä»»åŠ¡çš„ä¿¡æ¯å.å¦‚ä½•è¿”å›å½“å‰ä»»åŠ¡ç»§ç»­æ‰§è¡Œ?. åœ¨åšå‡½æ•°åˆ‡æ¢å‰,ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬å§raå¯„å­˜å™¨çš„å€¼æ”¹ä¸º</p>
<p>å‡½æ•°è°ƒç”¨è¿”å›åç¬¬ä¸€æ¡æŒ‡ä»¤çš„åœ°å€. å› æ­¤éœ€è¦ä¿å­˜ra</p>
<p>åˆ‡æ¢åˆ°ç›®æ ‡ä»»åŠ¡. riscvå‡½æ•°è°ƒç”¨ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°åˆ†åˆ«ä¿å­˜åœ¨a0/a1.å› æ­¤ld sp, 0(a1)å³å¯æ¢æ ˆ.</p>
<p>ç„¶åè¯»å–ra s0~s11. </p>
<p><strong>åä½œå¼è°ƒåº¦</strong></p>
<p>æœ‰äº†ä»»åŠ¡åˆ‡æ¢,é‚£ä¹ˆä½•æ—¶è¿›è¡Œåˆ‡æ¢?</p>
<p>ç°åœ¨çš„åšæ³•æ˜¯åº”ç”¨ç¨‹åºä¸»åŠ¨æš‚åœsys_yield ä»¥åŠä¸»åŠ¨é€€å‡ºsys_exit</p>
<p><strong>ä»»åŠ¡ç®¡ç†å™¨</strong></p>
<p>ä¿å­˜äº†å„ä¸ªç¨‹åºåˆ‡æ¢æ—¶æè¿°è‡ªèº«çš„æ ˆä¿¡æ¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskManager {
    num_app: usize,
    inner: RefCell&lt;TaskManagerInner&gt;,
}

struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    current_task: usize,
}

unsafe impl Sync for TaskManager {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆ‡æ¢ä»»åŠ¡</strong></p>
<p>__switchç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è‡ªèº«æ ˆ,ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç›®æ ‡ä»»åŠ¡çš„æ ˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_next_task(&amp;self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.borrow_mut();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr2 = inner.tasks[current].get_task_cx_ptr2();
        let next_task_cx_ptr2 = inner.tasks[next].get_task_cx_ptr2();
        core::mem::drop(inner);
        unsafe {
            __switch(
                current_task_cx_ptr2,
                next_task_cx_ptr2,
            );
        }
    } else {
        panic!(&quot;All applications completed!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>find_next_task.æ‰¾åˆ°çŠ¶æ€ä¸ºTaskStatus::Readyçš„ä»»åŠ¡</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    let inner = self.inner.borrow();
    let current = inner.current_task;
    (current + 1..current + self.num_app + 1)
        .map(|id| id % self.num_app)
        .find(|id| {
            inner.tasks[*id].task_status == TaskStatus::Ready
        })
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åˆ†æ—¶å¤šä»»åŠ¡ç³»ç»Ÿä¸æŠ¢å å¼è°ƒåº¦</strong></p>
<p>æ¯”è¾ƒç®€å•.è®¾ç½®å¥½æ—¶é’Ÿä¸­æ–­, å¹¶åœ¨æ—¶é’Ÿä¸­æ–­å‘ç”Ÿæ—¶run_next_task(),åœ¨trap_handlerä¸­åŠ å…¥ç›¸åº”å¤„ç†å³å¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn trap_handler(tf: &amp;mut TrapContext) -&gt; &amp;mut TrapContext{
.........
        match cause {
.........
            5 =&gt; super_timer(),

            _ =&gt; println!(&quot;undefined Exception!&quot;)
        }
        tf
    }
}


fn super_timer() {
    clock_set_next_event();
    suspend_current_and_run_next();
    unsafe {
        TICKS += 1;
        if TICKS == 100 {
            TICKS = 0;
            println!(&quot;* 100 ticks *&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>chapter3ç»ƒä¹ </strong></p>
<p><strong>stride è°ƒåº¦ç®—æ³•</strong></p>
<p>ä¹‹å‰æ˜¯åœ¨å‘ç”Ÿæ—¶é’Ÿä¸­æ–­æ—¶,é€‰æ‹©ä¸‹ä¸€ä¸ªReadyçŠ¶æ€çš„ç¨‹åºè¿è¡Œ,strideè°ƒåº¦ç®—æ³•å³,ç¨‹åºåˆå§‹strideä¸º0.ä¸ºæ¯ä¸ªç¨‹åºè®¾ç½®ä¸€ä¸ªpass.æ¯æ¬¡ç¨‹åºè¿è¡Œstride+pass. 
å¹¶æ€»æ˜¯é€‰æ‹©strideæœ€å°çš„ç¨‹åºè¿è¡Œ.</p>
<p><strong>å¢åŠ æ•°æ®ç»“æ„</strong></p>
<p>task_pass </p>
<p>task_stride</p>
<p>task_priority </p>
<p>task_time</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    pub current_task: usize,
    pub task_pass:[usize; MAX_APP_NUM],
    pub task_stride:[usize; MAX_APP_NUM],
    pub task_priority:[usize; MAX_APP_NUM],
    pub task_time:[usize; MAX_APP_NUM],
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>å¯»æ‰¾ä¸‹ä¸€ä¸ªæ‰§è¡Œç¨‹åº</strong></p>
<p>1.æ›´æ–°å½“å‰è¿›ç¨‹stride</p>
<p>2.å¯»æ‰¾ä¸‹ä¸€ä¸ªstrideå€¼æœ€å°çš„è¿›ç¨‹</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_next_task(&amp;self) -&gt; Option&lt;usize&gt; {
    //update
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    let priority = inner.task_priority[current];
    if inner.tasks[current].task_status == TaskStatus::Ready {
        inner.task_stride[current] = inner.task_stride[current] + 127 / priority
    }

    let num_app = get_num_app();
    let mut max_stride = 10000000;
    let mut next = 0 as usize;
    for i in 0..num_app{
        let stride_i  = inner.task_stride[i];
        if stride_i &lt;= max_stride  &amp;&amp; inner.tasks[i].task_status != TaskStatus::Exited{
            next = i;
            max_stride =  stride_i;
        }
    }
    let mut  exited_count = 0 as usize;
    for i in 0..num_app{
        
        if inner.tasks[i].task_status == TaskStatus::Exited{
            exited_count += 1;
        }
    }
    if exited_count == num_app{
        println!(&quot;all exited&quot;);
        None
    }else{
        println!(&quot; next min stride  app id{}&quot;, next);
        Some(next)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æ ‡è®°é€€å‡ºè¿›ç¨‹</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mark_current_suspended(&amp;self) {
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.task_time[current] += 1;
    inner.tasks[current].task_status = if inner.task_time[current] &gt;= 500 {
        inner.task_stride[current] = 10000000;
        println!(&quot;app id {}  exited  run out of time&quot;, current);
        TaskStatus::Exited
    } else {
        TaskStatus::Ready
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>é¦–å…ˆæ˜¯id0è¿è¡Œ.id0 exit åˆ‡æ¢åˆ°id3</p>
<p>id3æ‰§è¡Œçš„æ˜¯ä¸»åŠ¨yeildæ‰€ä»¥ç«‹é©¬è¿›è¡Œäº†åˆ‡æ¢</p>
<p>....</p>
<p>all exitedæ‰€ä»¥ç¨‹åºæ‰§è¡Œå®Œæ¯•</p>
<p>ç¨‹åºå¦‚æœŸè¿è¡Œ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OpenSBI v0.7
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 128 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
stext 80200000 etext 8020a000
srodata 8020a000 erodata 80236000
sdata 8023663c edata 8023be49
sbss 8024be50 ebss 8024c058
Hello, world!
base i 0x80400000
base i 0x80420000
base i 0x80440000
base i 0x80460000
load app done
++++ setup timer!     ++++
power_3 [10000/200000]
power_3 [20000/200000]
power_3 [30000/200000]
power_3 [40000/200000]
power_3 [50000/200000]
power_3 [60000/200000]
power_3 [70000/200000]
power_3 [80000/200000]
power_3 [90000/200000]
power_3 [100000/200000]
power_3 [110000/200000]
power_3 [120000/200000]
power_3 [130000/200000]
power_3 [140000/200000]
power_3 [150000/200000]
power_3 [160000/200000]
power_3 [170000/200000]
power_3 [180000/200000]
power_3 [190000/200000]
power_3 [200000/200000]
3^200000 = 871008973
Test power_3 OK!
[kernel] Application exited with code 0
app id 0  exited 
 next min stride  app id3
current 0 start switch to  3
 next min stride  app id2
current 3 start switch to  2
 next min stride  app id1
current 2 start switch to  1
power_5 [10000/140000]
power_5 [20000/140000]
power_5 [30000/140000]
power_5 [40000/140000]
power_5 [50000/140000]
power_5 [60000/140000]
power_5 [70000/140000]
power_5 [80000/140000]
power_5 [90000/140000]
power_5 [100000/140000]
power_5 [110000/140000]
power_5 [120000/140000]
power_5 [130000/140000]
power_5 [140000/140000]
5^140000 = 386471875
Test power_5 OK!
[kernel] Application exited with code 0
app id 1  exited 
 next min stride  app id3
current 1 start switch to  3
Test sleep OK!
[kernel] Application exited with code 0
app id 3  exited 
 next min stride  app id2
current 3 start switch to  2
power_7 [10000/160000]
power_7 [20000/160000]
power_7 [30000/160000]
power_7 [40000/160000]
power_7 [50000/160000]
power_7 [60000/160000]
power_7 [70000/160000]
power_7 [80000/160000]
power_7 [90000/160000]
power_7 [100000/160000]
power_7 [110000/160000]
power_7 [120000/160000]
power_7 [130000/160000]
power_7 [140000/160000]
power_7 [150000/160000]
power_7 [160000/160000]
7^160000 = 667897727
Test power_7 OK!
[kernel] Application exited with code 0
app id 2  exited 
all exited
panicked at 'All applications completed!', src\task\mod.rs:149:13
93
panicked at 'It should shutdown!', src\sbi.rs:45:5

<span class="boring">}
</span></code></pre></pre>
<p><strong>ch3repo</strong></p>
<p>1:è¿™ä¸€ç« ç”±åº”ç”¨ç¨‹åºä¸»åŠ¨yeild exit æˆ–è€…è¶…æ—¶ æ¥è§¦å‘ä¸­æ–­. ç„¶åç”±traphandlerè¿›è¡Œå¤„ç†å¹¶è¿è¡Œä¸‹ä¸€ä¸ªç¨‹åº...æœ¬è´¨ä¸Šæ²¡æœ‰è°ƒåº¦ç­–ç•¥..</p>
<p>2:(1)æœ¬è´¨ä¸Šéƒ½æ˜¯RRç®—æ³•
(2) p1 -&gt; p2 -&gt; p3 -&gt; p1ç»“æŸ -&gt;p2å¼€å§‹-&gt;p4äº§ç”Ÿ-&gt;p2ç»“æŸ-&gt;p3å¼€å§‹-&gt;p5äº§ç”Ÿ-&gt;p3ç»“æŸ-&gt;p5å¼€å§‹</p>
<p>æˆ‘çš„ç®—æ³•ä¸‹strideç›¸åŒæ—¶é€‰æ‹©TIDè¾ƒå°çš„è¿è¡Œ,å› ä¸ºæ˜¯ç¬¬ä¸€ä¸ªé€‰ä¸­çš„.</p>
<p>3:
å‚è€ƒhttps://piazza.com/class/i5j09fnsl7k5x0?cid=357</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>åœ°å€ç©ºé—´</strong></p>
<p><strong>ç‰©ç†å†…å­˜</strong></p>
<p>ç‰©ç†å†…å­˜é¡µå¼ç®¡ç†</p>
<p>å¯¹äºç‰©ç†å†…å­˜çš„é¡µå¼ç®¡ç†è€Œè¨€ï¼Œæˆ‘ä»¬æ‰€è¦æ”¯æŒçš„æ“ä½œæ˜¯ï¼š</p>
<p>åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œè¿”å›å…¶ç‰©ç†é¡µå·ï¼›</p>
<p>ç»™å®šä¸€ä¸ªç‰©ç†é¡µå·ï¼Œå›æ”¶å…¶å¯¹åº”çš„ç‰©ç†é¡µã€‚</p>
<p>ç»™å®šä¸€ä¸ªé¡µå·åŒºé—´è¿›è¡Œåˆå§‹åŒ–ã€‚</p>
<p>è¿™é‡Œç”¨æœ€ç®€å•çš„æ–¹å¼å®ç°</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Allocator {
    a: [u8; MAX_PHYSICAL_PAGES],
    offset: usize,
    total:usize
}

impl Allocator {
    // ç»™å®šä¸€ä¸ªé¡µå·åŒºé—´è¿›è¡Œåˆå§‹åŒ–ã€‚
    pub fn init(&amp;mut self, l:usize, r:usize) {
        self.offset = l - 1;
        self.total = r - l;
        // let size = r - l;

        //0è¡¨ç¤ºç©ºé—²
        for i in 0..self.total {
            self.a[i] = 0;
        }
    }

    // // ç»™å®šç‰©ç†åœ°å€ åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œè¿”å›å…¶ç‰©ç†é¡µå·ï¼›
    pub fn alloc(&amp;mut self) -&gt; usize {
        //è®¾ç½®ä¸€ä¸ªåˆ†é…æˆåŠŸæ ‡å¿—
        let mut flag = 0;

        //è¿”å›åˆ†é…çš„ç‰©ç†é¡µå·
        let mut result = 0;
        for i in 0..MAX_PHYSICAL_PAGES-1 {
            if self.a[i] == 0 {
                self.a[i] = 1;
                flag = 1;
                result = i;
                return result;
            }
        }
        if flag == 0 {
            panic!(&quot;physical memory depleted!&quot;);
        }
        result
    }

    //å›æ”¶ç‰©ç†é¡µå·ä¸ºnçš„ç‰©ç†é¡µ
    pub fn dealloc(&amp;mut self, n: usize) {

        let p = n;
        if p &gt;= MAX_PHYSICAL_PAGES {
            panic!(&quot;éæ³•ç‰©ç†é¡µå·&quot;)
        }
        self.a[p] = 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>åŠ¨æ€å†…å­˜åˆ†é…</strong></p>
<p>å®ç° Trait GlobalAlloc</p>
<p>ç”¨å†™å¥½çš„åº“ å¹¶æŠŠå®ƒæ ‡è®°ä¸º #[global_allocator]</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use buddy_system_allocator::LockedHeap;

#[global_allocator]
static DYNAMIC_ALLOCATOR: LockedHeap = LockedHeap::empty();

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>rv39é¡µè¡¨</strong></p>
<p><strong>åˆ†æé¡µè¡¨éœ€è¦æ”¯æŒçš„æ“ä½œ</strong></p>
<p>1.æ–°å»ºä¸€ä¸ªé¡µè¡¨(åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå¸§,å¹¶æŠŠè¯¥é¡µå¸§ä½œä¸ºé¡µè¡¨çš„åŸºå€)</p>
<p>2.map unmap ä¸ºä¸€å¯¹va å’Œ pa å»ºç«‹æ˜ å°„</p>
<p>3.æ‰¾åˆ°é¡µè¡¨é¡¹</p>
<p><strong>ç»™å®šæŸvaå»ºç«‹æ˜ å°„çš„è¿‡ç¨‹:</strong></p>
<p><strong>1.æ‰¾åˆ°root_table</strong></p>
<p><strong>2.åœ¨ä¸‰çº§é¡µè¡¨ä¸­æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„é¡µè¡¨é¡¹.æ ¹æ®é¡µè¡¨é¡¹æ¥æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„åœ°å€</strong></p>
<p>å¦‚æœé¡µè¡¨é¡¹æœªè¢«è®¾ç½®. åˆ™åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå¸§, å¹¶æŠŠè¯¥ç‰©ç†é¡µå¸§å¡«å†™åˆ°é¡µè¡¨é¡¹å¹¶è®¾ç½®æ ‡è®°ä½(å³ä»¥åèƒ½é€šè¿‡æ­¤é¡µè¡¨é¡¹æ‰¾åˆ°äºŒçº§é¡µè¡¨çš„åœ°å€äº†)</p>
<p>åªéœ€å¡«å†™validä½.å› ä¸ºå®ƒæŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨</p>
<p>å…¶ä¸­p1_index  p2_index p3_index åˆ†åˆ«ä¸º </p>
<p>è™šæ‹Ÿåœ°å€vaçš„12..21    21 .. 30  30..39 ä½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p3_index = page.p3_index();
let p2_index = page.p2_index();
let p1_index = page.p1_index();

let p2_table = if self.root_table.entries[p3_index].is_unused() {
    let frame = alloc_frame().unwrap();
    self.root_table.entries[p3_index].set(frame, EF::VALID);
    let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
    p2_table.zero();
    p2_table
} else {
    let frame = self.root_table.entries[p3_index].frame();
    unsafe { frame.as_kernel_mut() }
};
<span class="boring">}
</span></code></pre></pre>
<p>è¿™é‡Œéœ€è¦ä¸€ä¸ªæŠŠé¡µè¡¨é¡¹ä¸­çš„åœ°å€è§£æå‡ºæ¥å¹¶å½“æˆé¡µè¡¨çš„æ“ä½œ</p>
<p>(pte &gt;&gt; 10 )  &lt;&lt; 12  +  PHYSICAL_MEMORY_OFFSET</p>
<p>é¡µè¡¨é¡¹å³ç§»10ä½æ¥å¾—åˆ°ç‰©ç†é¡µå·. ä¸€ä¸ªç‰©ç†é¡µå¸§ä¸º4k. å†å·¦ç§»12ä½æ¥å¾—åˆ°ç‰©ç†åœ°å€</p>
<p>å¦‚æœæœ‰è®¾ç½®åç§»åˆ™åŠ ä¸ŠPHYSICAL_MEMORY_OFFSET</p>
<p>è¿™æ ·å°±å¾—åˆ°äº†é¡µè¡¨æ‰€åœ¨çš„ç‰©ç†åœ°å€</p>
<p>rustå†™æ³•æœ‰ä¸¤ç§</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_page_table(&amp;self) -&gt; *mut PageTable {
    ((self.data &gt;&gt; 10) &lt;&lt; 12) as *mut PageTable
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame = self.root_table.entries[p3_index].frame();
pub unsafe fn as_page_table&lt;'a, 'b, T&gt;(&amp;'a self) -&gt; &amp;'b mut T {
    &amp;mut *(    ((self.0).0 + PHYSICAL_MEMORY_OFFSET)   as *mut T  )
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>3.ç„¶åå°±æ˜¯é‡å¤ä¸Šè¿°æ“ä½œ</strong></p>
<p><strong>åœ¨äºŒçº§é¡µè¡¨ä¸­æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹, æ ¹æ®é¡µè¡¨é¡¹æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„åœ°å€</strong></p>
<p>å¦‚æœä¸å­˜åœ¨åˆ™åˆ†é…ç‰©ç†é¡µå¸§,å¡«å†™æ ‡å¿—</p>
<p><strong>æœ€ç»ˆåœ¨ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„é¡µè¡¨é¡¹,æŠŠå¯¹åº”çš„ç‰©ç†é¡µå·å¡«å†™è¿›å»å°±å®Œæˆäº†æ˜ å°„</strong></p>
<p><strong>é‚£ä¹ˆæˆ‘ä»¬è¯¥å¡«å†™ä»€ä¹ˆç‰©ç†é¡µå·è¿›å»å‘¢?</strong> è¿™é‡Œå°±æ¯”è¾ƒéšæ„äº†</p>
<ol>
<li>
<p>å¯ä»¥é‡‡ç”¨ä¸€ä¸ªå›ºå®šçš„åç§» pa = va +  PHYSICAL_MEMORY_OFFSET</p>
</li>
<li>
<p>å¯ä»¥é‡‡ç”¨ä¹‹å‰å†™å¥½çš„ç‰©ç†å†…å­˜åˆ†é…å™¨åˆ†é…ä¸€ä¸ªç‰©ç†é¡µå·</p>
</li>
<li>
<p>...</p>
</li>
</ol>
<p>å®Œæ•´ç‰ˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_pte_create(&amp;mut self, va:usize) -&gt; Option&lt;&amp;mut PageTableEntry&gt; {
    let page = Page::of_addr(VirtAddr::new(va));
    let p3_index = page.p3_index();
    let p2_index = page.p2_index();
    let p1_index = page.p1_index();
    //æ‰¾åˆ°äºŒçº§é¡µè¡¨
    let p2_table = if self.root_table.entries[p3_index].is_unused() {
        let frame = alloc_frame().unwrap();
        self.root_table.entries[p3_index].set(frame, EF::VALID);
        let p2_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p2_table.zero();
        p2_table
    } else {
        let frame = self.root_table.entries[p3_index].frame();
        unsafe { frame.as_kernel_mut() }
    };
    //æ‰¾åˆ°ä¸€çº§é¡µè¡¨
    let p1_table = if p2_table.entries[p2_index].is_unused() {
        let frame = alloc_frame().unwrap();
        p2_table.entries[p2_index].set(frame, EF::VALID);
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table.zero();
        p1_table
    } else {
        let frame = p2_table.entries[p2_index].frame();
        let p1_table: &amp;mut PageTable = unsafe { frame.as_kernel_mut() };
        p1_table
    };
    //åœ¨ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”é¡µè¡¨é¡¹
    let p1_entry = Some (&amp;mut p1_table.entries[p1_index]);
    p1_entry
}
<span class="boring">}
</span></code></pre></pre>
<p>å»ºç«‹æ˜ å°„</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map(&amp;mut self, va:usize, frame: Frame, ptflags: PageTableFlags) {
    let pte = self.find_pte_create(va).unwrap();
    if !pte.is_unused(){
        println!(&quot;pte {:?} already mapped&quot;, pte);
    }
    pte.set(frame, ptflags);
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
}

pub fn unmap(&amp;mut self, va:usize) {
    let pte = self.find_pte(va).unwrap();
    pte.set_unused();
    let page = Page::of_addr(VirtAddr::new(va));
    unsafe {llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;)};
    MapperFlush::flush(page);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>debug</strong></p>
<p>pa = va - 0xffffffff40000000</p>
<p>å…¶ä¸­p1_index p2_index p3_index åˆ†åˆ«ä¸º è™šæ‹Ÿåœ°å€vaçš„  12..21  å’Œ 21..30 å’Œ 30..39 ä½</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>satp :0x8000000000080a2b                 å¯¹åº”ç‰©ç†åœ°å€:0x80a2b000
p3_indexä¸º511                       ç¬¬511é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2bff8
0x80a2bff8å¤„å†…å­˜æ˜¾ç¤º 0x000000002028b0c5(é¡µè¡¨é¡¹)
(0x000000002028b0c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2c000
                                             ç‰©ç†åœ°å€ = 0x80a2c000


å¾—åˆ°äºŒçº§é¡µè¡¨è™šæ‹Ÿåœ°å€ 0xffffffffc0a2c000   å¯¹åº”ç‰©ç†åœ°å€:0x80a2c000
p2_indexä¸º1                            ç¬¬1é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2c008
0x80a2c008å¤„å†…å­˜æ˜¾ç¤º 0x000000002028b4c5(é¡µè¡¨é¡¹)
(0x000000002028b4c5 &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0a2d000
                                             ç‰©ç†åœ°å€ = 0x80a2d000


å¾—åˆ°ä¸€çº§é¡µè¡¨è™šæ‹Ÿåœ°å€ 0xffffffffc0a2d000   å¯¹åº”ç‰©ç†åœ°å€:0x80a2d000
p1_indexä¸º2                            ç¬¬2é¡¹åœ¨ç‰©ç†åœ°å€:0x80a2d010
0x80a2d010å¤„å†…å­˜æ˜¾ç¤º 0x00000000200808cf(é¡µè¡¨é¡¹)
(0x00000000200808cf &gt;&gt; 10) &lt;&lt; 12 + 0xffffffff40000000 = 0xffffffffc0202000
                                             ç‰©ç†åœ°å€ = 0x80202000
<span class="boring">}
</span></code></pre></pre>
<p>gdbæ˜¾ç¤ºç‰©ç†å†…å­˜  maintenance packet Qqemu.PhyMemMode:1</p>
<p>x/10xg $addr  ä»¥64ä½ä¸€ä¸ªå•å…ƒæ¥æ˜¾ç¤ºæŸåœ°å€å†…å­˜ä¸­å†…å®¹.</p>
<p><strong>é¡µè¡¨å»ºç«‹è¿‡ç¨‹ä¸­æœ‰å¯èƒ½å‡ºé”™çš„åœ°æ–¹:</strong></p>
<p>1.æŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹æ ‡å¿—ä½è®¾ç½®é”™! (åº”ä¸¥æ ¼æŒ‰ç…§riscvæ‰‹å†Œä¸­æŒ‡ç¤ºçš„æŒ‡å‘ä¸‹ä¸€çº§é¡µè¡¨çš„æ ‡å¿—ä½è®¾ç½®æ–¹å¼...å¦åˆ™è¯¥é¡µå°±ä¼šè¢«å½“åˆæ™®é€šé¡µ)..è¿™æ—¶debugä¼šå‘ç°ç»™å®švaæ‰‹åŠ¨ç®—æ€»èƒ½åœ¨æœ€åæ‰¾åˆ°ç›¸åº”çš„ç‰©ç†é¡µå¸§! ä½†æ˜¯ç¨‹åºæ²¡æ³•è¿è¡Œ</p>
<p><strong>rustå°ç¨‹åºè¾…åŠ©è®¡ç®—é¡µè¡¨ç›¸å…³ä¿¡æ¯</strong></p>
<p>å‡è®¾ pa = va - 0xffffffff40000000</p>
<pre><pre class="playground"><code class="language-rust">use bit_field::*;

pub fn next_level(pte:usize)  -&gt; usize {
    let next_level_va = ((pte &gt;&gt;10)&lt;&lt;12) + 0xffffffff40000000 as usize;
    println!(&quot;next level va 0x{:x}&quot;, next_level_va);
    println!(&quot;next level pa level 0x{:x}&quot;, next_level_va - 0xffffffff40000000 as usize);

    next_level_va
}

pub fn va_to_pa(va:usize){
    println!(&quot;pa {:x}&quot;, va - 0xffffffff40000000);
}

pub fn page_index(va:usize){
    println!(&quot;p1_index {:?}  p2_index {:?}  p3_index {:?}&quot;, va.get_bits(12..21), va.get_bits(21..30), va.get_bits(30..39) );
}

pub fn p1_entry(va:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p2_entry = (satp + 8*va.get_bits(12..21)) as usize ;
    println!(&quot;p1_entry {:x}&quot;, p1_entry);
    p2_entry
}

pub fn p2_entry(va:usize, p1_table:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p2_entry = (p1_table + 8*va.get_bits(21..30)) as usize ;
    println!(&quot;p2_entry {:x}&quot;, p2_entry);

    p2_entry
}


pub fn p3_entry(va:usize: p2_table:usize) -&gt; usize{
    let satp = 0x80a2a000 as usize;
    let p3_entry = (p2_table + 8*va.get_bits(30..39)) as usize ;
    println!(&quot;p3_entry {:x}&quot;, p3_entry);

    p3_entry
}

fn main() {
    let va = 0xffffffffc02058de;
    page_index(va);
    

    p1_entry = p1_entry(0xffffffffc02058de);
    p2_table = next_level(p1_entry);

    p2_entry = p2_entry(0xffffffffc02058de, p2_table);
    p3_table = next_level(p2_entry);

    p3_entry = p1_entry(0xffffffffc02058de, p3_table);

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch4</strong></p>
<p><strong>å®ç°mmap</strong></p>
<p>å¾ˆç®€å•...åŒ…è£…ä¸€ä¸‹memory_setä¸­insert_framed_area...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_mmap(start: usize, len: usize, port: usize) -&gt; isize {
    let mut permission = MapPermission::U;
    if port &amp; 0x1 != 0 {
        permission |= MapPermission::R;
    }
    if port &amp; 0x2 != 0 {
        permission |= MapPermission::W;
    }
    if port &amp; 0x4 != 0 {
        permission |= MapPermission::X;
    }

    let end = VirtAddr::from(VirtAddr(start + len));
    match insert_framed_area(start.into(), end, permission) {
        Ok(_) =&gt; (end.0 - start) as isize,
        Err(_) =&gt; -1,
    }
}

pub fn insert_framed_area(start: VirtAddr, end: VirtAddr, permission: MapPermission,){
    TASK_MANAGER.mmap(start, end, permission);
}

fn mmap(&amp;self, start: VirtAddr, end: VirtAddr,permission: MapPermission ){
    let mut inner = self.inner.borrow_mut();
    let current = inner.current_task;
    inner.tasks[current].memory_set.insert_framed_area(start, end, permission);
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch5repo</strong></p>
<p><strong>å®ç°sys_spawn</strong></p>
<p><strong>ç”±äºtutoriä¸­æ²¡æœ‰å®ç°å†…æ ¸çº¿ç¨‹(è¿›ç¨‹). æ‰€ä»¥åªèƒ½ä»å½“å‰è¿›ç¨‹ä¸­forkå‡ºæ¥.å†æ‰§è¡Œ.</strong></p>
<p>æ‹¿åˆ°åº”ç”¨ç¨‹åºåå­— -&gt; ä»app_nameè·å–åº”ç”¨ç¨‹åºåœ°å€ -&gt; get_app_data_by_name æ¥å£ä¸­æ‰¾åˆ°å¯¹åº”çš„ELFæ•°æ®</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_spawn(path: *const u8) -&gt; isize {
    let path = translated_str(current_user_token(), path);
    if let Some(data) = get_app_data_by_name(path.as_str()) {
        let new_task = current_task().unwrap().fork();
        new_task.exec(data);
        let new_pid = new_task.pid.0;
        add_task(new_task);
        new_pid as isize
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>æ•´ç†ä¹‹å‰ä»£ç </strong></p>
<p>æŠŠç”¨æˆ·ç¨‹åºå’Œosæ”¾ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸‹ç®¡ç†. é…ç½®vscode. ç¼–å†™pythonè„šæœ¬</p>
<p>åœ¨ä¸»ç›®å½•ä¸‹è¿è¡Œpython app_build.py æ¥ç”Ÿæˆç”¨æˆ·ç¨‹åº,é“¾æ¥è„šæœ¬</p>
<p><strong>app_build.py</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import os
os.system('cd user &amp;&amp; cargo clean')
os.system('cd user &amp;&amp; python ./build.py')
os.system('cd user &amp;&amp; python ./objdump.py')
os.system('cd user &amp;&amp; python ./linker.py')
<span class="boring">}
</span></code></pre></pre>
<p><strong>build.py</strong></p>
<pre><code>import os
os.system('cd os &amp;&amp; cargo build')
os.system('cd os &amp;&amp; rust-objcopy target/riscv64gc-unknown-none-elf/debug/os --strip-all -O binary target/riscv64gc-unknown-none-elf/debug/kernel.bin')
</code></pre>
<p>é…åˆvscode</p>
<p><strong>launch.json</strong></p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;launch&quot;,
            &quot;type&quot;: &quot;cppvsdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;qemu-system-riscv64.exe&quot;,
            &quot;args&quot;: [
                &quot;-machine&quot;,
                &quot;virt&quot;,
                &quot;-nographic&quot;,
                &quot;-no-reboot&quot;,
                &quot;-bios&quot;,
                &quot;default&quot;,
                &quot;-device&quot;,
                &quot;loader,file=${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/kernel.bin,addr=0x80200000&quot;,
            ],
            &quot;preLaunchTask&quot;: &quot;python&quot;,
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
        },        
        {
            &quot;name&quot;: &quot;launch-qemu&quot;,
            &quot;type&quot;: &quot;cppvsdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;qemu-system-riscv64.exe&quot;,
            &quot;args&quot;: [
                &quot;-machine&quot;,
                &quot;virt&quot;,
                &quot;-nographic&quot;,
                &quot;-no-reboot&quot;,
                &quot;-bios&quot;,
                &quot;default&quot;,
                &quot;-device&quot;,
                &quot;loader,file=${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/kernel.bin,addr=0x80200000&quot;,
                &quot;-s&quot;,
                &quot;-S&quot;
            ],
            &quot;preLaunchTask&quot;: &quot;copy&quot;,
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,
        },
        {
            &quot;name&quot;: &quot;qemu&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;miDebuggerServerAddress&quot;: &quot;127.0.0.1:1234&quot;,
            &quot;miDebuggerPath&quot;: &quot;D:/riscv64-unknown-elf-gcc-w64/bin/riscv64-unknown-elf-gdb.exe&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/os/target/riscv64gc-unknown-none-elf/debug/os&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;logging&quot;: {
                &quot;engineLogging&quot;: false
            },
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Add gdbinit&quot;,
                    &quot;text&quot;: &quot;-interpreter-exec console \&quot;source -v D:/os/os/.gdbinit\&quot;&quot;
                }
            ]
        },

    ]
}
</code></pre>
<p><strong>tasks.json</strong></p>
<pre><code class="language-json">{
	&quot;version&quot;: &quot;2.0.0&quot;,
	&quot;tasks&quot;: [
		{
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;python&quot;,
			&quot;command&quot;:&quot;python ./build.py&quot;,
		},
        {
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;build&quot;,
			&quot;command&quot;:&quot;cargo build&quot;
		},
		{
			&quot;type&quot;: &quot;shell&quot;,
			&quot;label&quot;: &quot;copy&quot;,
			&quot;command&quot;:&quot;rust-objcopy target/riscv64gc-unknown-none-elf/debug/os --strip-all -O binary target/riscv64gc-unknown-none-elf/debug/kernel.bin&quot;,
			&quot;dependsOn&quot;:[&quot;build&quot;]
		}
	]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ch6</strong></p>
<p>è®¾è®¡mail. ç°åœ¨éœ€è¦ä¸€ä¸ªæ‰€æœ‰è¿›ç¨‹å…±äº«çš„æ•°æ®ç»“æ„.å‚è€ƒKERNEL_STACK.è®¾ç½®ä¸€ä¸ªå…¨å±€çš„æ•°æ®ç»“æ„æ¥æ¥ç®¡ç†é‚®ç®±</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mails(pub VecDeque&lt;Vec&lt;u8&gt;&gt;);

åœ¨æ²¡æœ‰å¤šæ ¸çš„æƒ…å†µä¸‹.ä¸éœ€è¦æä¾›äº’æ–¥è®¿é—®.æ‰€ä»¥ä¸éœ€è¦ç”¨ç±»ä¼¼Arc&lt;Mutex&lt;T&gt;&gt;çš„æ–¹æ³•

å’ŒKernelStackä¸€æ ·æŠŠMailsæ”¾åœ¨TaskControlBlockä¸­

<span class="boring">}
</span></code></pre></pre>
<p>è¯»</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn readable(&amp;self) -&gt; bool {
    self.0.len() &gt; 0
}

pub fn read(&amp;mut self, buf: UserBuffer) -&gt; usize {
    let mut buf_iter = buf.into_iter();
    let mut read_size = 0usize;
    let mail = self.0.pop_front().unwrap();
    for c in mail {
        if let Some(byte_ref) = buf_iter.next() {
            unsafe { *byte_ref = c; }
            read_size += 1;
        } else {
            break;
        }
    }
    read_size
}
<span class="boring">}
</span></code></pre></pre>
<p>å†™</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn writable(&amp;self) -&gt; bool {
    self.0.len() &lt; MAX_MAILS_NUM
}

pub fn write(&amp;mut self, buf: UserBuffer) -&gt; usize {
    let mut write_size = 0usize;
    let mut mail: Vec&lt;u8&gt; = Vec::new();
    for c in buf {
        unsafe{ mail.push(*c); }
        write_size += 1;
    }
    self.0.push_back(mail);
    write_size
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ch7</strong></p>
<p><strong>æ–‡ä»¶ç³»ç»Ÿ</strong></p>
<p>æ–‡ä»¶ç³»ç»Ÿçš„å‡ ä¸ªç»„è¦éƒ¨åˆ†:</p>
<p>1.ç£ç›˜ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿ</p>
<p>2.ç£ç›˜å—,åœ¨bufferä¸­çš„ç£ç›˜å—</p>
<p>3.å†…å­˜ä¸­çš„buffer</p>
<p>(è¯»å†™æ–‡ä»¶ç³»ç»Ÿ: å¦‚æœç£ç›˜å—åœ¨å†…å­˜bufferä¸­,å°±æ˜¯ç›´æ¥è¯»å†™å†…å­˜, å¦‚æœç£ç›˜å—ä¸åœ¨bufferä¸­åˆ™éœ€è°ƒç”¨é©±åŠ¨ç›´æ¥è¯»å†™ç£ç›˜å¹¶å¡«å…¥bufferä¸­.)</p>
<p>4.osä¸Šçš„å…·ä½“æ–‡ä»¶ç³»ç»Ÿ</p>
<p>5.osä¸­çš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ. åŒ…è£…å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿ</p>
<p>6.æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨.  å¯é‡‡ç”¨ramdisk.ç”¨å†…å­˜ä¸­çš„ä¸€æ®µåŒºé—´æ¥æ¨¡æ‹Ÿç£ç›˜.</p>
<p><strong>sys_open</strong></p>
<p>è°ƒç”¨ä¸€ä¸‹open_file.è®¾ç½®æ ‡è®°ä½.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_open(path: *const u8, flags: u32) -&gt; isize {
    let task = current_task().unwrap();
    let token = current_user_token();
    let path = translated_str(token, path);
    if let Some(inode) = open_file(
        path.as_str(),
        OpenFlags::from_bits(flags).unwrap()
    ) {
        let mut inner = task.acquire_inner_lock();
        let fd = inner.alloc_fd();
        inner.fd_table[fd] = Some(inode);
        fd as isize
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>linkat</strong></p>
<p>åŸºæœ¬å’Œcreateä¸€æ ·,åªä¸è¿‡createéœ€è¦allocä¸€ä¸ªinode.è¿™é‡Œéœ€è¦æ‰¾åˆ°inode</p>
<p>è°ƒç”¨find_inode_idæ‰¾åˆ°inode_id.</p>
<p>æ¥ä¸‹æ¥å‚è€ƒInode::create()ä¸­çš„å†™æ³•. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.modify_disk_inode(|root_inode| {
    // append file in the dirent
    let file_count = (root_inode.size as usize) / DIRENT_SZ;
    let new_size = (file_count + 1) * DIRENT_SZ;
    // increase size
    self.increase_size(new_size as u32, root_inode, &amp;mut fs);
    // write dirent
    let dirent = DirEntry::new(name, new_inode_id);
    root_inode.write_at(
        file_count * DIRENT_SZ,
        dirent.as_bytes(),
        &amp;self.block_device,
    );
});
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.linkat(|root_inode| {
    let file_count = (root_inode.size as usize) / DIRENT_SZ;
    let new_size = (file_count + 1) * DIRENT_SZ;
    self.increase_size(new_size as u32, root_inode, &amp;mut fs);
    let dirent = DirEntry::new(new_name, inode_id);
    root_inode.write_at(
        file_count * DIRENT_SZ,
        dirent.as_bytes(),
        &amp;self.block_device,
    );
});
<span class="boring">}
</span></code></pre></pre>
<p><strong>unlinkat</strong></p>
<p>å’Œlså¾ˆåƒ.lséœ€è¦åˆ—ä¸¾ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶. unlinkatä¹Ÿéœ€è¦éå†ç›®å½•æ¥æ‰¾åˆ°æŒ‡å®šæ–‡ä»¶</p>
<p>ls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ls(&amp;self) -&gt; Vec&lt;String&gt; {
    let _fs_lock = self.fs.lock();
    self.read_disk_inode(|disk_inode| {
        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
        let mut v: Vec&lt;String&gt; = Vec::new();
        for i in 0..file_count {
            let mut dirent = DirEntry::empty();
            assert_eq!(
                disk_inode.read_at(
                    i * DIRENT_SZ,
                    dirent.as_bytes_mut(),
                    &amp;self.block_device,
                ),
                DIRENT_SZ,
            );
            if dirent.inode_number() != 0 {
                v.push(String::from(dirent.name()));
            }
        }
        v
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>unlinkat</p>
<p>å¦‚æœæ–‡ä»¶å==name,åˆ™æŠŠå½“å‰æ–‡ä»¶å†™ç©º.æ¥å®ç°unlink....</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn unlinkat(&amp;self, name: &amp;str) -&gt; isize {
    let file_remove = |disk_inode: &amp;mut DiskInode| {
        let file_count = (disk_inode.size as usize) / DIRENT_SZ;
        let mut dirent = DirEntry::empty();
        for i in 0..file_count {

            disk_inode.read_at(DIRENT_SZ * i, dirent.as_bytes_mut(), &amp;self.block_device);

            if dirent.name() == name {
                disk_inode.write_at(
                    DIRENT_SZ * i,
                    DirEntry::empty().as_bytes_mut(),
                    &amp;self.block_device,
                );
                return 0;
            }
        }
        -1
    };
    self.modify_disk_inode(file_remove)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>æ•´ç†</strong></p>
<p>user-shell</p>
<p>æˆ‘ä»¬é¦–å…ˆè¦èƒ½å¤Ÿé€šè¿‡é”®ç›˜å‘ç»ˆç«¯ç¨‹åºä¸­è¾“å…¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦å®ç°ä¸€ä¸ªç”¨æˆ·ç¨‹åºï¼Œå®ƒèƒ½å¤Ÿæ¥å—é”®ç›˜çš„è¾“å…¥ï¼Œå¹¶å°†é”®ç›˜è¾“å…¥çš„å­—ç¬¦æ˜¾ç¤ºåœ¨å±å¹•ä¸Š</p>
<p>è¿™ä¸ªç”¨æˆ·ç¨‹åºéœ€è¦çš„åŠŸèƒ½æ˜¯ï¼šæ¥å—é”®ç›˜è¾“å…¥ï¼ˆå¯ä»¥è¢«ç§°ä¸ºâ€œæ ‡å‡†è¾“å…¥â€ï¼‰çš„ä¸€ä¸ªå­—ç¬¦ã€‚</p>
<p>éœ€è¦ sys_read    ä»¥åŠç”¨æˆ·ç¨‹åºèƒ½è°ƒç”¨çš„getchar()</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// usr/rust/src/syscall.rs

enum SyscallId {
    Read = 63,
}

pub fn sys_read(fd: usize, base: *const u8, len: usize) -&gt; i64 {
    sys_call(SyscallId::Read, fd, base as usize, len, 0)
}

åŒ…è£…ä¸‹sys_read

pub fn getchar() -&gt; u8 {
    let mut c = [0u8; 1];
    read(STDIN, &amp;mut c);
    c[0]
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>æœ‰äº†getchar()æ”¯æŒ æˆ‘ä»¬å°±å¯ä»¥ç”¨ä¸€ä¸ªloopæ¥å¾ªç¯è·å¾—è¾“å…¥</strong></p>
<p>è¿™ä¸ªè¾“å…¥å­˜åœ¨å“ªé‡Œ?</p>
<p>è¿™æ—¶å°±éœ€è¦ç”¨æˆ·ç¨‹åºçš„åŠ¨æ€å†…å­˜åˆ†é…. å’Œoså†…æ ¸ä¸­ä½¿ç”¨çš„ä¸€æ ·,ä½¿ç”¨å·²ç»å†™å¥½çš„åº“buddy_system_allocator</p>
<p>è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç”¨Stringæ•°æ®ç»“æ„æ¥å­˜è·å¾—çš„è¾“å…¥</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut line: String = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><strong>åœ¨æœ‰äº†ä¸Šé¢çš„æ”¯æŒå,éœ€è¦åšçš„å°±æ˜¯åŒ¹é…è¾“å…¥,ç„¶åè°ƒç”¨execæ¥è¿è¡Œä¸åŒçš„ç¨‹åº</strong></p>
<p>é‡‡ç”¨matchæ¥åŒ¹é…</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() -&gt; i32 {
    println!(&quot;Rust user shell&quot;);
    let mut line: String = String::new();
    print!(&quot;&gt;&gt; &quot;);
    loop {
        let c = getchar();
        match c {

        }
    }
}
</code></pre></pre>
<table><tr><td bgcolor=#EFF5FF>
æ¥ä¸‹æ¥è¦åšçš„å°±æ˜¯ä½¿ç”¨exec("ç”¨æˆ·ç¨‹åºå")æ¥è¿è¡Œä¸åŒç¨‹åº
<p>è¿™è¦æ±‚execèƒ½å¤Ÿæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²,å¹¶è½½å…¥æŒ‡å®šåº”ç”¨ç¨‹åºå¹¶è¿è¡Œ</p>
<p>ç”±äºç³»ç»Ÿè°ƒç”¨ä¸æ”¯æŒä¼ å…¥æ•´ä¸ªå­—ç¬¦ä¸².åªèƒ½ä¼ å…¥å­—ç¬¦ä¸²çš„åœ°å€,ä½†æ˜¯è¿™ä¸ªåœ°å€åˆæ˜¯åœ¨ç”¨æˆ·ç¨‹åºçš„é¡µè¡¨ä¸‹çš„(é‡‡ç”¨äº†åŒé¡µè¡¨è®¾è®¡,å†…æ ¸ç©ºé—´æ— æ³•è®¿é—®ç”¨æˆ·ç©ºé—´,å¦‚æœæ˜¯å•é¡µè¡¨ä¸‹å†…æ ¸å’Œç”¨æˆ·ä½¿ç”¨åŒä¸€ä¸ªé¡µè¡¨,å¯ä»¥ç›´æ¥è·å¾—å­—ç¬¦ä¸²).æ‰€ä»¥éœ€è¦åœ¨å†…æ ¸ä¸­è·å–ç”¨æˆ·ç¨‹åºçš„satp,å¹¶ä¸”æ‰‹åŠ¨æŸ¥é¡µè¡¨æ¥è·å–å­—ç¬¦ä¸².</p>
<p>è·å–åº”ç”¨åä¹‹å,å¦‚ä½•åœ¨å†…æ ¸ç©ºé—´è½½å…¥app_dataå‘¢? ç›¸æ¯”ä¹‹å‰è¿™é‡Œåˆå¤šäº†ä¸€ä¸ªç±»ä¼¼TaskControlBlock ä»¥åŠ Kernel_stackçš„æ•°æ®ç»“æ„APP_NAMES,é‡Œé¢ä¿å­˜äº†åº”ç”¨åå­—å’Œæ•°æ®çš„ä¿¡æ¯</p>
</td></tr></table>
<p><strong>æ•´ä¸ªsys_execå¤§æ¦‚åŒ…æ‹¬å‡ ä¸ªä¸»è¦å‡½æ•°</strong></p>
<p><strong>1:è·å–å½“å‰ç”¨æˆ·é¡µè¡¨åŸºåœ°å€</strong></p>
<p><strong>2:æ‰‹åŠ¨æŸ¥è¯¥é¡µè¡¨è·å–å­—ç¬¦ä¸²</strong></p>
<p><strong>3:ç”¨å­—ç¬¦ä¸²æ‰¾åˆ°åº”ç”¨æ•°æ®,å¹¶è½½å…¥è¿è¡Œ</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_exec(path: *const u8) -&gt; isize {
    let token = current_user_token();
    let path = translated_str(token, path);
    if let Some(data) = get_app_data_by_name(path.as_str()) {
        let task = current_task().unwrap();
        task.exec(data);
        0
    } else {
        -1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>app linker ç¼–å†™</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_app_names:
    .string &quot;exit&quot;
    .string &quot;user_shell&quot;
<span class="boring">}
</span></code></pre></pre>
<p>start = _app_names. ç›´åˆ°è¯»å–åˆ°'\0' (æœ‰å¾…ç¡®è®¤è¿™é‡Œæ˜¯å¦æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨åŠ ä¸Šäº†'\0')  ä¹‹åç”¨ç±»ä¼¼memcpyä¿å­˜åˆ°&amp;strä¸­</p>
<p>_app_namesæŒ‰é¡ºåºä¿å­˜åœ¨äº†ä¸€ä¸ªvecä¸­, ä¹‹åå°±å¯ä»¥ç”¨idæ¥å¾—åˆ°åº”ç”¨æ•°æ®äº†</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref APP_NAMES: Vec&lt;&amp;'static str&gt; = {
        let num_app = get_num_app();
        extern &quot;C&quot; { fn _app_names(); }
        let mut start = _app_names as usize as *const u8;
        let mut v = Vec::new();
        unsafe {
            for _ in 0..num_app {
                let mut end = start;
                while end.read_volatile() != '\0' as u8 {
                    end = end.add(1);
                }
                let slice = core::slice::from_raw_parts(start, end as usize - start as usize);
                let str = core::str::from_utf8(slice).unwrap();
                v.push(str);
                start = end.add(1);
            }
        }
        v
    };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è™šæ‹ŸåŒ–</strong></p>
<p>æ²¡æœ‰å¤´ç»ª.æ‰¾äº†ä¸€ç¯‡æœ‰ä»£ç çš„è®ºæ–‡çœ‹çœ‹å…ˆ.</p>
<p><a href="https://arxiv.org/pdf/2103.14951">A First Look at RISC-V Virtualization from anEmbedded Systems Perspective</a></p>
<p>è®ºæ–‡ä»“åº“:<a href="https://github.com/mit-pdos/RVirt">https://github.com/mit-pdos/RVirt</a></p>
<p><strong>What Needs to be Virtualized?</strong></p>
<p>1.Supervisor architectural state (i.e. CSRs)</p>
<p>2.Memory</p>
<p>3.I/O and Interrupts</p>
<p><strong>Virtualizing Memory</strong></p>
<p>Two-Level Address Translation</p>
<p>-Original virtual addresses translated to guest physical addresses by VS-level page table</p>
<p>-Guest physical addresses translated to machine physical addresses by HS-level page table</p>
<p>Same page-table entry format as S-mode</p>
<p>Same page-table layouts as S-mode (Sv32, 39, 48, ...)</p>
<p><strong>Virtualizing I/O and Interrupts</strong></p>
<p>Software &amp; Timer interrupts use SBI (=&gt; trivial)</p>
<p>Use two-level paging scheme to trap MMIO accesses </p>
<p>-Sufficient to emulate PLIC and other MMIO devices</p>
<p>Could avoid extra traps into hypervisor with virtualization</p>
<p>-aware PLIC-Platform issue, outside scope of hypervisor ISA</p>
<p>Need I/O MMU to initiate DMAs without trap into hypervisor</p>
<p>-Platform issue, outside scope of hypervisor ISA</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>è™šæ‹ŸåŒ–å±‚æ¬¡</strong>
<img src="camp-daliy/./../Virtualization.png" alt="avatar" /></p>
<p>linux namespace cgroup</p>
<p>namesapce: å®‰å…¨éš”ç¦»  (MNT, UTS, IPC, PID, NET, User, Cgroup)</p>
<p>cgroup: æ€§èƒ½éš”ç¦» (task, cgroup, subsystem, hierarchy)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-ç¬¬äºŒé˜¶æ®µ---å¼‚æ­¥os"><a class="header" href="#-ç¬¬äºŒé˜¶æ®µ---å¼‚æ­¥os">ğŸš§ ç¬¬äºŒé˜¶æ®µ---&gt;å¼‚æ­¥os</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>è¿™æ®µæ—¶é—´ä¸€ç›´åœ¨çœ‹äºŒé˜¶æ®µé¢˜ç›®</p>
<p>åŸå…ˆå¯¹å¼‚æ­¥æ“ä½œç³»ç»Ÿä¸€æ— æ‰€çŸ¥...ç°åœ¨ç¨å¾®æœ‰ç‚¹ç†è§£äº†</p>
<p>ç¡®å®šäº†äºŒé˜¶æ®µçš„é¢˜ç›®æ˜¯ç»“åˆå…±äº«è°ƒåº¦å™¨ä¸ç”¨æˆ·æ€ä¸­æ–­å†™ä¸€ä¸ªos</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>8.1~8.9</strong></p>
<p><strong>base on this</strong></p>
<p>å¼‚æ­¥æ“ä½œç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ
<a href="https://github.com/async-kernel/documents/blob/f85ea19e02217fc5e111309354566b4880046e0f/design/design.md">design.md</a></p>
<p>å…±äº«è°ƒåº¦å™¨
<a href="https://github.com/HUST-OS/tornado-os">tonado-os</a></p>
<p>ç”¨æˆ·æ€ä¸­æ–­
<a href="https://gallium70.github.io/rv-n-ext-impl/intro.html">rcore-n</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="810"><a class="header" href="#810">8.10</a></h1>
<p><strong>tornado-osä¸­ç”¨æˆ·ç¨‹åºæ‰§è¡Œ</strong></p>
<p>async-read.rs</p>
<pre><pre class="playground"><code class="language-rust">async fn async_main() {
    println!(&quot;[user] start async read block--------------------------&quot;);
    let mut buf = [0; 512];
    read_block(0, &amp;mut buf).await;
    println!(&quot;[user] async read block ret: {:x?}&quot;, buf);

}
// å¼‚æ­¥mainå‡½æ•°ï¼Œç”±entryè°ƒç”¨execute_async_main
#[no_mangle]
fn main() -&gt; i32 {
    println!(&quot;async-read adding task\n&quot;);
    spawn(async_main());
    println!(&quot;async-read do_yield\n&quot;);
    do_yield(4);
    println!(&quot;[user] yield back async-read----------------------------&quot;);
    execute_async();
    0
}
</code></pre></pre>
<p>yield-task0.rs</p>
<pre><pre class="playground"><code class="language-rust">async fn async_main() {
    println!(&quot;yield test task 0&quot;);
}

// å¼‚æ­¥mainå‡½æ•°ï¼Œç”±entryè°ƒç”¨execute_async_main
#[no_mangle]
fn main() -&gt; i32 {
    // å¾€å…±äº«è°ƒåº¦å™¨ä¸­æ·»åŠ ä»»åŠ¡
    tornado_user::spawn(async_main());
    // åˆ‡æ¢åœ°å€ç©ºé—´
    do_yield(2);
    println!(&quot;yield back 1&quot;);
    execute_async();
    0
}

</code></pre></pre>
<p>yield-task1.rs</p>
<pre><pre class="playground"><code class="language-rust">async fn async_main() {
    println!(&quot;yield test task 1&quot;);
}

// å¼‚æ­¥mainå‡½æ•°ï¼Œç”±entryè°ƒç”¨execute_async_main
#[no_mangle]
fn main() -&gt; i32 {
    spawn(async_main());
    do_yield(3);
    println!(&quot;yield back 2&quot;);
    execute_async();
    0
}
</code></pre></pre>
<p>ä¸»è¦æµç¨‹:</p>
<p>1.æ¯ä¸ªç”¨æˆ·ç¨‹åºéƒ½ç”¨async_mainæŠŠè‡ªå·±ä¸»ä½“ä»»åŠ¡åŒ…è£…èµ·æ¥, é€šè¿‡spawn(async_main()) å°†è¯¥ä»»åŠ¡åŠ å…¥åˆ°å…±äº«è°ƒåº¦å™¨ä¸­,</p>
<p>2.ç„¶åç«‹å³do_yield()è®©å‡ºç­‰å¾…è¢«è°ƒåº¦æ‰§è¡Œ,å½“è¢«è°ƒåº¦æ‰§è¡Œæ—¶printä¸€ä¸‹ä¿¡æ¯</p>
<p>3.åœ¨æ‰§è¡Œç»“æŸå‰é€šè¿‡æ¥å‘è°ƒåº¦å™¨ç”³è¯·æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡. (å› ä¸ºå®ƒæœ¬èº«å·²ç»æ‰§è¡Œå®Œäº†)</p>
<p><strong>ç”¨æˆ·æ€ä¸‹è¿›ç¨‹åœ¨ç»“æŸå‰å‘è°ƒåº¦å™¨å‘å‡ºè¯·æ±‚æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡</strong></p>
<p><strong>ç”¨æˆ·æ€ä¸‹è¿›ç¨‹æ·»åŠ å®Œä»»åŠ¡åå¯ä»¥é€‰æ‹©ç»§ç»­æ‰§è¡Œ,æˆ–è€…ä¸»åŠ¨è®©å‡º(do_yield).  ç­‰å¾…å†…æ ¸æ¥ç”¨è°ƒåº¦å™¨åˆ‡æ¢åˆ°å®ƒ</strong></p>
<p><strong>ç”¨ä¸Šè¿°å‡ ä¸ªç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹çš„è¾“å‡ºä¿¡æ¯æ¥ç†è§£è¿™ä¸ªè¿‡ç¨‹</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[/]: yield-task0.bin yield-task1.bin async-read.bin channel.bin 
new asid: AddressSpaceId(1)
new asid: AddressSpaceId(2)
new asid: AddressSpaceId(3)
new asid: AddressSpaceId(4)
asid AddressSpaceId(1) user base: PhysicalAddress(87000000)
asid AddressSpaceId(2) user base: PhysicalAddress(8712c000)
asid AddressSpaceId(3) user base: PhysicalAddress(87258000)
asid AddressSpaceId(4) user base: PhysicalAddress(87384000)
yield-task0 adding task
yield-task0 do_yeild(2)
[syscall] yield: 2
yield-task1 adding task
yield-task0 do_yield(3)
[syscall] yield: 3
async-read adding task
async-read do_yield
[syscall] yield: 4
finding next task 
<span class="boring">}
</span></code></pre></pre>
<p><strong>yield-task0.bin yield-task1.bin async-read.bin åˆ†åˆ«ç”Ÿæˆä¸€ä¸ªä»»åŠ¡æ·»åŠ åˆ°å…±äº«è°ƒåº¦å™¨ä¸­. é€šè¿‡ecall yieldè¿›å…¥å†…æ ¸. å†…æ ¸ç”¨å…±äº«è°ƒåº¦å™¨æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&gt;&gt;&gt; user executor: next task = ShouldYield(0)
[syscall] yield kernel
mod interrupt initialized
yield kernel task!
[user] yield back 1
yield-task0 execute_async
finding next task 

&gt;&gt;&gt; user executor: next task = Task(10a090)
[user] yield test task 0
[user] task0 excuting async_main
finding next task 

&gt;&gt;&gt; user executor: next task = ShouldYield(2)
[syscall] yield: 2
[user] yield back 2
yield-task0 execute_async
finding next task 

&gt;&gt;&gt; user executor: next task = Task(10a090)
[user] yield test task 1
[user] task1 executing async_main
finding next task 

&gt;&gt;&gt; user executor: next task = ShouldYield(3)
[syscall] yield: 3
[user] yield back async-read----------------------------
[user] yield back 3
finding next task 
<span class="boring">}
</span></code></pre></pre>
<p><strong>yield back å›åˆ°yield-task0å task0æ‰§è¡Œexecute_async.å‘å…±äº«è°ƒåº¦å™¨å‘å‡ºè¯·æ±‚æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡..å…¶ä»–ç¨‹åºé‡å¤ä¸Šè¿°è¿‡ç¨‹</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&gt;&gt;&gt; user executor: next task = Task(108410)
[user] start async read block--------------------------
[syscall] new kernel task: ffffffffc025c310
finding next task 

&gt;&gt;&gt; user executor: next task = ShouldYield(4)
[syscall] yield: 4
finding next task 

&gt;&gt;&gt; user executor: next task = Task(110090)
[user] channel test
finding next task 

&gt;&gt;&gt; user executor: next task = ShouldYield(0)
[syscall] yield kernel
mod interrupt initialized
finding next task 

extr intr in shared
&gt;&gt;&gt; user executor: next task = Task(110190)
[user] start receive from channel
finding next task 

&gt;&gt;&gt; user executor: next task = Task(110410)
[user] send 0 to channel
finding next task 

&gt;&gt;&gt; user executor: next task = Task(110190)
[user] received 0 from channel
finding next task 
<span class="boring">}
</span></code></pre></pre>
<p><strong>channeléƒ¨åˆ†è¿˜æ²¡çœ‹</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&gt;&gt;&gt; user executor: next task = NoWakeTask
finding next task 

&gt;&gt;&gt; user executor: next task = NoWakeTask
finding next task 

...................é‡å¤(ç•¥)

&gt;&gt;&gt; user executor: next task = NoWakeTask
finding next task 

&gt;&gt;&gt; user executor: next task = ShouldYield(0)
[syscall] yield kernel
mod interrupt initialized
finding next task 

&gt;&gt;&gt; user executor: next task = Task(108410)
[user] async read block ret: [eb, 58, 90, 6d, 6b, 66, 73, 2e, 66, 61, 74, 0, 2, 1, 20, 0, 2, 0, 0, 0, 0, f8, 0, 0, 20, 0, 40, 0, 0, 0, 0, 0, 0, 0, 8, 0, c1, f, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 29, ca, 13, 7, b8, 4e, 4f, 20, 4e, 41, 4d, 45, 20, 20, 20, 20, 46, 41, 54, 33, 32, 20, 20, 20, e, 1f, be, 77, 7c, ac, 22, c0, 74, b, 56, b4, e, bb, 7, 0, cd, 10, 5e, eb, f0, 32, e4, cd, 16, cd, 19, eb, fe, 54, 68, 69, 73, 20, 69, 73, 20, 6e, 6f, 74, 20, 61, 20, 62, 6f, 6f, 74, 61, 62, 6c, 65, 20, 64, 69, 73, 6b, 2e, 20, 20, 50, 6c, 65, 61, 73, 65, 20, 69, 6e, 73, 65, 72, 74, 20, 61, 20, 62, 6f, 6f, 74, 61, 62, 6c, 65, 20, 66, 6c, 6f, 70, 70, 79, 20, 61, 6e, 64, d, a, 70, 72, 65, 73, 73, 20, 61, 6e, 79, 20, 6b, 65, 79, 20, 74, 6f, 20, 74, 72, 79, 20, 61, 67, 61, 69, 6e, 20, 2e, 2e, 2e, 20, d, a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, aa]
finding next task 

&gt;&gt;&gt; user executor: next task = Finished
User exit!
<span class="boring">}
</span></code></pre></pre>
<p><strong>æœ€ç»ˆasync-read blockå®Œæˆ è¾“å‡ºç»“æœ</strong></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>åˆæ­¥è®¾è®¡</strong></p>
<p>tiny_kernelæ˜¯å¤šçº¿ç¨‹ç¨‹åº,æ‰€æœ‰äººå…±äº«åœ°å€ç©ºé—´(å•é¡µè¡¨ä¸‹çš„å†…æ ¸),æ²¡æœ‰å†…å­˜ç®¡ç†(ç”±ä¸Šçº§kernelå®Œæˆ),æœ‰è¿›ç¨‹çº¿ç¨‹ç®¡ç†,ç»“åˆç”¨æˆ·æ€ä¸­æ–­</p>
<p>é€šè¿‡æ‹“å±•ecallè¯­ä¹‰æ¥ä½¿å¾—ç”¨æˆ·è¿›ç¨‹ä¸‹çš„ä»»åŠ¡å¯ä»¥ ecall è¿›å…¥tiny_kernel,tiny_kernelé€‰æ‹©æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡.</p>
<p>tiny_kernelåœ¨å†…æ ¸ä»¥åŠç”¨æˆ·ç©ºé—´ä¸­çš„å›ºå®šä½ç½®</p>
<p><strong>so far------------</strong></p>
<p>ä¸»è¦å®Œæˆäº†tiny_kernelåœ¨å†…æ ¸ä¸­çš„æ˜ å°„.  æš‚æ—¶æ²¡æœ‰å®Œæˆtiny_kernelåœ¨ç”¨æˆ·ç©ºé—´ä¸­çš„æ˜ å°„</p>
<p>ç”¨æˆ·ç¨‹åºå¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨è®©å†…æ ¸æ¥æ‰§è¡Œtiny_kernel</p>
<p>v1æ˜¯ä¸€ä¸ªæœ€å°åŒ–å†…æ ¸åªèƒ½è¾“å‡ºä¸€äº›ä¸œè¥¿,å¯å•ç‹¬ç¼–è¯‘,æ”¹å˜linkerä¸­çš„entryåœ°å€å’Œsyscallä¸ºsbicallå¯ä»¥æˆä¸ºä¸€ä¸ªç‹¬ç«‹çš„å†…æ ¸</p>
<p>æœªæ¥v1ä¸­å°†æœ‰ä¸€ä¸ªåº“ä»¥å‡½æ•°è°ƒç”¨çš„å½¢å¼ä¾›å…¶ä»–ç”¨æˆ·ç¨‹åºä½¿ç”¨,ç»“åˆç”¨æˆ·æ€ä¸­æ–­,å¯å°†ecall(éœ€è¦æ‹“å±•è¯­ä¹‰)åˆ†å‘ç»™v1,èµ‹äºˆv1æ›´å¤šåŠŸèƒ½</p>
<p>v1å°†è‡ªå·±æ— æ³•å¤„ç†çš„æƒ…å†µå†é€šè¿‡ecallè½¬äº¤ç»™å†…æ ¸</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[kernel] Hello, world!
last 31684 Physical Frames.
.text [0x80200000, 0x80217000)
.rodata [0x80217000, 0x8021d000)
.data [0x8021d000, 0x8022b000)
.bss [0x8022b000, 0x8043c000)
mapping .text section
mapping .rodata section
mapping .data section
mapping .bss section
mapping physical memory
mapping memory-mapped registers
remap_test passed!
loader list app
/**** APPS ****
v1
**************/
/**** APPS ****
initproc
usertests
hello_world
user_shell
tiny
**************/
Rust user shell
&gt;&gt; hello_world
Hello world from user mode program!
Hello world switch to v1
Hello, world! from v1
v1 stext 80400000 etext 80403000
Shell: Process 2 exited with code 0
<span class="boring">}
</span></code></pre></pre>
<p><strong>to do</strong></p>
<p>1.åœ¨ç”¨æˆ·ç©ºé—´æ˜ å°„tiny_kernelä½¿å¾—ç”¨æˆ·è¿›ç¨‹å¯ä»¥ä¸é€šè¿‡å†…æ ¸è®¿é—®tiny_kernel</p>
<p>2.å¢åŠ tiny_kernelåŠŸèƒ½</p>
<p><strong>ecall</strong></p>
<p>æœ€åˆæƒ³æ³•:è¿›ç¨‹Aé€šè¿‡sapwnç”Ÿæˆä¸€ä¸ªä»»åŠ¡,æ·»åŠ åˆ°è°ƒåº¦é˜Ÿåˆ—ä¸­åå°±ç«‹é©¬do_yieldä¸»åŠ¨è®©å‡º,do_yieldéœ€è¦é€šè¿‡ecallè¿›å…¥å†…æ ¸æ¥å¤„ç†,</p>
<p>æ€è€ƒ:ç»“åˆç”¨æˆ·æ€ä¸­æ–­,æ˜¯å¦å¯ä»¥å°†do_yieldç›´æ¥è½¬äº¤ç»™å…±äº«è°ƒåº¦å™¨å‘¢? è¿™æ ·å°±å¯ä»¥å°‘ä¸€æ¬¡è¿›å…¥å†…æ ¸, å°¤äºˆé˜³æŒ‡å‡ºé€‰æ‹©æ— æ³•åŒºåˆ†ecallæ¥æ‰§è¡Œä¸åŒå¤„ç†,ä½†æ˜¯å¯ä»¥é€šè¿‡ä¸€ä¸ªè½¯ä¸­æ–­è¾¾åˆ°ç±»ä¼¼æ•ˆæœ</p>
<p>æ‹“å±•ecallè¯­ä¹‰ä¸»è¦çš„ç”¨å¤„åº”è¯¥åœ¨ioå¤„.(è¿˜åœ¨æ•´ç†ä¸­)</p>
<p><strong>ecallæ‹“å±•è¯­ä¹‰çš„è®¨è®ºfromå°¤äºˆé˜³</strong></p>
<p><a href="camp-daliy/./../ecall%E8%AF%AD%E4%B9%89%E6%8B%93%E5%B1%95.html">è®¨è®ºé“¾æ¥</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>åœ¨rcore-tutoriä¸­åŠ å…¥ç”¨æˆ·è¿›ç¨‹å’Œçº¿ç¨‹...</p>
<p>åˆ‡æ¢æ—¶switchåå°±åœä½äº†. è¿˜åœ¨æ‰¾åŸå› ä¸­..</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>8-13</strong></p>
<p>ä¸Šåˆè®¨è®ºä¸­å‘è€å¸ˆæç¤ºçœ‹vDSO. äº†è§£ä¸­</p>
<p><strong>8:15å›è®°:æ­¤æ—¶æœªç†è§£vDSO,vDSOæ ¹æœ¬ä¸æ˜¯è¿™æ ·~~</strong></p>
<p>vdsoä¸­éœ€è¦å¤šä¸ªè™šæ‹Ÿé¡µé¢æ˜ å°„åˆ°åŒä¸€ä¸ªç‰©ç†é¡µé¢</p>
<p>å°è¯•ä¸€ä¸‹~</p>
<p>å°è¯•æŠŠä¸€ä¸ªæŒ‡å‘666çš„åœ°å€å¼€å§‹çš„ä¸€é¡µæ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´å»</p>
<p>ptråœ¨å†…æ ¸ç©ºé—´ä¸­çš„åœ°å€-0xffffffff40000000 = ç‰©ç†åœ°å€ = 0x8024e210</p>
<p>æŠŠå®ƒæ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´çš„0x86750000-0x86751000è¿™ä¸€é¡µä¸­, ç„¶åæˆ‘ä»¬åœ¨ç”¨æˆ·ç©ºé—´ä¸‹çœ‹çœ‹èƒ½ä¸èƒ½è®¿é—®å®ƒ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const usize = &amp;666usize as *const usize;
println!( &quot;ptr {:#x}&quot;, ptr as usize- 0xffffffff40000000) ;
let va_range1 =
    VirtualAddress(0x86750000 as usize)..VirtualAddress(0x86751000)
let pa_range1 =
    PhysicalAddress(0x8024e000)..PhysicalAddress(0x8024f000)
mapping.map_defined(
    &amp;va_range1,
    &amp;pa_range1,
    Flags::WRITABLE | Flags::READABLE | Flags::EXECUTABLE | Flags::USER,
);
<span class="boring">}
</span></code></pre></pre>
<p>ç„¶ååœ¨ç”¨æˆ·è¿›ç¨‹ä¸‹è¯•å›¾è·å–å…¶ä¸­æ•°æ®</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
#[link_section = &quot;.text.entry&quot;]
pub extern &quot;C&quot; fn _start() -&gt; ! {
    println!(&quot;0x86750210 ---------------------------------{}&quot;, unsafe { *((0x86750210) as usize as *const usize) });
    extern &quot;C&quot; {
        fn sbss();
        fn ebss();
    }
    unsafe {
        r0::zero_bss(
            &amp;mut sbss as *mut _ as *mut u32,
            &amp;mut ebss as *mut _ as *mut u32,
        );
        HEAP.lock()
            .init(HEAP_SPACE.as_ptr() as usize, USER_HEAP_SIZE);
    }
    let exit_code = main();
    exit(exit_code);
    unreachable!()
}
<span class="boring">}
</span></code></pre></pre>
<p>å¯ä»¥çœ‹åˆ°ç›®æ ‡åˆæ­¥å®ç°äº†.</p>
<pre><code class="language-log">[virtio] found a block device of size 262144 KB
[virtio] DMA address: 0x80536000
fs init
[/]: yield-task0.bin yield-task1.bin async-read.bin channel.bin 
new asid: AddressSpaceId(1)
new asid: AddressSpaceId(2)
new asid: AddressSpaceId(3)
new asid: AddressSpaceId(4)
asid AddressSpaceId(1) user base: PhysicalAddress(87000000)
ptr 0x8024e210
asid AddressSpaceId(2) user base: PhysicalAddress(8712c000)
ptr 0x8024e210
asid AddressSpaceId(3) user base: PhysicalAddress(87258000)
ptr 0x8024e210
asid AddressSpaceId(4) user base: PhysicalAddress(87384000)
ptr 0x8024e210
0x86750210 ---------------------------------666
yield-task0 adding task
yield-task0 do_yeild(2)
[syscall] yield: 2
0x86750210 ---------------------------------666
yield-task1 adding task
yield-task0 do_yield(3)
[syscall] yield: 3
0x86750210 ---------------------------------666
async-read adding task
async-read do_yield
[syscall] yield: 4
0x86750210 ---------------------------------666
finding next task 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ç›®å‰å·²æœ‰å®ç°</p>
<p><strong>v1æ˜¯ä¸€ä¸ªæœ€å°åŒ–å†…æ ¸</strong> </p>
<p>æˆ‘ä»¬æŠŠå®ƒå•ç‹¬ç¼–è¯‘å¥½,å¹¶æŠŠå®ƒè½½å…¥åˆ°0x87000000åœ°å€å¤„</p>
<pre><code class="language-python">import os
os.system(&quot;cd user &amp;&amp; cargo clean&quot;)
os.system(&quot;cd v1 &amp;&amp; cargo clean&quot;)
os.system(&quot;cd v1 &amp;&amp; python build.py&quot;)
os.system(&quot;cd os &amp;&amp; make build&quot;)
os.system(&quot;qemu-system-riscv64 \
-machine virt \
-nographic \
-bios bootloader/rustsbi-qemu.bin \
-device loader,file=os/target/riscv64gc-unknown-none-elf/release/os,addr=0x80200000 \
-device loader,file=v1/target/riscv64gc-unknown-none-elf/debug/v1.bin,addr=0x87000000 \
-drive file=user/target/riscv64gc-unknown-none-elf/release/fs.img,if=none,format=raw,id=x0 \
-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0&quot;)
</code></pre>
<p><strong>kernel memory_set.rsä¿®æ”¹</strong></p>
<p>åœ¨memory_set.rsä¸­åŠ å…¥push_shared</p>
<p>å…¶ä¸­0x80218000----0x8021a000åŒºé—´å†…æ˜¯2ä¸ªusizeæ•°æ®çš„åœ°å€. åœ¨ç”¨æˆ·ç©ºé—´å†…è¢«mapåˆ°0x86000000-----0x86002000åœ°å€å¤„</p>
<p>ç„¶åæ˜ å°„0x87000000å¼€å§‹çš„1000ä¸ªpage.   è¿™æ®µåŒºé—´å†…æœ‰v1.binçš„æ•°æ®å’Œä»£ç </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn push_shared(&amp;mut self) {
    let ptr1: *const usize = &amp;666usize as *const usize;
    let ptr2: *const usize = &amp;777usize as *const usize;
    println!( &quot;ptr1 {:?}&quot;, ptr1);
    println!( &quot;ptr2 {:?}&quot;, ptr2);
    self.page_table.map(
        VirtAddr::from(0x86000000 ).into(),  
        PhysAddr::from(0x80218000).into(),  
        PTEFlags::R | PTEFlags::X | PTEFlags::W|PTEFlags::U
    );
        self.page_table.map(
        VirtAddr::from(0x86001000 ).into(),  
        PhysAddr::from(0x80219000).into(),  
        PTEFlags::R | PTEFlags::X | PTEFlags::W|PTEFlags::U
    );
    
    self.page_table.map(
        VirtAddr::from(0x86002000 ).into(),  
        PhysAddr::from(0x8021a000).into(),  
        PTEFlags::R | PTEFlags::X | PTEFlags::W |PTEFlags::U
    );
    let start_addr = 0x87000000 as usize;
    for i in 0..1000 {
        self.page_table.map(
            VirtAddr::from(start_addr + PAGE_SIZE*i).into(),  
            PhysAddr::from(start_addr + PAGE_SIZE*i).into(),  
            PTEFlags::R | PTEFlags::X | PTEFlags::W|PTEFlags::U
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>v1.binçš„é“¾æ¥è„šæœ¬linker.ld</strong></p>
<p>å…¥å£åœ°å€ä¸º0x87000000</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OUTPUT_ARCH(riscv)
ENTRY(v1_start)
BASE_ADDRESS = 0x87000000;
SECTIONS
{
    . = BASE_ADDRESS;
    stext = .;

    .text : {
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(4K);
    etext = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }
    . = ALIGN(4K);

    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    .bss : {
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }
    /DISCARD/ : {
        *(.eh_frame)
        *(.debug*)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>ç”¨æˆ·ç¨‹åºhello_world</strong></p>
<p>å¦‚æœè¢«æ­£ç¡®è®¾ç½®æ˜¯,è®¿é—®0x86000770å’Œ0x860007b8å¯å¾—åˆ°666å’Œ777</p>
<p>jr 0x87000000åº”è¯¥å¯ä»¥è·³è½¬åˆ°v1.binçš„å…¥å£å¹¶ä¸”æ­£ç¡®æ‰§è¡Œ</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]
#![feature(global_asm)]
#![feature(llvm_asm)]
#[macro_use]
extern crate user_lib;
use user_lib::{
    exec_v1,
};

#[no_mangle]
pub fn main() -&gt; i32 {
    println!(&quot;Hello world from user mode program!&quot;);
    println!(&quot;0x86000770 ---------------------------------{}&quot;, unsafe { *(0x86000770 as usize as *const usize) });
    println!(&quot;0x860007b8 ---------------------------------{}&quot;, unsafe { *(0x860007b8 as usize as *const usize) });

    let addr = 0x87000000 as usize;
    unsafe {
        llvm_asm!(&quot;jr $0&quot; :: &quot;r&quot;(addr as usize) :: &quot;volatile&quot;);
    }
    // unsafe{}
    // exec_v1();
    0
}
</code></pre></pre>
<p><strong>v1çš„å…¥å£å‡½æ•°</strong></p>
<pre><pre class="playground"><code class="language-rust">use crate::io;
global_asm!(include_str!(&quot;entry.asm&quot;));
#[no_mangle]
pub unsafe extern &quot;C&quot; fn main() -&gt; i32 {
    extern &quot;C&quot; {
        fn stext();
        fn etext();
    }
    println!(&quot;Hello, world! from v1&quot;);
    println!(&quot;v1 stext {:x} etext {:x}&quot;, stext as usize, etext as usize);
    0
}   
</code></pre></pre>
<p>æœ€åçœ‹è¾“å‡º</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[rustsbi] RustSBI version 0.2.0-alpha.1
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|

[rustsbi] Platform: QEMU (Version 0.2.0)
[rustsbi] misa: RV64ACDFIMNSU
[rustsbi] mideleg: 0x222
[rustsbi] medeleg: 0xb1ab
[rustsbi-dtb] Hart count: cluster0 with 1 cores
[rustsbi] Kernel entry: 0x80200000
[kernel] Hello, world!
last 31683 Physical Frames.
.text [0x80200000, 0x80218000)
.rodata [0x80218000, 0x8021e000)
.data [0x8021e000, 0x8022c000)
.bss [0x8022c000, 0x8043d000)
mapping .text section
mapping .rodata section
mapping .data section
mapping .bss section
mapping physical memory
mapping memory-mapped registers
remap_test passed!
loader list app
/**** APPS ****
v1
**************/
/**** APPS ****
initproc
usertests
hello_world
user_shell
tiny
**************/
ptr1 0x80218770
ptr2 0x802187b8
ptr1 0x80218770
ptr2 0x802187b8
Rust user shell
&gt;&gt; hello_world
ptr1 0x80218770
ptr2 0x802187b8
Hello world from user mode program!
Hello world switch to v1
0x86000770 ---------------------------------666
0x860007b8 ---------------------------------777
Hello, world! from v1
v1 stext 87000000 etext 87003000
Shell: Process 2 exited with code 0
&gt;&gt; 
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>ä¸å‘è€å¸ˆè®¨è®ºè®°å½•</strong></p>
<p>éœ€è¦åšçš„å‡†å¤‡: çœ‹Green thread  ä»¥åŠ 200è¡Œä»£ç å­¦future</p>
<p>æ¥ä¸‹æ¥çš„ä»»åŠ¡:äº†è§£åŠ¨æ€é“¾æ¥,ä»¥åŠzcoreä¸­vDSOç›¸å…³çš„å†…å®¹,åœ¨rcoreä¸­é‡ç°ç›¸å…³å†…å®¹</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>8.16</strong></p>
<p>å­¦ä¹ zcoreä¸­çš„vDSO</p>
<p>åœ¨zcoreä¸­çš„rustç¨‹åºæ˜¯ä½¿ç”¨stdçš„.ä¸ä¹‹å‰çš„no_stdçš„ç”¨æˆ·ç¨‹åºä¸åŒ,æœ€åéœ€è¦ç»è¿‡libcå°è£…,å› ä¸ºrust-stdä¹Ÿæ˜¯å°è£…çš„libc</p>
<p>libcå¯ä»¥ç†è§£ä¸ºå°è£…äº†ç³»ç»Ÿè°ƒç”¨çš„ä¸€ä¸ªåº“</p>
<p><strong>stdä¸‹println!()</strong></p>
<p>println!()ä¼šä»¥è°ƒç”¨libcåº“.æœ€ç»ˆä»¥æ‰§è¡Œlibcå°è£…å¥½çš„ç³»ç»Ÿè°ƒç”¨æ¥å®Œæˆæ“ä½œ</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, zCore!-----------------------------------------&quot;);
}
</code></pre></pre>
<p><strong>å¯¹æ¯”no_stdä¸‹çš„println!()</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SYSCALL_WRITE: usize = 64;
fn syscall(id: usize, args: [usize; 3]) -&gt; isize {
    let mut ret: isize;
    unsafe {
        llvm_asm!(&quot;ecall&quot;
            : &quot;={x10}&quot; (ret)
            : &quot;{x10}&quot; (args[0]), &quot;{x11}&quot; (args[1]), &quot;{x12}&quot; (args[2]), &quot;{x17}&quot; (id)
            : &quot;memory&quot;
            : &quot;volatile&quot;
        );
    }
    ret
}
pub fn sys_write(fd: usize, buffer: &amp;[u8]) -&gt; isize {
  syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()])
}
struct Stdout;
impl Write for Stdout {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        sys_write(1, s.as_bytes());
        Ok(())
    }
}
pub fn print(args: fmt::Arguments) {
    Stdout.write_fmt(args).unwrap();
}
#[macro_export]
macro_rules! print {
    ($fmt: literal $(, $($arg: tt)+)?) =&gt; {
        $crate::console::print(format_args!($fmt $(, $($arg)+)?));
    }
}
#[macro_export]
macro_rules! println {
    ($fmt: literal $(, $($arg: tt)+)?) =&gt; {
        print(format_args!(concat!($fmt, &quot;\n&quot;) $(, $($arg)+)?));
    }
}

#[no_mangle]
extern &quot;C&quot; fn _start() {
    println!(&quot;Hello, world!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>æ€ä¹ˆæ ·..æ˜¯ä¸æ˜¯æ¯”è¾ƒæ›²æŠ˜.å¯ä»¥ç†è§£åœ¨stdä¸‹libcä¸ºç¨‹åºåšäº†å·®ä¸å¤šçš„äº‹æƒ….</p>
<p>åŠ¨æ€é“¾æ¥</p>
<p>æƒ³è±¡è¿™æ ·ä¸€ç§æƒ…å†µ,ä¸€ä¸ªç¨‹åºä½¿ç”¨äº†libcæ ‡å‡†åº“,ç°åœ¨è®¡ç®—æœºä¸­åŒæ—¶è¿è¡Œç€è¯¥ç¨‹åºçš„100ä¸ªè¿›ç¨‹.é‚£ä¹ˆ,æ¯ä¸ªè¿›ç¨‹ä¸­éƒ½ä¼šæœ‰ä¸€ä»½libc,æ“ä½œç³»ç»Ÿéœ€è¦åœ¨çœŸå®çš„ç‰©ç†å†…å­˜ä¸­åŠ è½½100ä»½libc,æµªè´¹äº†å¾ˆå¤šå†…å­˜.(é€šè¿‡no_stdçš„ä¾‹å­å°±å¯ä»¥æ„Ÿè§‰åˆ°)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ldd /bin/sh
        linux-vdso.so.1 (0x00007fff7910b000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4d7b663000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f4d7b88c000)
<span class="boring">}
</span></code></pre></pre>
<p><strong>åœ¨no_stdä¸‹å†™äº†ä¸€ä¸ªåŒ…è£…syscallçš„åº“ã€‚ å†…æ ¸ä¸ºç”¨æˆ·æ˜ å°„syscallåº“ä¸­å„å‡½æ•°çš„ç‰©ç†åœ°å€ï¼Œå’Œä¸€ä¸ªè™šæ‹Ÿåœ°å€ã€‚ éœ€ç”¨æˆ·ç¨‹åºåœ¨libä¸­jp addrå½¢å¼æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ã€‚addrä¸ºåªè¯»é¡µé¢ã€‚  è¿™æ ·ä¹Ÿå®ç°äº†vdsoå’Œâ€œè½½å…¥æ—¶åŠ¨æ€é“¾æ¥â€</strong></p>
<p>libc</p>
<p>è§£æelf</p>
<p>é“¾æ¥</p>
<p>vdsoåœ°å€ç©ºé—´</p>
<p>è°ƒåº¦ä»£ç ç”±å†…æ ¸ä»£ç æä¾›.</p>
<p>å¼‚æ­¥ç³»ç»Ÿè°ƒç”¨</p>
<p>ç”¨æˆ·ç¨‹åºä¿®æ”¹</p>
<p>æ€»ä½“è®¾è®¡æ–¹æ¡ˆ</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>zcore-zirconä¸­çš„vDSO</strong></p>
<p><strong>vdsoåº“å½¢æˆ</strong></p>
<p>åœ¨zircon-libos.patchä¸­æè¿°äº†ä¿®æ”¹zirconæºç æ¥ç”ŸæˆvdsoåŠ¨æ€åº“(åªåšäº†å¯¹x86å¹³å°ä»¥åŠarmå¹³å°)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">include &quot;syscall-entry.h&quot;
</span><span class="boring">include &quot;zircon-syscall-x86.S&quot;
</span>.text
.cfi_sections .eh_frame, .debug_frame

.macro m_syscall name, num, nargs, public
 syscall_entry_begin \name

    mov $\num, %eax
    jmpq *zcore_syscall_entry(%rip)

    .hidden CODE_SYSRET_\name\()_VIA_\name
CODE_SYSRET_\name\()_VIA_\name\():
syscall_entry_end \name \public
.endm

.pushsection .rodata
zcore_syscall_entry:
    .quad 0xdeadbeaf
.popsection
<span class="boring">include &quot;syscalls-stubs.S&quot;
</span><span class="boring">}
</span></code></pre></pre>
<p><strong>ä¸»è¦æ”¹åŠ¨çš„ä»£ç </strong></p>
<p>mov $\num, %eax ä¿å­˜ç³»ç»Ÿè°ƒç”¨å·</p>
<p>jmpq *zcore_syscall_entry(%rip)  è·³è½¬åˆ° [rip + *zcore_syscall_entry]</p>
<p><strong>çœ‹ä¸€ä¸‹ç¼–è¯‘å‡ºæ¥çš„vdso----libzircon.so</strong>(æˆ‘æ²¡ç¼–è¯‘. æ‹¿äº†ç°æˆçš„)</p>
<p>readelf --dyn-syms libzircon.so</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Symbol table '.dynsym' contains 359 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000000071d0    75 FUNC    WEAK   DEFAULT    9 zx_vmo_op_range
     2: 0000000000007afe     8 FUNC    GLOBAL DEFAULT    9 _zx_clock_read
     3: 0000000000007b5f     8 FUNC    GLOBAL DEFAULT    9 _zx_event_create
     4: 0000000000007d97     8 FUNC    GLOBAL DEFAULT    9 _zx_pci_enable_bus_master
     5: 0000000000007cb8    11 FUNC    WEAK   DEFAULT    9 zx_ktrace_write
     6: 0000000000007d79    11 FUNC    WEAK   DEFAULT    9 zx_pager_op_range
....ç•¥
   357: 0000000000008069    11 FUNC    GLOBAL DEFAULT    9 _zx_vmar_protect
   358: 0000000000007d53     8 FUNC    WEAK   DEFAULT    9 zx_pager_create
<span class="boring">}
</span></code></pre></pre>
<p>zx_pager_createä¸ºä¾‹</p>
<p>å»æ‰zx_ å°±èƒ½åœ¨zcore/zircon-syscall/consts.rsä¸­å¯ä»¥æ‰¾åˆ°ç›¸åº”çš„ç³»ç»Ÿè°ƒç”¨å·å®šä¹‰ PAGER_CREATE = 77,</p>
<p><strong>å†…æ ¸è½½å…¥vDSO</strong></p>
<p>å¯åŠ¨æ—¶ä¼šåœ¨_startåšä¸€äº›åˆå§‹åŒ–å·¥ä½œå,è¿›å…¥main. </p>
<p>mainä¸­åœ¨imagesè½½å…¥libzircon.so è¿™å°±æ˜¯vDSOçš„å¯¹åº”å®é™…åŠ¨æ€åº“æ–‡ä»¶.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn _start(boot_info: &amp;BootInfo) -&gt; ! {
    logging::init(get_log_level(boot_info.cmdline));
.....(ç•¥)
    main(ramfs_data, boot_info.cmdline);
    unreachable!();
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[cfg(feature = &quot;zircon&quot;)]
fn main(ramfs_data: &amp;[u8], cmdline: &amp;str) {
    use zircon_loader::{run_userboot, Images};
    let images = Images::&lt;&amp;[u8]&gt; {
        userboot: include_bytes!(&quot;../../prebuilt/zircon/x64/userboot.so&quot;),
        vdso: include_bytes!(&quot;../../prebuilt/zircon/x64/libzircon.so&quot;),
        zbi: ramfs_data,
    };
    let _proc = run_userboot(&amp;images, cmdline);
    run();
}
</code></pre></pre>
<p><strong>zircon-loaderåšäº†ä¸ºç”¨æˆ·ç¨‹åºå‡†å¤‡å¥½æ‰§è¡Œç¯å¢ƒ,å…¶ä¸­å°±åŒ…å«äº†æ˜ å°„vDSOéƒ¨åˆ†</strong></p>
<p><strong>åœ¨zircon-loader::run_userboot()ä¸‹</strong></p>
<p>// å½“å†…æ ¸å°†userbootæ˜ å°„åˆ°ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ—¶ï¼Œä¼šåƒæ­£å¸¸ç¨‹åºé‚£æ ·ï¼Œåœ¨å†…å­˜ä¸­é€‰æ‹©ä¸€ä¸ªéšæœºåœ°å€è¿›è¡ŒåŠ è½½ã€‚è€Œåœ¨æ˜ å°„userbootçš„vDSOæ—¶ï¼Œå¹¶ä¸é‡‡ç”¨ä¸Šè¿°éšæœºçš„æ–¹å¼ï¼Œè€Œæ˜¯å°†vDSOæ˜ åƒç›´æ¥æ”¾åœ¨å†…å­˜ä¸­userbootçš„æ˜ åƒä¹‹åã€‚è¿™æ ·ä¸€æ¥ï¼ŒvDSOä»£ç ä¸userbootçš„åç§»é‡æ€»æ˜¯å›ºå®šçš„ã€‚åœ¨ç¼–è¯‘é˜¶æ®µä¸­ï¼Œç³»ç»Ÿè°ƒç”¨çš„å…¥å£ç‚¹ç¬¦å·è¡¨ä¼šä»vDSO ELFæ˜ åƒä¸­æå–å‡ºæ¥ï¼Œéšåå†™å…¥åˆ°é“¾æ¥è„šæœ¬çš„ç¬¦å·å®šä¹‰ä¸­ã€‚åˆ©ç”¨æ¯ä¸ªç¬¦å·åœ¨vDSOæ˜ åƒä¸­ç›¸å¯¹å›ºå®šçš„åç§»åœ°å€ï¼Œå¯åœ¨é“¾æ¥è„šæœ¬æä¾›çš„_endç¬¦å·çš„å›ºå®šåç§»é‡å¤„ï¼Œå®šä¹‰è¯¥ç¬¦å·ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œuserbootä»£ç å¯ä»¥ç›´æ¥è°ƒç”¨åˆ°æ”¾åœ¨å†…å­˜ä¸­ï¼Œå…¶æ˜ åƒæœ¬èº«ä¹‹åçš„ï¼Œæ¯ä¸ªç¡®åˆ‡ä½ç½®ä¸Šçš„vDSOå…¥å£ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn run_userboot(images: &amp;Images&lt;impl AsRef&lt;[u8]&gt;&gt;, cmdline: &amp;str) -&gt; Arc&lt;Process&gt; {

....(ç•¥)
    // vdso
    //ä¸ºvdsoåˆ›å»ºvmo
    //vmoè¡¨ç¤ºè™šæ‹Ÿå†…å­˜çš„ä¸€ä¸ªè¿ç»­åŒºåŸŸ,å¯ä»¥æ˜ å°„åˆ°å¤šä¸ªåœ°å€ç©ºé—´ä¸­.
    //VMOåœ¨å†…æ ¸å’Œç”¨æˆ·ç©ºé—´ä¸­ç”¨äºè¡¨ç¤ºåˆ†é¡µå†…å­˜å’Œç‰©ç†å†…å­˜.
    let vdso_vmo = {
        let elf = ElfFile::new(images.vdso.as_ref()).unwrap();
        let vdso_vmo = VmObject::new_paged(images.vdso.as_ref().len() / PAGE_SIZE + 1);
        vdso_vmo.write(0, images.vdso.as_ref()).unwrap();
        let size = elf.load_segment_size();

        //allocate_at: Create a child VMAR at the `offset`.
        let vmar = vmar.allocate_at(userboot_size,
                                    size,
                                    VmarFlags::CAN_MAP_RXW | VmarFlags::SPECIFIC,
                                    PAGE_SIZE,).unwrap();

        //è¿™é‡Œå°±åˆ°äº†vDSOçš„éƒ¨åˆ†,åŸæœ¬éœ€è¦ä»æ–‡ä»¶ç³»ç»Ÿä¸­åŠ è½½ä¸€ä¸ª.soè¿‡æ¥
        //è¿™é‡Œç›´æ¥æŠŠå‰é¢å·²ç»æ˜ å°„å¥½vdsoçš„vmoä¼ å…¥è¿‡å»
        // Same as `load_from_elf`, but the `vmo` is an existing one instead of a lot of new ones.
        vmar.map_from_elf(&amp;elf, vdso_vmo.clone()).unwrap();


//-------------------------------------------------------------------------
fn map_from_elf(&amp;self, elf: &amp;ElfFile, vmo: Arc&lt;VmObject&gt;) -&gt; ZxResult {
    for ph in elf.program_iter() {

        //åªæœ‰TYPE=LOADçš„æ‰éœ€è¦è¢«æ˜ å°„è¿›å†…å­˜
        if ph.get_type().unwrap() != Type::Load {
            continue;
        }
        //è·å–elfæ–‡ä»¶ä¸­çš„VirtAddr
        let offset = ph.virtual_addr() as usize;
        //è·å–elfä¸­çš„æƒé™ä¿¡æ¯
        let flags = ph.flags().to_mmu_flags();
        //è·å–elfæ–‡ä»¶ä¸­çš„PhysAddr å¹¶åšå¯¹é½
        let vmo_offset = pages(ph.physical_addr() as usize) * PAGE_SIZE;
        //è·å–elfæ–‡ä»¶ä¸­çš„MemSiz
        let len = pages(ph.mem_size() as usize) * PAGE_SIZE;
        //å®Œæˆæ˜ å°„
        self.map_at(offset, vmo.clone(), vmo_offset, len, flags)?;
    }
    Ok(())
}
-------------------------------------------------------------------------
<span class="boring">}
</span></code></pre></pre>
<p><strong>è§£æç¬¦å·è¡¨, å¦‚æœç¬¦å·è¡¨ä¸­æœ‰zcore_syscall_entryåˆ™è·å–å®ƒçš„åœ°å€..</strong></p>
<p><strong>è¿™å°±å¯¹åº”äº†ä¹‹å‰ä¿®æ”¹zirconç”Ÿæˆå®é™…vdsoçš„éƒ¨åˆ†,å¦‚æœç»è¿‡é‚£ä¸ªåŠ¨æ€åº“ç¼–è¯‘,ç¬¦å·è¡¨ä¸­æ˜¯ä¼šå‡ºç°zcore_syscall_entryçš„</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[cfg(feature = &quot;std&quot;)]
        {
            //è·å–ç¬¦å·åä¸ºzcore_syscall_entryçš„ç¬¦å·åœ°å€
            let offset = elf.get_symbol_address(&quot;zcore_syscall_entry&quot;).expect(&quot;failed to locate syscall entry&quot;) as usize;
            let syscall_entry = &amp;(kernel_hal_unix::syscall_entry as usize).to_ne_bytes();

            //æ˜ å°„zcore_syscall_entryå’ŒçœŸå®çš„syscall_entryçš„ç‰©ç†åœ°å€   ä¸ºä»€ä¹ˆx3 I have no idea.
            // fill syscall entry x3
            vdso_vmo.write(offset, syscall_entry).unwrap();
            vdso_vmo.write(offset + 8, syscall_entry).unwrap();
            vdso_vmo.write(offset + 16, syscall_entry).unwrap();
        }
        vdso_vmo
    };
//-------------------------------------------------------------------------
fn get_symbol_address(&amp;self, symbol: &amp;str) -&gt; Option&lt;u64&gt; {
    for section in self.section_iter() {
        if let SectionData::SymbolTable64(entries) = section.get_data(self).unwrap() {
            for e in entries {
                if e.get_name(self).unwrap() == symbol {
                    return Some(e.value());
                }
            }
        }
    }
    None
}
//-------------------------------------------------------------------------
........(ç•¥)

    let data = Vec::from(cmdline.replace(':', &quot;\0&quot;) + &quot;\0&quot;);
    let msg = MessagePacket { data, handles };
    kernel_channel.write(msg).unwrap();

//entryä¸ºuserbootçš„entry  vDSOæ˜ åƒåœ¨ç¼–è¯‘æ—¶åµŒå…¥åˆ°å†…æ ¸ä¸­ã€‚å†…æ ¸å°†å®ƒä½œä¸ºåªè¯»VMOå…¬å¼€ç»™ç”¨æˆ·ç©ºé—´ã€‚å†…æ ¸å¯åŠ¨æ—¶ï¼Œä¼šé€šè¿‡è®¡ç®—å¾—åˆ°å®ƒæ‰€åœ¨çš„ç‰©ç†é¡µã€‚å½“program loaderè®¾ç½®äº†ä¸€ä¸ªæ–°è¿›ç¨‹åï¼Œä½¿è¯¥è¿›ç¨‹èƒ½å¤Ÿè¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„å”¯ä¸€æ–¹æ³•æ˜¯ï¼šprogram loaderåœ¨æ–°è¿›ç¨‹çš„ç¬¬ä¸€ä¸ªçº¿ç¨‹å¼€å§‹è¿è¡Œä¹‹å‰ï¼Œå°†vDSOæ˜ å°„åˆ°æ–°è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆåœ°å€éšæœºï¼‰ã€‚å› æ­¤ï¼Œåœ¨å¯åŠ¨å…¶ä»–èƒ½å¤Ÿè¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„è¿›ç¨‹çš„æ¯ä¸ªè¿›ç¨‹è‡ªå·±æœ¬èº«éƒ½å¿…é¡»èƒ½å¤Ÿè®¿é—®vDSOçš„VMOã€‚

    proc.start(&amp;thread, entry, sp, Some(handle), 0, thread_fn)
        .expect(&quot;failed to start main thread&quot;);
    proc
}
<span class="boring">}
</span></code></pre></pre>
<p>vDSOè¢«æ˜ å°„åˆ°æ–°è¿›ç¨‹çš„åŒæ—¶ä¼šå°†æ˜ åƒçš„base addressé€šè¿‡arg2å‚æ•°ä¼ é€’ç»™æ–°è¿›ç¨‹ä¸­çš„ç¬¬ä¸€ä¸ªçº¿ç¨‹ã€‚</p>
<p>é€šè¿‡è¿™ä¸ªåœ°å€ï¼Œå¯ä»¥åœ¨å†…å­˜ä¸­æ‰¾åˆ°ELFçš„æ–‡ä»¶å¤´ï¼Œè¯¥æ–‡ä»¶å¤´æŒ‡å‘å¯ç”¨äºæŸ¥æ‰¾ç³»ç»Ÿè°ƒç”¨ç¬¦å·åçš„å…¶ä»–ELFç¨‹åºæ¨¡å—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread.start(entry, stack, handle_value as usize, arg2, thread_fn)
<span class="boring">}
</span></code></pre></pre>
<p>é€šè¿‡è¾“å‡ºä¿¡æ¯å¯ä»¥çœ‹åˆ°åŠ¨æ€è¿æ¥å™¨åœ¨userboot bootfsä¸­</p>
<p>userboot: searching bootfs for 'lib/ld.so.1'</p>
<p>userboot: userboot: loaded lib/ld.so.1 at 0x400000000000, entry point 0x40000005772c</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>zircon ----------------------------------------
[3.843034047s ERROR 0 0:0] Map [0, 4000)
[3.843828373s ERROR 0 0:0] Map [4000, 16000)
userboot: option &quot;LOG=warn&quot;
userboot: option &quot;TERM=xterm-256color&quot;
userboot: option &quot;console.shell=true&quot;
userboot: option &quot;virtcon.disable=true&quot;
userboot: decompressed BOOTFS to VMO!
userboot: searching bootfs for 'bin/bootsvc'
userboot: 'bin/bootsvc' has PT_INTERP &quot;lib/ld.so.1&quot;
userboot: searching bootfs for 'lib/ld.so.1'
userboot: userboot: loaded lib/ld.so.1 at 0x400000000000, entry point 0x40000005772c
userboot: userboot: loaded vDSO at 0x4000000af000, entry point 0x4000000b6e38
userboot: process bin/bootsvc started.
userboot: waiting for loader-service requests...
userboot: searching bootfs for 'lib/libfdio.so'
userboot: searching bootfs for 'lib/libtrace-engine.so'
userboot: searching bootfs for 'lib/libasync-default.so'
userboot: searching bootfs for 'lib/liblaunchpad.so'
userboot: searching bootfs for 'lib/libmemfs.so'
userboot: searching bootfs for 'lib/libc++.so.2'
userboot: searching bootfs for 'lib/libc++abi.so.1'
userboot: searching bootfs for 'lib/libunwind.so.1'
<span class="boring">}
</span></code></pre></pre>
<p>ç”¨æˆ·ç¨‹åºç¼–è¯‘è¿‡ç¨‹</p>
<p>cargo build --release</p>
<p>zbi-linux bringup.zbi target/x86_64-fuchsia/release/bootfs -o target/zcore.zbi</p>
<p>å…¶ä¸­zbi-linux bringup.zbi æ˜¯é¢„å…ˆç¼–è¯‘å¥½çš„</p>
<p>æœ€ç»ˆæä¾›ç»™kernelçš„æ˜¯zcore.zbi</p>
<p>ZBIæ˜¯ä¸€ç§ç®€å•çš„å®¹å™¨æ ¼å¼ï¼Œå®ƒå†…åµŒäº†è®¸å¤šå¯ç”±å¼•å¯¼åŠ è½½ç¨‹åº BootLoaderä¼ é€’çš„é¡¹ç›®å†…å®¹ï¼ŒåŒ…æ‹¬ç¡¬ä»¶ç‰¹å®šçš„ä¿¡æ¯ã€æä¾›å¼•å¯¼é€‰é¡¹çš„å†…æ ¸â€œå‘½ä»¤è¡Œâ€ä»¥åŠRAMç£ç›˜æ˜ åƒ(é€šå¸¸æ˜¯è¢«å‹ç¼©çš„)ã€‚ZBIä¸­åŒ…å«äº†åˆå§‹æ–‡ä»¶ç³»ç»Ÿ bootfsï¼Œå†…æ ¸å°† ZBI å®Œæ•´ä¼ é€’ç»™ userbootï¼Œç”±å®ƒè´Ÿè´£è§£æå¹¶å¯¹å…¶å®ƒè¿›ç¨‹æä¾›æ–‡ä»¶æœåŠ¡ã€‚</p>
<p>å†…æ ¸ä¸ç›´æ¥å‚ä¸ç”¨æˆ·ç¨‹åºçš„åŠ è½½å·¥ä½œï¼ˆç¬¬ä¸€ä¸ªè¿›ç¨‹é™¤å¤–ï¼‰</p>
<p>ç”¨æˆ·ç¨‹åºå¼ºåˆ¶ä½¿ç”¨ PIC å’Œ PIEï¼ˆä½ç½®æ— å…³ä»£ç ï¼‰</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="820"><a class="header" href="#820">8.20</a></h1>
<p>v2ä¸­åŒ…è£…äº†ç³»ç»Ÿè°ƒç”¨. æˆåŠŸè·³è½¬åˆ°æŸåœ°å€æ‰§è¡Œäº†ç³»ç»Ÿè°ƒç”¨å¹¶è·å¾—è¿”å›å€¼</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>remap_test passed!
loader list app
/**** APPS ****
v1
**************/
/**** APPS ****
1
2
hello_world
initproc
usertests
user_shell
**************/
Rust user shell
&gt;&gt; 1
syscall1 = 0x870003a6
syscall2 = 0x870003ee
syscall3 = 0x87000436
syscall4 = 0x8700047e
sys_get_time = 0x870004fe
Shell: Process 2 exited with code 0
&gt;&gt; 2
Hello world from user mode program!
gettime from v2 1117122
Shell: Process 2 exited with code 0
&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>æ¥ä¸‹æ¥è€ƒè™‘æ”¯æŒsys_yield</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="821"><a class="header" href="#821">8.21</a></h1>
<p>æ— è¿›å±•çš„ä¸€å¤©~</p>
<p>åˆ†æäº†å‡½æ•°è°ƒç”¨çš„æ±‡ç¼–ä»£ç .</p>
<p>ç®€å•çš„å‡½æ•°è°ƒç”¨æ²¡æœ‰ä¿å­˜ä¸€äº›å¯„å­˜å™¨(è°ƒç”¨è€…ä¿å­˜)çš„æ“ä½œ</p>
<p>call(ä¼ªæŒ‡ä»¤)å¤§è‡´ä¼šåˆ†è§£æˆ  auipc å’Œ jalr æŒ‡ä»¤</p>
<p>auipc   ra, 0x0   ä¿å­˜å½“å‰pcå€¼åœ¨raä¸­</p>
<p>jalr (Jump and Link Register)</p>
<p>è¿”å›å€¼åœ¨a0ä¸­</p>
<p>å¸¦å‚æ•°æƒ…å†µli  a0, arg   ç„¶åå†æ‰§è¡Œauipc  ra,0x0</p>
<p>å¤šä¸ªå‚æ•°åº”è¯¥é¡ºåºä¿å­˜åœ¨a0, a1...ä¸­</p>
<p>å¦‚æœå‡½æ•°å¤æ‚ä¸€äº›å¯èƒ½å°±éœ€è¦ä¿å­˜ä¸€äº›å¯„å­˜å™¨äº†,ä¿é™©èµ·è§è¿˜æ˜¯ç”¨switchçš„å½¢å¼æ¥è·³è½¬åˆ°ç›®æ ‡å‡½æ•°åœ°å€æ¥æ‰§è¡Œ.</p>
<p>é€šè¿‡è¿™ç§æ–¹æ³•,å¤§è‡´å¯ä»¥åšåˆ°å’ŒåŠ¨æ€é“¾æ¥ä¸€æ ·çš„äº‹äº†....</p>
<p>é€šè¿‡åœ¨let x = test1();å¤„è®¾ç½®æ–­ç‚¹ç„¶åå•æ­¥è°ƒè¯•åˆ†æ</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = test1();
    test2();
    test3(888);
    let y = test4();
    test5();
}
    
fn test1() -&gt; usize{
    666
}
fn test2()-&gt; usize{
    777
}
fn test3(arg: usize){
    println!(&quot;arg {:?}&quot;, arg)
}
fn test4()-&gt; usize{
    999
}
fn test5() -&gt;usize{
    test1()
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x/100i $pc
let x = test1();
0xffffffffc020661a &lt;rust_main+480&gt;:	auipc	ra,0x0
0xffffffffc020661e &lt;rust_main+484&gt;:	jalr	260(ra)
0xffffffffc0206622 &lt;rust_main+488&gt;:	sd	a0,-32(s0)
0xffffffffc0206626 &lt;rust_main+492&gt;:	j	0xffffffffc0206628 &lt;rust_main+494&gt;
test2();
0xffffffffc0206628 &lt;rust_main+494&gt;:	auipc	ra,0x0
0xffffffffc020662c &lt;rust_main+498&gt;:	jalr	266(ra)
0xffffffffc0206630 &lt;rust_main+502&gt;:	j	0xffffffffc0206632 &lt;rust_main+504&gt;
test3(888);
0xffffffffc0206632 &lt;rust_main+504&gt;:	li	a0,888
0xffffffffc0206636 &lt;rust_main+508&gt;:	auipc	ra,0x0
0xffffffffc020663a &lt;rust_main+512&gt;:	jalr	272(ra)
0xffffffffc020663e &lt;rust_main+516&gt;:	j	0xffffffffc0206640 &lt;rust_main+518&gt;
let y = test4();
0xffffffffc0206640 &lt;rust_main+518&gt;:	auipc	ra,0x0
0xffffffffc0206644 &lt;rust_main+522&gt;:	jalr	490(ra)
0xffffffffc0206648 &lt;rust_main+526&gt;:	sd	a0,-24(s0)
0xffffffffc020664c &lt;rust_main+530&gt;:	j	0xffffffffc020664e &lt;rust_main+532&gt;
test5();
0xffffffffc020664e &lt;rust_main+532&gt;:	auipc	ra,0x0
0xffffffffc0206652 &lt;rust_main+536&gt;:	jalr	496(ra)
0xffffffffc0206656 &lt;rust_main+540&gt;:	j	0xffffffffc0206658 &lt;rust_main+542&gt;
0xffffffffc0206658 &lt;rust_main+542&gt;:	auipc	ra,0x0
0xffffffffc020665c &lt;rust_main+546&gt;:	jalr	972(ra)
0xffffffffc0206660 &lt;rust_main+550&gt;:	j	0xffffffffc0206662 &lt;rust_main+552&gt;
<span class="boring">}
</span></code></pre></pre>
<p>rust_main 0x8700008c
init_payload_environment 0x870002b2
add_to_thread_pool 0x870008e6
show_thread 0x870004b0
run_thread 0x87000626</p>
<p>rust_main 0x8700008c
init_payload_environment 0x870002b2
add_to_thread_pool 0x87000902
show_thread 0x870004b0
run_thread 0x87000626</p>
<p>rust_main 0x8700008c
init_payload_environment 0x870002b2
add_to_thread_pool 0x87000882
show_thread 0x870004b0
run_thread 0x87000626</p>
<p>init_payload_environment 0x87000256
add_to_thread_pool 0x87000748
run_thread 0x87000454</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>æ€»ä½“è®¾è®¡</strong></p>
<p>å‚è€ƒé£“é£å†…æ ¸è®¾è®¡</p>
<p>å…±äº«è°ƒåº¦å™¨æ˜¯ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åº,æ‰€æœ‰äººå…±äº«åœ°å€ç©ºé—´(å°±å¦‚åŒå•é¡µè¡¨ä¸‹çš„å†…æ ¸,åªæ˜¯æŠŠéœ€è¦å…±äº«çš„ä¸œè¥¿æ˜ å°„äº†å‰©ä¸‹è¿˜æ˜¯éš”ç¦»çš„),æ²¡æœ‰å†…å­˜ç®¡ç†(ç”±ä¸Šçº§kernelå®Œæˆ,ä¿è¯éš”ç¦»),æœ‰çº¿ç¨‹ç®¡ç†(è°ƒåº¦å™¨ä»¥åŠæ‰§è¡Œå™¨) </p>
<p>é£“é£å†…æ ¸è°ƒåº¦çš„å•ä½æ˜¯åç¨‹,æˆ‘ä¸ºäº†ç®€å•åšçš„æ˜¯çº¿ç¨‹(æ²¡å®ç°è¿‡åç¨‹) </p>
<p>ä»è°ƒåº¦å™¨ä¸­å¾—åˆ°çº¿ç¨‹æ—¶,ä¼šåˆ¤æ–­æ˜¯å¦åœ¨å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸‹,å¦‚æœåœ¨ç›¸åŒåœ°å€ç©ºé—´ä¸‹åˆ™ç›´æ¥æ‰§è¡Œè¯¥çº¿ç¨‹,å¦‚æœæ˜¯åœ¨ä¸åŒåœ°å€ç©ºé—´ä¸‹,é‚£ä¹ˆéœ€è¦é€šè¿‡ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨è®©å†…æ ¸å®Œæˆè¿›ç¨‹åˆ‡æ¢,åˆ°ç›®æ ‡åœ°å€ç©ºé—´ä¸‹æ‰§è¡Œ.</p>
<p>è¿›ç¨‹éœ€è¦æ„ŸçŸ¥è‡ªå·±æ‰€åœ¨çš„åœ°å€ç©ºé—´-----------è§£å†³æ–¹æ¡ˆ:åœ¨æ˜ å°„å†…å­˜æ—¶,æŒ‡å®šä¸€ä¸ªå”¯ä¸€spaceidå’Œç”¨æˆ·è¿›ç¨‹çš„satpç»‘å®š,å¹¶ä¸”é€šè¿‡tpå¯„å­˜å™¨ä¼ ç»™ç”¨æˆ·(ç›´æ¥æ‹¿é£“é£å†…æ ¸ä¸€äº›ä»£ç è¿‡æ¥å°±èƒ½ç”¨äº†~)</p>
<p>æ’æ›²:vDSO ç›®å‰rustç¨‹åºé’ˆå¯¹riscvå¹³å°æ— æ³•ç¼–è¯‘å½¢æˆä¸€ä¸ªåŠ¨æ€åº“,å¯¼è‡´å®ç°vDSOåªèƒ½é‡‡å–æ¯”è¾ƒæ›²æŠ˜çš„æ–¹æ³•----&gt;å½¢æˆä¸€ä¸ªelfæ–‡ä»¶,ç„¶åæ‰‹åŠ¨æ¥&quot;é“¾æ¥&quot;,åœ¨riscvä¸‹å°±æ˜¯åˆ†è§£callæŒ‡ä»¤ </p>
<p>auipc ra,0 ä¿å­˜å½“å‰pcåˆ°raä¸­, </p>
<p>ç„¶åjalr addrè·³è½¬ä¸­æŸåœ°å€æ‰§è¡Œ. </p>
<p>(ç„¶åæŠŠè¿™æ®µæ±‡ç¼–ä»£ç ç”¨ä¸€ä¸ªå‡½æ•°åŒ…è£…èµ·æ¥,è®©ç¼–è¯‘å™¨å¸®æˆ‘ä»¬åšä¸€äº›ä¸Šä¸‹æ–‡ä¿å­˜)</p>
<p>é“¾æ¥é˜¶æ®µå‘ç°æŸå‡½æ•°å®šä¹‰åœ¨åŠ¨æ€åº“æ—¶,é“¾æ¥å™¨ä¼šç”Ÿæˆä¸€æ®µå°ä»£ç ,è¿™æ®µå°ä»£ç å®é™…ä¸Šåšçš„å°±æ˜¯jp addrè·³è¿‡å»æ‰§è¡Œå‡½æ•°.åœ¨riscvä¸‹ç¼–è¯‘å™¨ä¼šåšauipc + jalr addr ä»¥åŠä¸€äº›ä¿å­˜çŠ¶æ€çš„æ“ä½œ.</p>
<p><strong>è¿è¡Œæ¼”ç¤º</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loader list app
/**** APPS ****
1
2
hello_world
initproc
usertests
user_shell
**************/
[kernel] init scheduler mem

[test1] Hello world from user mode program!
[user] [test1] add thread to scheduler  entry addr 0x22a space_id 0x1
add_to_thread_pool addr:0x22a  space_id:0x1
[user] [test1] return to test1
[user] [test1] yield


[test2] Hello world from user mode program!
[user] [test2] add thread to scheduler
[user] [test2] add thread entry addr 0x206 space_id 0x1

add_to_thread_pool addr:0x206  space_id:0x2
[user] [test2] return to test2
run thread space_id: 1
(ä»è°ƒåº¦å™¨å¾—åˆ°çš„çº¿ç¨‹æ˜¯ä¸åŒåœ°å€ç©ºé—´çš„,åˆ™éœ€è¦åˆ‡æ¢ç©ºé—´)
need switch space from 2 to 1

[user] return to test1
run thread space_id: 1
hello world! from --------------------- test1

hello world! from --------------------- test2
<span class="boring">}
</span></code></pre></pre>
<p><strong>æœªæ¥è®¡åˆ’</strong></p>
<p>ä¹‹åç»“åˆç”¨æˆ·æ€ä¸­æ–­,å¯ä»¥æ‹“å±•ecallè¯­ä¹‰,è®©ç”¨æˆ·ç¨‹åºå‘å‡ºçš„ecallå¯ä»¥åˆ†å‘åˆ°tiny_kernelå¤„.</p>
<p>ä¸€ç§åº”ç”¨çš„åœºæ™¯:ç”¨æˆ·è¿›ç¨‹å’ŒæŸä¸ªè®¾å¤‡ç»‘å®šäº†,é‚£ä¹ˆåœ¨è¿™ä¸ªç”¨æˆ·è¿›ç¨‹ä¸‹å¯¹æŸè®¾å¤‡çš„ioè¯·æ±‚å¯ä»¥ç”±tiny_kernelå¤„ç†.(ä¹Ÿå°±æ˜¯åœ¨ç”¨æˆ·æ€ä¸‹).  è®¾å¤‡è™šæ‹ŸåŒ–</p>
<p>å¯ä»¥ç†è§£ä¸ºåŸæ¥çš„å†…æ ¸é™¤äº†æä¾›å†…å­˜ç®¡ç†,è¿›ç¨‹ç®¡ç†,å…¶ä»–éƒ½å¯ä»¥äº¤ç»™tiny_kernelåš.</p>
<p><strong>æ„Ÿè°¢è€å¸ˆä»¥åŠåŠ©æ•™çš„å¸®åŠ©</strong></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: 2021å¼€æºæ“ä½œç³»ç»Ÿå¤ä»¤è¥æ€»ç»“-tiny_kernel-é™ˆä¹
date: 2021-09-16 16:00:25
categories:
- report
tags:
- author:yuoo655
- summerofcode2021
- async-os</h2>
<p>repoåœ°å€ï¼š<a href="https://github.com/yuoo655/async_os">https://github.com/yuoo655/async_os</a></p>
<!-- more -->
<h2 id="è®¾è®¡èƒŒæ™¯"><a class="header" href="#è®¾è®¡èƒŒæ™¯">è®¾è®¡èƒŒæ™¯</a></h2>
<p>ç°æœ‰å¦‚ä¸‹äº‹å®:</p>
<p>é¡µè¡¨åˆ‡æ¢å¼€é”€(è¿›ç¨‹) &gt; æ ˆåˆ‡æ¢å¼€é”€(çº¿ç¨‹) &gt; æ— æ ˆåˆ‡æ¢å‡½æ•°è°ƒç”¨å¼€é”€(åç¨‹) &gt; å‡½æ•°è°ƒç”¨</p>
<p>åœ¨åŒé¡µè¡¨è®¾è®¡ä¸‹,çº¿ç¨‹åˆ‡æ¢éœ€è¦è¿›å…¥å†…æ ¸,è¿™æ—¶éœ€åˆ‡æ¢é¡µè¡¨.é¡µè¡¨åˆ‡æ¢çš„å¼€é”€å¯¹äºçº¿ç¨‹æ¥è¯´æ¯”è¾ƒå¤§,æ‰€ä»¥æœ‰äº†ç”¨æˆ·æ€å’Œå†…æ ¸æ€å…±äº«ä¸€ä¸ªçº¿ç¨‹è°ƒåº¦å™¨ä¸æ‰§è¡Œå™¨çš„æƒ³æ³•.</p>
<p>å…·ä½“ç›®æ ‡:åŒä¸€è¿›ç¨‹ä¸‹çš„çº¿ç¨‹åˆ‡æ¢ä¸éœ€è¦è¿›å…¥å†…æ ¸,ä¸åŒè¿›ç¨‹ä¸‹çš„çº¿ç¨‹åˆ‡æ¢éœ€è¦ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨æ¥åˆ‡æ¢åˆ°ç›®æ ‡è¿›ç¨‹.</p>
<h3 id="å¦‚ä½•åœ¨å†…æ ¸å’Œç”¨æˆ·ä¹‹é—´å…±äº«ä¸€æ®µä»£ç "><a class="header" href="#å¦‚ä½•åœ¨å†…æ ¸å’Œç”¨æˆ·ä¹‹é—´å…±äº«ä¸€æ®µä»£ç ">å¦‚ä½•åœ¨å†…æ ¸å’Œç”¨æˆ·ä¹‹é—´å…±äº«ä¸€æ®µä»£ç </a></h3>
<p>æ€è€ƒ:åœ¨å•é¡µè¡¨çš„æƒ…å½¢ä¸‹å†…æ ¸å’Œç”¨æˆ·åœ¨åŒä¸€åœ°å€ç©ºé—´,å†…æ ¸åœ¨åˆ›å»ºä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ—¶éœ€è¦æŠŠå†…æ ¸å„æ®µæ˜ å°„è¿›ç”¨æˆ·ç©ºé—´.é‚£ä¹ˆå†…æ ¸æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åº,æ‰€æœ‰ç”¨æˆ·å…±äº«äº†å†…æ ¸çš„åœ°å€ç©ºé—´</p>
<p>ä»¿ç…§åˆšæ‰æ€è·¯,æˆ‘é‡‡å–æŠŠéœ€è¦å…±äº«çš„ä»£ç å½“æˆä¸€ä¸ªå•é¡µè¡¨ä¸‹çš„å†…æ ¸æ¥å†™,æ‰€æœ‰è¿›ç¨‹(åŒé¡µè¡¨ä¸‹å†…æ ¸å’Œç”¨æˆ·éƒ½æ˜¯ç‹¬ç«‹çš„è¿›ç¨‹)å…±äº«æ­¤éƒ¨åˆ†åœ°å€ç©ºé—´.</p>
<p>é‚£ä¹ˆå…³äºå…±äº«ä»£ç çš„éƒ¨åˆ†å¤§è‡´è¿‡ç¨‹å°±æ˜¯:æŠŠéœ€è¦å…±äº«çš„ä»£ç ç¼–è¯‘æˆä¸€ä¸ªelfæ–‡ä»¶ ==&gt; æŠŠelfæ–‡ä»¶åŠ è½½åˆ°å›ºå®šçš„ç‰©ç†åœ°å€ ==&gt; åœ¨å†…æ ¸ä¸­æ˜ å°„ ==&gt; åœ¨ç”¨æˆ·è¿›ç¨‹ä¸­æ˜ å°„</p>
<p>è¯¥elfæ–‡ä»¶çš„ä»£ç æ®µåœ¨ç”¨æˆ·è¿›ç¨‹ä¸‹çš„æƒé™æ˜¯å¯è¯»å¯æ‰§è¡ŒR||X è¿™æ ·ä¿è¯äº†ç”¨æˆ·æ— æ³•ä¿®æ”¹ä»£ç .</p>
<h3 id="ç”¨æˆ·è¿›ç¨‹å¦‚ä½•æ‰§è¡Œè°ƒåº¦å™¨çš„ä»£ç "><a class="header" href="#ç”¨æˆ·è¿›ç¨‹å¦‚ä½•æ‰§è¡Œè°ƒåº¦å™¨çš„ä»£ç ">ç”¨æˆ·è¿›ç¨‹å¦‚ä½•æ‰§è¡Œè°ƒåº¦å™¨çš„ä»£ç </a></h3>
<p>ç”±äºè°ƒåº¦å™¨è¢«ç¼–è¯‘æˆäº†ä¸€ä¸ªelfæ–‡ä»¶. é‚£ä¹ˆåªç”¨çŸ¥é“ä¸€ä¸ªèµ·å§‹åœ°å€å’Œå‡½æ•°åœ¨elfæ–‡ä»¶ä¸­çš„åç§»(è°ƒåº¦å™¨ä¸åšæ”¹åŠ¨è¯¥åç§»é‡æ˜¯å›ºå®šçš„),å°±å¯ä»¥è·³è½¬åˆ°ç›®æ ‡åœ°å€æ‰§è¡Œ.</p>
<h2 id="ä»£ç åˆ†æ"><a class="header" href="#ä»£ç åˆ†æ">ä»£ç åˆ†æ</a></h2>
<p>è°ƒåº¦å™¨çš„é“¾æ¥è„šæœ¬ç¼–å†™ ----- async_os/tiny_kernel/src/linker.ld</p>
<p>æŠŠè°ƒåº¦å™¨èµ·å§‹åœ°å€è®¾ç½®ä¸º0x87000000</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x87000000;
SECTIONS
{
    . = BASE_ADDRESS;
    start = .;
    .text : {
        stext = .;
        *(.text.entry)
        *(.text .text.*)
        . = ALIGN(4K);
        etext = .;
    }
...(ç•¥)
}
<span class="boring">}
</span></code></pre></pre>
<p>åŠ è½½è°ƒåº¦å™¨ ----- async_os/1.py</p>
<p>åœ¨qemuä¸­æŠŠå®ƒåŠ è½½åˆ°0x87000000(æ­¤éƒ¨åˆ†å¯ä»¥ä¼˜åŒ–,å³ä¸é€šè¿‡qemuåŠ è½½,è€Œæ˜¯é€šè¿‡å†…æ ¸æ¥åŠ è½½)</p>
<pre><code class="language-python">os.system(&quot;qemu-system-riscv64 \
-machine virt \
-nographic \
-bios bootloader/rustsbi-qemu.bin \
-device loader,file=os/target/riscv64gc-unknown-none-elf/release/os,addr=0x80200000 \
-device loader,file=tiny_kernel/target/riscv64gc-unknown-none-elf/release/tiny_kernel.bin,addr=0x87000000 \
-drive file=user/target/riscv64gc-unknown-none-elf/release/fs.img,if=none,format=raw,id=x0 \
-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 &quot;)
</code></pre>
<p>æ˜ å°„è¿›ç”¨æˆ·è¿›ç¨‹ ----- async_os\os\src\mm\memory_set.rs:270
æ­¤æ—¶å¯ä»¥æ˜ å°„ä»»æ„çš„è™šæ‹Ÿåœ°å€ä¸è°ƒåº¦å™¨çš„ç‰©ç†åœ°å€ç›¸å¯¹åº”.åœ¨ç”¨æˆ·è¿›ç¨‹ä¸‹åªéœ€è¦çŸ¥é“ä»£ç çš„ç›¸å¯¹åç§»é‡å³å¯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn push_shared(&amp;mut self) {
    let start_addr = 0x87000000 as usize;
    //ä»£ç æ®µå¯è¯»å¯æ‰§è¡Œ
    for i in 0..5 {
        // println!(&quot;R||X addr:{:#x}&quot;, start_addr + PAGE_SIZE*i);
        self.page_table.map(
            VirtAddr::from(start_addr + PAGE_SIZE*i).into(),  
            PhysAddr::from(start_addr + PAGE_SIZE*i).into(),  
            PTEFlags::R | PTEFlags::X  | PTEFlags::U
        );
    }
    for i in 5..50 {
        self.page_table.map(
            VirtAddr::from(start_addr + PAGE_SIZE*i).into(),  
            PhysAddr::from(start_addr + PAGE_SIZE*i).into(),  
            PTEFlags::R |  PTEFlags::W | PTEFlags::U
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>è°ƒåº¦å™¨éœ€è¦ä¸€ä¸ªåŠ¨æ€å†…å­˜åˆ†é…å™¨,éœ€è¦å†…æ ¸æ¥åˆå§‹åŒ–  ----- os\src\main.rs:64</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;[kernel] init scheduler mem&quot;);
unsafe {
    llvm_asm!(&quot;auipc ra, 0&quot;);
    llvm_asm!(&quot;jalr ra, $0&quot; :: &quot;r&quot;(0x87000462 as usize));
}
<span class="boring">}
</span></code></pre></pre>
<p>åœ¨ç”¨æˆ·è¿›ç¨‹ä¸­æ‰§è¡Œè°ƒåº¦å™¨çš„ä»£ç    ----- user\src\bin\1.rs:24
ç›®å‰è¿˜æ²¡æœ‰å¾ˆå¥½çš„åŠæ³•æ¥è§£å†³å¦‚ä½•è®©ç”¨æˆ·ç¨‹åºçŸ¥é“å‡½æ•°åœ¨elfæ–‡ä»¶ä¸­çš„åç§»é‡.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add_to_thread_pool: unsafe extern &quot;C&quot; fn(usize, usize) = unsafe { core::mem::transmute(0x87000854 as usize) };
unsafe { add_to_thread_pool(addr, 1 as usize) };
<span class="boring">}
</span></code></pre></pre>
<h2 id="è°ƒåº¦å™¨å®ç°éƒ¨åˆ†ä»£ç å…±äº«æ— å…³"><a class="header" href="#è°ƒåº¦å™¨å®ç°éƒ¨åˆ†ä»£ç å…±äº«æ— å…³">è°ƒåº¦å™¨å®ç°éƒ¨åˆ†(ä»£ç å…±äº«æ— å…³)</a></h2>
<p>è°ƒåº¦çš„åŸºæœ¬å•ä½çº¿ç¨‹çš„æ•°æ®ç»“æ„.åŒé¡µè¡¨çš„æƒ…å†µä¸‹åº”è¯¥ä¸éœ€è¦è¿™ä¸ªKernelStack.ä¸ºäº†æ–¹ä¾¿èµ·è§,è¿˜æ˜¯å…ˆä¸åŠ¨å®ƒ..</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Thread {
    //ä¸Šä¸‹æ–‡
    pub context: Context,
    pub kstack: KernelStack,
    //ç”±äºè°ƒåº¦å™¨éœ€è¦çŸ¥é“ä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„çº¿ç¨‹æ‰€å±çš„åœ°å€ç©ºé—´æ˜¯å•¥,ä»¥ä¾¿åœ¨ä¸åŒåœ°å€ç©ºé—´æ—¶å¯ä»¥åˆ‡æ¢è¿‡å»,æ‰€ä»¥éœ€è¦åœ¨çº¿ç¨‹ä¸­ä¿å­˜å½“å‰åœ°å€ç©ºé—´çš„ä¿¡æ¯
    //è¿™ä¸ªåœ°å€ç©ºé—´ç”±å†…æ ¸åˆ†é…,ç±»ä¼¼ä¸Tid,å’Œsatpç»‘å®š
    pub space_id: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>space_idä¸satpçš„ç›¸å…³ä¿¡æ¯  ----- os\src\mm\memory_set.rs:46 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>lazy_static! {
    pub static ref SPACE_ID_SATP : Vec&lt;usize&gt; = {
        let mut v = Vec::new();
        
        //åˆå§‹åŒ–ä¸º0  vectorçš„indexå°±æ˜¯space_id,åœ¨é‡Œé¢å­˜ç€satpçš„å€¼ 
        for i in 0..10{
            v.push(0);
        }
        v
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>åˆ›å»ºçº¿ç¨‹ ----- tiny_kernel\src\process\thread.rs:28</p>
<p>è¿›ç¨‹é€šè¿‡è¯»å–tpå¯„å­˜å™¨è·å–space_idä¿¡æ¯,åˆ›å»ºè¿›ç¨‹æ—¶space_idé€šè¿‡argä¼ å…¥.å¯¹äºè¿›ç¨‹æ¥è¯´å®ƒåªèƒ½çœ‹åˆ°space_idä½†æ— æ³•çŸ¥é“satpçš„å€¼,è¯¥æ˜ å°„ä¿¡æ¯ç”±å†…æ ¸æŒæ¡</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new_thread(entry: usize, arg: usize) -&gt; Thread {
    unsafe {
        let kstack_ = KernelStack::new();
        Thread {
            context: Context::new_thread_context(entry, arg, kstack_.top()),
            kstack: kstack_,
            space_id: arg
        }
    }
}
pub fn switch_to(&amp;mut self, target: &amp;mut Thread) {
   unsafe {
       self.context.switch(&amp;mut target.context);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>æŠŠspace_idä¼ å…¥tpå¯„å­˜å™¨ ----- os\src\trap\context.rs:18</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TrapContext {
    pub x: [usize; 32],
    pub sstatus: Sstatus,
    pub sepc: usize,
    pub kernel_satp: usize,
    pub kernel_sp: usize,
    pub trap_handler: usize,
    pub tp: usize,
}

impl TrapContext {
    pub fn set_sp(&amp;mut self, sp: usize) { self.x[2] = sp; }
    
    pub fn app_init_context(
        entry: usize,
        sp: usize,
        kernel_satp: usize,
        kernel_sp: usize,
        trap_handler: usize,
        tp: usize,
    ) -&gt; Self {
        let mut sstatus = sstatus::read();
        // set CPU privilege to User after trapping back
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
            kernel_satp,
            kernel_sp,
            trap_handler,
            tp,
        };
        cx.set_sp(sp);
        cx
    }
}


----- os\src\trap\trap.Sä¸­

__restore:

    csrw satp, a1
    sfence.vma
    csrw sscratch, a0
    mv sp, a0
    ld t0, 32*8(sp)
    ld t1, 33*8(sp)

    //è¿™é‡ŒæŠŠspace_idä¼ å…¥äº†tpå¯„å­˜å™¨ä¸­
    ld tp, 37*8(sp)
    (ç•¥)
    sret

<span class="boring">}
</span></code></pre></pre>
<h2 id="å‚è€ƒèµ„æ–™"><a class="header" href="#å‚è€ƒèµ„æ–™">å‚è€ƒèµ„æ–™</a></h2>
<ol>
<li>å¼‚æ­¥æ“ä½œç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ: <a href="https://github.com/async-kernel/documents/blob/main/design/design.md">https://github.com/async-kernel/documents/blob/main/design/design.md</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>ä»¥ä¸‹æ˜¯ä¸€äº›å°¤äºˆé˜³åœ¨å¾®ä¿¡ç¾¤çš„è®¨è®º</p>
<p><img src="./../ecall.jpg" alt="avatar" /></p>
<p>å°¤äºˆé˜³:æœ‰rs1å’Œrdçš„ä½ç½®ï¼Œä½†æ˜¯å¼ºåˆ¶ä¸º0</p>
<p>å°¤äºˆé˜³:å¦‚æœæƒ³æ”¹çš„è¯ï¼Œå¯ä»¥è€ƒè™‘ç»™rs1å’Œrdèµ‹ä¸€ä¸ªä»€ä¹ˆæ ·çš„è¯­ä¹‰</p>
<p>å°¤äºˆé˜³:è¿™ä¸ªæ”¹åŠ¨å®Œå…¨å¯ä»¥å’Œç°æœ‰çš„å…¼å®¹ï¼Œæ¯”å¦‚è§„å®šrs1å’Œrdä¸º0çš„æ—¶å€™è§¦å‘env callå¼‚å¸¸ï¼Œä¸ä¸º0çš„æ—¶å€™å¯ä»¥ä¸äº§ç”Ÿå¼‚å¸¸</p>
<p>å°¤äºˆé˜³:åœ¨ä¸æ”¹åŠ¨ç¡¬ä»¶çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥å‚è€ƒrustsbié‡Œé¢çš„æŒ‡ä»¤æ¨¡æ‹ŸåŠŸèƒ½ï¼Œæ¯”å¦‚è¯´æ‰‹åŠ¨æŠŠrs1å’Œrdç¼–ç è¿›å»ï¼Œæ‰§è¡Œåˆ°è¿™é‡Œå¯èƒ½ä¼šè§¦å‘ä¸€ä¸ªéæ³•æŒ‡ä»¤çš„å¼‚å¸¸ï¼Œè·³åˆ°sbiæˆ–è€…å†…æ ¸ä¸­å»æ¨¡æ‹Ÿæˆ‘ä»¬æƒ³è¦çš„ç¡¬ä»¶åŠŸèƒ½</p>
<p>å°¤äºˆé˜³:ç°åœ¨çš„ecallä¸€å®šä¼šè§¦å‘ä¸€ä¸ªç¯å¢ƒè°ƒç”¨å¼‚å¸¸ï¼Œåˆ‡åˆ°é«˜ç‰¹æƒçº§å»äº†ï¼Œæ‰€ä»¥æ²¡æœ‰æ„ä¹‰ã€‚
ä½†æ˜¯ç°åœ¨çš„ecallçš„rs1å’ŒrdåŸŸæ˜¯0ï¼Œå¦‚æœæˆ‘ä»¬æŠŠæŒ‡ä»¤çš„å®šä¹‰æ”¹æˆï¼Œå½“rs1å’Œrdä¸º0çš„æ—¶å€™ï¼Œè§¦å‘ç¯å¢ƒè°ƒç”¨å¼‚å¸¸ï¼ˆå…¼å®¹ç°æœ‰çš„è½¯ä»¶ï¼‰ï¼Œä¸ä¸º0çš„æ—¶å€™ä¸è§¦å‘å¼‚å¸¸ï¼Œæˆ–è€…è§¦å‘ä¸€ä¸ªåœ¨å½“å‰ç‰¹æƒçº§å¤„ç†çš„å¼‚å¸¸ï¼Œé‚£å°±æœ‰æ„ä¹‰äº†</p>
<p>å°¤äºˆé˜³:å¦‚æœç°åœ¨ç›´æ¥æŠŠç¯å¢ƒè°ƒç”¨å¼‚å¸¸å§”æ‰˜åˆ°ä½ç‰¹æƒçº§å¤„ç†ï¼Œä¼šå’Œç°æœ‰çš„è½¯ä»¶ä¸å…¼å®¹</p>
<p>å°¤äºˆé˜³:å¦ä¸€ä¸ªäº‹æƒ…ï¼Œåœ¨æœ‰ç”¨æˆ·æ€ä¸­æ–­çš„æƒ…å†µä¸‹ï¼Œå¦‚æœç”¨æˆ·æ€ç¨‹åºæƒ³ç”¨Arc Mutexåœ¨ä¸»ç¨‹åºå’Œä¸­æ–­å¤„ç†ç¨‹åºä¹‹é—´å…±äº«æ•°æ®çš„è¯ï¼Œä¸»ç¨‹åºåœ¨è·å–é”ä¹‹å‰è¦ç”¨uieå¯„å­˜å™¨æŠŠä¸­æ–­å±è”½æ‰ï¼Œä¸ç„¶å¯èƒ½ä¼šå¯¼è‡´ä¸´ç•ŒåŒºè¢«çªç ´ï¼Œå‡ºç°æ­»é”ã€‚è¿™ä¸ªé—®é¢˜ä»¥å‰åº”è¯¥æ˜¯åªæœ‰åœ¨å†™å†…æ ¸çš„æ—¶å€™æ‰éœ€è¦è€ƒè™‘çš„ã€‚</p>
<p>è½¦æ˜¥æ± :è¿™ä¸ªé—®é¢˜æˆ‘ä¹‹å‰è€ƒè™‘è¿‡ï¼Œåœ¨ç”¨æˆ·æ€ä¸èƒ½å…³ä¸­æ–­çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ç”¨ä¸€äº›ç¼–ç¨‹ä¸Šçš„æŠ€å·§å»è§„é¿è¿™ä¸ªé—®é¢˜</p>
<p>xyong:èƒ½è§„é¿åˆ°ä»€ä¹ˆç¨‹åºï¼Ÿ--------&gt;  è½¦æ˜¥æ± :è¿™ä¸ªè¦çœ‹å…·ä½“åœºæ™¯</p>
<p>å°¤äºˆé˜³:ä¸­æ–­å¤„ç†å‡½æ•°ä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥çœ‹æˆå¦ä¸€ä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯ç¼–è¯‘å™¨å¯èƒ½ä¸èƒ½ç†è§£è¿™ä¸€ç‚¹ï¼›
å¯ä»¥æŠŠå…±äº«çš„æ•°æ®ç»“æ„æ”¹æˆæ— é”çš„</p>
<p>è½¦æ˜¥æ± :æ— é”ç¼–ç¨‹éš¾åº¦æ¯”è¾ƒå¤§</p>
<p>xyong:åœ¨ä½ çš„åœºæ™¯ä¸‹ï¼Œå¯ä»¥å®Œå…¨è§„é¿å—ï¼Ÿ ---&gt; è½¦æ˜¥æ± :å¯ä»¥ï¼Œåªä¸è¿‡å¤„ç†èµ·æ¥æœ‰ç‚¹éº»çƒ¦   æ€è·¯æ˜¯å°½å¯èƒ½çŸ­æ—¶é—´å æœ‰é”ï¼Œè¿˜æœ‰å»¶è¿Ÿä¸­æ–­</p>
<p>xyong:å¦‚æœèƒ½å®Œå…¨é¿å¼€é”ï¼Œåº”è¯¥è¿˜æ˜¯å¾ˆå¥½çš„åšæ³•ã€‚çŸ­æ—¶é—´å ç”¨ï¼Œå¹¶ä¸èƒ½å®Œå…¨é¿å¼€ï¼Œå»¶è¿Ÿä¸­æ–­åœ¨æˆ‘çœ‹æ¥æ˜¯å¥½åŠæ³•ã€‚   è½¦æ˜¥æ± :å¯èƒ½è¿™ä¹Ÿæ˜¯ç”¨æˆ·æ€ä¸­æ–­åœ¨æˆ‘ä»¬é¡¹ç›®é‡Œé¢çš„ä¸€ä¸ªä¼˜åŒ–ç‚¹å§ï¼Œå¯ä»¥åœ¨ç”¨æˆ·æ€ç®¡ç†å¤–éƒ¨ä¸­æ–­</p>
<p>å°¤äºˆé˜³:å¯¹äºç”¨æˆ·æ€çš„ä¸­æ–­ï¼Œç”¨æˆ·è¿›ç¨‹æ˜¯å¯ä»¥é€šè¿‡ustatus.UIEæˆ–è€…uieå¯„å­˜å™¨æ¥å…³æ‰çš„ï¼Œè¿™ä¸¤ä¸ªå¯„å­˜å™¨åœ¨ç”¨æˆ·æ€éƒ½å¯ä»¥è¯»å†™ã€‚</p>
<p>å°¤äºˆé˜³:è¿™ä¸ªæ—¶å€™ä»ç„¶å¯ä»¥ç»™uipå¯„å­˜å™¨çš„ä¸€äº›ä½è®¾ç½®æˆ1ï¼Œä½†æ˜¯ä¸ä¼šè·³è½¬åˆ°utvecå»ï¼Œåªæœ‰ç­‰uieçš„ç›¸åº”ä½å†è¢«ç½®ä¸º1çš„æ—¶å€™æ‰ä¼šè·³è½¬</p>
<p>å°¤äºˆé˜³:CSRçš„æŒ‡ä»¤åº”è¯¥éƒ½æ˜¯åŸå­çš„</p>
<p>å°¤äºˆé˜³:è¿™ä¹Ÿå¯ä»¥è§†ä½œä¸€ç§å»¶è¿Ÿä¸­æ–­å§</p>
<p>å°¤äºˆé˜³:è™½ç„¶ç”¨æˆ·æ€ä¸èƒ½å…³å†…æ ¸æ€çš„ä¸­æ–­ï¼Œä½†æ˜¯å†…æ ¸åº”è¯¥ä¹Ÿä¸ä¼šå»åŠ¨ç”¨æˆ·è¿›ç¨‹çš„é”ç»“æ„ï¼Ÿ</p>
<p>å°¤äºˆé˜³:æˆ‘æ„Ÿè§‰ï¼Œå…ˆç”±ç¡¬ä»¶å®ç°æŠŠä¸­æ–­è½¬æ¶ˆæ¯ï¼Œæˆ–æŠŠä¸­æ–­è§†ä¸ºä¸€ç§é«˜ä¼˜å…ˆçº§çš„æ¶ˆæ¯ï¼›ç„¶åå†åœ¨çº¿ç¨‹æˆ–åç¨‹ä¸­ç”¨æŒ‡å®šå‡½æ•°å¤„ç†æ¶ˆæ¯ã€‚é€šè¿‡é™åˆ¶æ¶ˆæ¯å¤„ç†å‡½æ•°èƒ½è®¿é—®çš„æ•°æ®èŒƒå›´ï¼Œè¿™æ—¶çš„å…±äº«å°±å˜æˆæ­£å¸¸æƒ…å†µä¸‹çš„ï¼Œçº¿ç¨‹æˆ–åç¨‹é—´çš„æ•°æ®å…±äº«äº†ã€‚ä»è€Œè§„é¿é”çš„å¤§é‡ä½¿ç”¨ã€‚</p>
<p>@xyong åœ¨æ‚¨è¯´çš„è¿™ç§æ–¹å¼ä¸‹ï¼Œå¦‚æœçº¿ç¨‹æˆ–åç¨‹é—´ç¡®å®éœ€è¦åŒæ­¥äº’æ–¥é”çš„æƒ…å†µï¼Œæ˜¯ä¸æ˜¯å°±å¯ä»¥åˆ©ç”¨åˆšæ‰è¯´çš„â€œç”¨uieæ§åˆ¶ç”¨æˆ·è¿›ç¨‹å»å“åº”ä¸­æ–­çš„æ—¶æœºâ€ï¼Œæ¥å®ç°åŠ è§£é”æ—¶å€™ï¼Œå…³è¿™ä¸ªç”¨æˆ·è¿›ç¨‹çš„ä¸­æ–­çš„æ•ˆæœ</p>
<p>xyong:æˆ‘è¿˜æ²¡æœ‰æƒ³å¾—å¤ªæ¸…æ¥šã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•-1"><a class="header" href="#-rustå­¦ä¹ è®°å½•-1">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-1"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-1">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setp0------rustç»ƒä¹ ---a-hrefhttpsgithubcomrust-langrustlingsrustlingsafont"><a class="header" href="#setp0------rustç»ƒä¹ ---a-hrefhttpsgithubcomrust-langrustlingsrustlingsafont">setp0 ---- rustç»ƒä¹  -&gt; <a href="https://github.com/rust-lang/rustlings">rustlings</a></font></a></h1>
<hr />
<p><strong>AsRef&lt;T&gt;</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
   assert_eq!(&quot;hello&quot;, s.as_ref());
}
let s = &quot;hello&quot;;
is_hello(s);
<span class="boring">}
</span></code></pre></pre>
<p><strong>as_ref()</strong> ä¸èƒ½å‡ºé”™, å¦åˆ™å°±éœ€è¦ç”¨ <strong>Option<T> or a Result&lt;T,E&gt;</strong> å½¢å¼</p>
<p></br> <br/>
<strong>enmu match ç»„åˆ</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Move(Point),
    Echo(String),
    ChangeColor((u8, u8, u8)),
    Quit,
}
fn process(&amp;mut self, message: Message) {
    match message {
        Message::Move(value) =&gt; {
            self.move_position(value) 
        }
        Message::ChangeColor(value) =&gt; {
            self.change_color(value) 
        }
        Message::Echo(value) =&gt;{
            self.echo(value)
        }
        Message::Quit =&gt;{self.quit()}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>å…¶ä¸­<strong>value</strong>æ˜¯æšä¸¾æˆå‘˜ä¸­åŒ…å«çš„ä»»æ„ç±»å‹å€¼, å¦‚æœæšä¸¾æˆå‘˜ä¸­æœ‰2ä¸ªä»¥ä¸Šå˜é‡å¯ç”¨ <strong>( _, _, value)</strong> å½¢å¼æå–ä»»æ„å˜é‡</p>
<p></br><br>
<strong>mainå‡½æ•°ä¹Ÿå¯è¿”å›'Result'</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt;Result&lt;(), E&gt;{
    let cost = xxxxxxxxxxxxxx?;
    Ok(())
}
</code></pre></pre>
<p></br> <br/></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>å®Œæˆäº†rustlingsç»ƒä¹ ,é€‰å‡ ä¸ªé¢˜ç›®è®°å½•ä¸€ä¸‹,ç„¶åæ‰“ç®—å¼„ä¸€ä¸‹github+gitpod</strong></p>
<p></br><br>
<strong>åŒä¸€ä¸ªå®ä¸­ä¹Ÿå¯ç”¨ ;  éš”å¼€æ¥åŒ¹é…ä¸åŒçš„è¾“å…¥</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
    ($val:expr) =&gt; {
        println!(&quot;Look at this other macro: {}&quot;, $val);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p></br><br>
<strong>ç”¨foldæ–¹æ³•å®ç°é˜¶ä¹˜</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1..num + 1).fold(1, |acc, x| acc * x)
<span class="boring">}
</span></code></pre></pre>
<p></br><br>
<strong>Arc&lt;Mutex&lt;&gt;&gt;</strong>
</br><br>
å•ç‹¬Arc-&gt;ä¸å¯å˜å¼•ç”¨...ä½†æ˜¯ä¿è¯äº’æ–¥è®¿é—®å¤šåŠæ˜¯éœ€è¦ä¿®æ”¹å˜é‡çš„.åˆä¸å¾—ä¸åŠ ä¸ŠMutex.å½¢æˆäº†è¿™ä¸€ç»å…¸ç»„åˆ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
let status_shared = status.clone();
thread::spawn(move || {
    for _ in 0..10 {
        thread::sleep(Duration::from_millis(250));
        status_shared.lock().unwrap().jobs_completed += 1;
    }
});
<span class="boring">}
</span></code></pre></pre>
<p><br></br></p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>setp0-3.2</strong></p>
<p>3.2è¦æ±‚:ç”¨rustå®ç°cè¯­è¨€ä¾‹å­</p>
<p><strong>æ€»ç»“</strong>:cè¯­è¨€ä¸­æŒ‡é’ˆçš„ä¸€äº›ä½¿ç”¨å¾€å¾€åœ¨rustä¸­æ²¡æœ‰ç‰¹åˆ«å¥½çš„å¯¹åº”,è¿™æ—¶å€™æœ€å¥½æ›´æ”¹æ•°æ®ç»“æ„,æ“ä½œæ–¹å¼æ¥è¾¾åˆ°ç›¸åŒåŠŸèƒ½.</p>
<p>ä¸èƒ½å¾ˆå¥½å¯¹åº”çš„æƒ…å½¢æœ‰:</p>
<p>1.ç”¨æŒ‡é’ˆåšç´¢å¼•</p>
<p>2.if (æŸæŒ‡é’ˆ) ç­‰åšåˆ¤æ–­</p>
<p><strong>ä¾‹:</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    // create two arrays we care about
    int ages[] = {23, 43, 12, 89, 2};
    char *names[] = {
        &quot;Alan&quot;, &quot;Frank&quot;,
        &quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;
    };
    // safely get the size of ages
    int count = sizeof(ages) / sizeof(int);
    int i = 0;
    // first way using indexing
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s has %d years alive.\n&quot;,
                names[i], ages[i]);
    }
    // setup the pointers to the start of the arrays
    int *cur_age = ages;
    char **cur_name = names;
    // second way using pointers
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old.\n&quot;,
                *(cur_name+i), *(cur_age+i));
    }
    // third way, pointers are just arrays
    for(i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old again.\n&quot;,
                cur_name[i], cur_age[i]);
    }
    // fourth way with pointers in a stupid complex way
    for(cur_name = names, cur_age = ages;
            (cur_age - ages) &lt; count;
            cur_name++, cur_age++)
    {
        printf(&quot;%s lived %d years so far.\n&quot;,
                *cur_name, *cur_age);
    }
    return 0;
}
</code></pre>
<p>å¦‚æœç”Ÿç¡¬ç¿»è¯‘æˆrust</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::*;

fn main() {

    let mut ages = [23,43,12,89,2];
    let mut names = [&quot;Alan&quot;, &quot;Frank&quot;,&quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;];

    let count = size_of_val(&amp;ages) / size_of::&lt;i32&gt;();
    // let count = ages.len();

    for i in 0..count {
        println!(&quot;{} has {} years alive.&quot;,names[i], ages[i]);
    }
    println!(&quot;----\n&quot;);
    let cur_age = ages.as_mut_ptr();
    let cur_name = names.as_mut_ptr();
    
    for i in 0..count{
        unsafe {
            println!(&quot;{} is {} years old.&quot;, 
            *cur_name.offset(i as isize), 
            *cur_age.offset(i as isize));
        }
    }
    println!(&quot;----\n&quot;);

    unsafe { 
        let cur_age1 = core::slice::from_raw_parts_mut(ages.as_ptr() as *mut i32, count);
        for i in 0..count{
            println!(&quot;xxxx is {} years old.&quot;,  cur_age1[i])
        }
    }
    
}
</code></pre></pre>
<p>ç›®å‰æ”¶é›†åˆ°çš„æ–¹æ³•æœ‰:</p>
<p>1.å¾—åˆ°ä¸€ä¸ªå¯å¯¹æ•°æ®è¿›è¡Œä¿®æ”¹çš„æŒ‡é’ˆ  ç„¶åä»¥å­—èŠ‚å•ä½è®¡ç®—åç§»é‡.ä¸èƒ½è¶…è¿‡isizeå¤§å°.æ¥è¾¾åˆ°ç´¢å¼•</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cur_age = ages.as_mut_ptr()   
*cur_name.offset(i as isize)      
<span class="boring">}
</span></code></pre></pre>
<p>2.å¾—åˆ°ä¸€ä¸ªi32ç±»å‹é•¿åº¦ä¸ºcountç±»å‹çš„slice.å¯ä»¥ç†è§£ä¸ºå›ºå®šå¤§å°æ•°ç»„.</p>
<p>æ­¤æ–¹æ³•å¯¹å­—ç¬¦ä¸²æ•°ç»„æ— æ•ˆ...å¯èƒ½åŸå› :å­—ç¬¦ä¸²å¤§å°ä¸å›ºå®š.æ— æ³•å‡†ç¡®è®¡ç®—å¤§å°??</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>from_raw_parts_mut(ages.as_ptr() as *mut i32, count)
<span class="boring">}
</span></code></pre></pre>
<p><strong>æ›´å¤šæœ‰å…³åŸå§‹æŒ‡é’ˆå¯æŸ¥é˜…å®˜æ–¹æ–‡æ¡£</strong>:<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset">https://doc.rust-lang.org/std/primitive.pointer.html#method.offset</a></p>
<p>è¯¥æ–‡æ¡£ç¬¬ä¸€å¥è¯<strong>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</strong></p>
<p>åœ¨æœ‰æ›¿ä»£æ–¹æ³•æ—¶å€™è¿˜æ˜¯å»ºè®®é¿å…ä½¿ç”¨.</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>leetcode</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨:https://leetcode-cn.com/problems/merge-two-sorted-lists/
pub fn merge_two_lists(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        match (l1, l2) {
            (Some(n1), None) =&gt; Some(n1),
            (None, Some(n2)) =&gt; Some(n2),

            (Some(mut n1), Some(mut n2)) =&gt; {
                if n1.val &lt; n2.val {
                    let n = n1.next.take();
                    n1.next = merge_two_lists(n, Some(n2));
                    Some(n1)
                } else {
                    let n = n2.next.take();
                    n2.next = merge_two_lists(Some(n1), n);
                    Some(n2)
                }
            },
            _ =&gt; None,
        }
}
<span class="boring">}
</span></code></pre></pre>
<p>matchå¯ä»¥æ¥å—å¤šä¸ªå€¼.ä»¥å…ƒç»„å½¢å¼å­˜åœ¨</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustå­¦ä¹ è®°å½•-2"><a class="header" href="#-rustå­¦ä¹ è®°å½•-2">ğŸš§ rustå­¦ä¹ è®°å½•</a></h1>
<h2 id="è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-2"><a class="header" href="#è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°-2">è¿™é‡Œä¸»è¦è®°å½•ä¸€äº›cå®ç°çš„osä¸€äº›å¸¸ç”¨æ•°æ®ç»“æ„å·²ç»æ“ä½œåœ¨rustä¸­æ€ä¹ˆå®ç°</a></h2>
<p><strong>çœ‹ä¸€ä¸ªcè¯­è¨€ä¾‹å­</strong></p>
<pre><code class="language-c">char  *_fx_directory_name_extract(char *source_ptr, char *dest_ptr){

    unsigned int i;
    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/')){
        /* Advance the string pointer.  */
        source_ptr++;
    }
    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' '){

        /* Position past leading space.  */
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
        {
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;

        /* Increment the character counter.  */
        i++;
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;

    /* Determine if we can backup to the previous character.  */
    if (i)
    {

        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}

</code></pre>
<p><strong>ä»¥ä¸‹æ˜¯rustå®ç°</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fx_directory_name_extract(source: &amp;String, dest:&amp;mut String) -&gt; Option&lt;String&gt; {

    let mut idx: usize = 0;
    let mut j: usize;

    // /* Is a backslash present?  */
    if( (source.as_bytes()[0] == b'\\') || (source.as_bytes()[0] == b'/') ){
        /* Advance the string pointer.  */
        idx += 1;
    }


    /* Loop to remove any leading spaces.  */
    while( source.as_bytes()[idx] == b' '){
        /* Position past leading space.  */
        idx+= 1;
    }

    j = 0;
    for (i, c) in source.chars().enumerate() {
        j+=1;
        if i &lt; idx {
            continue;
        }

        if( (c == '\\') || (c == '/')){
            j-=1;
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
            FX_MAX_LONG_NAME_LEN define.  */
        if (i == 256 - 1){
            break;
        }
        dest.push(c);
    }

    /* Determine if the source string is now at the end.  */
    if ( j == source.len()) {
        /* Yes, return a NULL pointer.  */
        return None;
    }
    
    return Some( source[j..].to_string());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-foo"><a class="header" href="#-foo">ğŸš§ foo</a></h1>
<p><strong>è®°å½•ä¸€äº›æ–°æŠ€èƒ½</strong></p>
<p><strong>docker</strong>
åœ¨é…ç½®github+gitpodä¸­å­¦ä¹ äº†dockerçš„åŸºæœ¬ç”¨æ³•åŒ…æ‹¬imageç”Ÿæˆ.containerä½¿ç”¨</p>
<p><br/> </br></p>
<p><strong>è·å–åŸºç¡€é•œåƒ</strong></p>
<p>å¦‚æœæˆ‘ä»¬æœ¬åœ°æ²¡æœ‰ ubuntu é•œåƒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ docker pull å‘½ä»¤æ¥è½½å…¥ ubuntu é•œåƒ</p>
<pre><code class="language-shell">$ docker pull ubuntu
</code></pre>
<p><strong>å¯åŠ¨å®¹å™¨</strong></p>
<pre><code>$ docker run -it ubuntu /bin/bash
</code></pre>
<p><strong>å®‰è£…ç¯å¢ƒ(ç•¥)</strong></p>
<p><strong>æ¨é€é•œåƒåˆ°Docker Hub</strong></p>
<p>éœ€è¦åœ¨docker hubä¸Šæ³¨å†Œè´¦æˆ·,åˆ›å»ºä»“åº“</p>
<p>ç™»å…¥docker</p>
<pre><code class="language-shell">$ docker login 
</code></pre>
<p>ä¿®æ”¹æ ‡ç­¾</p>
<pre><code class="language-shell">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
</code></pre>
<p>æ¨é€</p>
<pre><code class="language-shell">$ docker push username/repository:[tag]
</code></pre>
<p><strong>æŸ¥çœ‹æœ¬åœ°å®¹å™¨,é•œåƒ</strong></p>
<pre><code class="language-shell">$ docker images
$ docker ps -a
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
