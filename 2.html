<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>riscv-privileged</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ÂºÄÂßã‰πãÂâç</a></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">1.</strong> üöß rustÂ≠¶‰π†ËÆ∞ÂΩï</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="daliy/7-2.html"><strong aria-hidden="true">1.1.</strong> 7.2</a></li><li class="chapter-item expanded "><a href="daliy/7-3.html"><strong aria-hidden="true">1.2.</strong> 7.3</a></li><li class="chapter-item expanded "><a href="daliy/7-4.html"><strong aria-hidden="true">1.3.</strong> 7.4</a></li><li class="chapter-item expanded "><a href="daliy/7-5.html"><strong aria-hidden="true">1.4.</strong> 7.5</a></li><li class="chapter-item expanded "><a href="daliy/7-6.html"><strong aria-hidden="true">1.5.</strong> 7.6</a></li><li class="chapter-item expanded "><a href="daliy/7-7.html"><strong aria-hidden="true">1.6.</strong> 7.7</a></li><li class="chapter-item expanded "><a href="1.html"><strong aria-hidden="true">1.7.</strong> RISC-V-Reader</a></li><li class="chapter-item expanded "><a href="2.html" class="active"><strong aria-hidden="true">1.8.</strong> riscv-privileged</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">2.</strong> üöß c2rust</a></li><li class="chapter-item expanded "><a href="foo.html"><strong aria-hidden="true">3.</strong> üöß foo</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="the-risc-v-instruction-set-manual"><a class="header" href="#the-risc-v-instruction-set-manual">The RISC-V Instruction Set Manual</a></h3>
<h4 id="volume-ii-privileged-architecture"><a class="header" href="#volume-ii-privileged-architecture">Volume II: Privileged Architecture</a></h4>
<h4 id="document-version-20190608-priv-msu-ratified"><a class="header" href="#document-version-20190608-priv-msu-ratified">Document Version 20190608-Priv-MSU-Ratified</a></h4>
<h4 id="editors-andrew-waterman1--krste-asanovi-c1-2"><a class="header" href="#editors-andrew-waterman1--krste-asanovi-c1-2">Editors: Andrew Waterman^1 , Krste Asanovi ÃÅc^1 ,^2</a></h4>
<p>(^1) SiFive Inc.,
(^2) CS Division, EECS Department, University of California, Berkeley</p>
<h4 id="andrewsifivecom-krsteberkeleyedu"><a class="header" href="#andrewsifivecom-krsteberkeleyedu">andrew@sifive.com, krste@berkeley.edu</a></h4>
<h4 id="june-8-2019"><a class="header" href="#june-8-2019">June 8, 2019</a></h4>
<p>Contributors to all versions of the spec in alphabetical order (please contact editors to suggest
corrections): Krste Asanovi ÃÅc, Peter Ashenden, Rimas AviÀázienis, Jacob Bachmeyer, Allen J. Baum,
Paolo Bonzini, Ruslan Bukin, Christopher Celio, Chuanhua Chang, David Chisnall, Anthony Coul-
ter, Palmer Dabbelt, Monte Dalrymple, Dennis Ferguson, Gary Guo, Mike Frysinger, John Hauser,
David Horner, Olof Johansson, David Kruckemyer, Yunsup Lee, Andrew Lutomirski, Prashanth
Mundkur, Jonathan Neusch Ãàafer, Rishiyur Nikhil, Stefan O‚ÄôRear, Albert Ou, John Ousterhout,
David Patterson, Dmitri Pavlov, Kade Phillips, Josh Scheid, Colin Schmidt, Michael Taylor, Wes-
ley Terpstra, Matt Thomas, Tommy Thorn, Ray VanDeWalker, Megan Wachs, Steve Wallach,
Andrew Waterman, Clifford Wolf, and Reinoud Zandijk.</p>
<p>This document is released under a Creative Commons Attribution 4.0 International License.</p>
<p>This document is a derivative of the RISC-V privileged specification version 1.9.1 released under
following license:‚Éùc2010‚Äì2017 Andrew Waterman, Yunsup Lee, Rimas AviÀázienis, David Patterson,
Krste Asanovi ÃÅc. Creative Commons Attribution 4.0 International License.</p>
<p>Please cite as: ‚ÄúThe RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Document
Version 20190608-Priv-MSU-Ratified‚Äù, Editors Andrew Waterman and Krste Asanovi ÃÅc, RISC-V
Foundation, June 2019.</p>
<h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This document describes the RISC-V privileged architecture. This release, version
20190608-Priv-MSU-Ratified, represents the ratified 1.11 version of the machine and supervisor
ISA modules.</p>
<p>The document contains the following versions of the RISC-V ISA modules:</p>
<pre><code>Module Version Status
Machine ISA 1.11 Ratified
Supervisor ISA 1.11 Ratified
</code></pre>
<p>The changes in this version of the document include:</p>
<ul>
<li>Moved Machine and Supervisor spec toRatifiedstatus.</li>
<li>Improvements to the description and commentary.</li>
<li>Added a draft proposal for a hypervisor extension.</li>
<li>Specified which interrupt sources are reserved for standard use.</li>
<li>Allocated some synchronous exception causes for custom use.</li>
<li>Specified the priority ordering of synchronous exceptions.</li>
<li>Added specification that xRET instructions may, but are not required to, clear LR reserva-
tions if A extension present.</li>
<li>The virtual-memory system no longer permits supervisor mode to execute instructions from
user pages, regardless of the SUM setting.</li>
<li>Software is strongly recommended to allocate ASIDs globally, so that a future extension can
globalize ASIDs for improved performance and hardware flexibility.</li>
<li>SFENCE.VMA semantics have been clarified.</li>
<li>Made themstatus.MPP fieldWARL, rather thanWLRL.</li>
<li>Made the unusedxipfieldsWPRI, rather thanWIRI.</li>
<li>Made the unusedmisafieldsWLRL, rather thanWIRI.</li>
<li>Made the unusedpmpaddrandpmpcfgfieldsWARL, rather thanWIRI.</li>
<li>Required all harts in a system to employ the same PTE-update scheme as each other.</li>
<li>Rectified an editing error that misdescribed the mechanism by whichmstatus.xIE is written
upon an exception.</li>
<li>Described scheme for emulating misaligned AMOs.</li>
<li>Specified the behavior of themisaandxepcregisters in systems with variable IALIGN.</li>
<li>Specified the behavior of writing self-contradictory values to themisaregister.</li>
<li>Defined themcountinhibitCSR, which stops performance counters from incrementing to
reduce energy consumption.</li>
</ul>
<pre><code>i
</code></pre>
<p>ii Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified</p>
<ul>
<li>Specified semantics for PMP regions coarser than four bytes.</li>
<li>Specified contents of CSRs across XLEN modification.</li>
<li>Moved PLIC chapter into its own document.</li>
</ul>
<p>Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified iii</p>
<h3 id="preface-to-version-1"><a class="header" href="#preface-to-version-1">Preface to Version 1.</a></h3>
<p>This is version 1.10 of the RISC-V privileged architecture proposal. Changes from version 1.9.
include:</p>
<ul>
<li>The previous version of this document was released under a Creative Commons Attribution
4.0 International License by the original authors, and this and future versions of this document
will be released under the same license.</li>
<li>The explicit convention on shadow CSR addresses has been removed to reclaim CSR space.
Shadow CSRs can still be added as needed.</li>
<li>Themvendoridregister now contains the JEDEC code of the core provider as opposed to
a code supplied by the Foundation. This avoids redundancy and offloads work from the
Foundation.</li>
<li>The interrupt-enable stack discipline has been simplified.</li>
<li>An optional mechanism to change the base ISA used by supervisor and user modes has been
added to themstatusCSR, and the field previously called Base inmisahas been renamed
toMXLfor consistency.</li>
<li>Clarified expected use of XS to summarize additional extension state status fields inmstatus.</li>
<li>Optional vectored interrupt support has been added to themtvecandstvecCSRs.</li>
<li>The SEIP and UEIP bits in themipCSR have been redefined to support software injection
of external interrupts.</li>
<li>Thembadaddrregister has been subsumed by a more generalmtvalregister that can now
capture bad instruction bits on an illegal instruction fault to speed instruction emulation.</li>
<li>The machine-mode base-and-bounds translation and protection schemes have been removed
from the specification as part of moving the virtual memory configuration tosptbr(now
satp). Some of the motivation for the base and bound schemes are now covered by the PMP
registers, but space remains available inmstatusto add these back at a later date if deemed
useful.</li>
<li>In systems with only M-mode, or with both M-mode and U-mode but without U-mode
trap support, themedelegandmidelegregisters now do not exist, whereas previously they
returned zero.</li>
<li>Virtual-memory page faults now havemcausevalues distinct from physical-memory access
exceptions. Page-fault exceptions can now be delegated to S-mode without delegating excep-
tions generated by PMA and PMP checks.</li>
<li>An optional physical-memory protection (PMP) scheme has been proposed.</li>
<li>The supervisor virtual memory configuration has been moved from themstatusregister to
thesptbrregister. Accordingly, thesptbrregister has been renamed tosatp(Supervisor
Address Translation and Protection) to reflect its broadened role.</li>
<li>The SFENCE.VM instruction has been removed in favor of the improved SFENCE.VMA
instruction.</li>
<li>Themstatusbit MXR has been exposed to S-mode viasstatus.</li>
<li>The polarity of the PUM bit insstatushas been inverted to shorten code sequences involving
MXR. The bit has been renamed to SUM.</li>
<li>Hardware management of page-table entry Accessed and Dirty bits has been made optional;
simpler implementations may trap to software to set them.</li>
</ul>
<p>iv Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified</p>
<ul>
<li>The counter-enable scheme has changed, so that S-mode can control availability of counters
to U-mode.</li>
<li>H-mode has been removed, as we are focusing on recursive virtualization support in S-mode.
The encoding space has been reserved and may be repurposed at a later date.</li>
<li>A mechanism to improve virtualization performance by trapping S-mode virtual-memory
management operations has been added.</li>
<li>The Supervisor Binary Interface (SBI) chapter has been removed, so that it can be maintained
as a separate specification.</li>
</ul>
<p>Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified v</p>
<h3 id="preface-to-version-19"><a class="header" href="#preface-to-version-19">Preface to Version 1.9.</a></h3>
<p>This is version 1.9.1 of the RISC-V privileged architecture proposal. Changes from version 1.
include:</p>
<ul>
<li>Numerous additions and improvements to the commentary sections.</li>
<li>Change configuration string proposal to be use a search process that supports various formats
including Device Tree String and flattened Device Tree.</li>
<li>Made misaoptionally writable to support modifying base and supported ISA extensions.
CSR address ofmisachanged.</li>
<li>Added description of debug mode and debug CSRs.</li>
<li>Added a hardware performance monitoring scheme. Simplified the handling of existing hard-
ware counters, removing privileged versions of the counters and the corresponding delta reg-
isters.</li>
<li>Fixed description of SPIE in presence of user-level interrupts.</li>
</ul>
<p>vi Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified</p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ul>
<li>1 Introduction Preface i
<ul>
<li>1.1 RISC-V Privileged Software Stack Terminology</li>
<li>1.2 Privilege Levels</li>
<li>1.3 Debug Mode</li>
</ul>
</li>
<li>2 Control and Status Registers (CSRs)
<ul>
<li>2.1 CSR Address Mapping Conventions</li>
<li>2.2 CSR Listing</li>
<li>2.3 CSR Field Specifications</li>
<li>2.4 CSR Width Modulation</li>
</ul>
</li>
<li>3 Machine-Level ISA, Version 1.11
<ul>
<li>3.1 Machine-Level CSRs
<ul>
<li>3.1.1 Machine ISA Registermisa</li>
<li>3.1.2 Machine Vendor ID Registermvendorid</li>
<li>3.1.3 Machine Architecture ID Registermarchid</li>
<li>3.1.4 Machine Implementation ID Registermimpid</li>
<li>3.1.5 Hart ID Registermhartid.</li>
<li>3.1.6 Machine Status Register (mstatus)
<ul>
<li>3.1.6.1 Privilege and Global Interrupt-Enable Stack inmstatusregister</li>
</ul>
</li>
<li>3.1.6.2 Base ISA Control inmstatusRegister viii Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified</li>
<li>3.1.6.3 Memory Privilege inmstatusRegister</li>
<li>3.1.6.4 Virtualization Support inmstatusRegister</li>
<li>3.1.6.5 Extension Context Status inmstatusRegister</li>
</ul>
</li>
<li>3.1.7 Machine Trap-Vector Base-Address Register (mtvec)</li>
<li>3.1.8 Machine Trap Delegation Registers (medelegandmideleg)</li>
<li>3.1.9 Machine Interrupt Registers (mipandmie)</li>
<li>3.1.10 Machine Timer Registers (mtimeandmtimecmp)</li>
<li>3.1.11 Hardware Performance Monitor</li>
<li>3.1.12 Counter-Enable Registers ([m|s]counteren)</li>
<li>3.1.13 Machine Counter-Inhibit CSR (mcountinhibit)</li>
<li>3.1.14 Machine Scratch Register (mscratch)</li>
<li>3.1.15 Machine Exception Program Counter (mepc)</li>
<li>3.1.16 Machine Cause Register (mcause)</li>
<li>3.1.17 Machine Trap Value (mtval) Register</li>
</ul>
</li>
<li>3.2 Machine-Mode Privileged Instructions
<ul>
<li>3.2.1 Environment Call and Breakpoint</li>
<li>3.2.2 Trap-Return Instructions</li>
<li>3.2.3 Wait for Interrupt</li>
</ul>
</li>
<li>3.3 Reset</li>
<li>3.4 Non-Maskable Interrupts</li>
<li>3.5 Physical Memory Attributes
<ul>
<li>3.5.1 Main Memory versus I/O versus Empty Regions</li>
<li>3.5.2 Supported Access Type PMAs</li>
<li>3.5.3 Atomicity PMAs</li>
<li>3.5.4 Memory-Ordering PMAs</li>
<li>3.5.5 Coherence and Cacheability PMAs</li>
<li>3.5.6 Idempotency PMAs</li>
<li>3.6 Physical Memory Protection Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified ix
<ul>
<li>3.6.1 Physical Memory Protection CSRs</li>
<li>3.6.2 Physical Memory Protection and Paging</li>
</ul>
</li>
</ul>
</li>
<li>4 Supervisor-Level ISA, Version 1.11
<ul>
<li>4.1 Supervisor CSRs
<ul>
<li>4.1.1 Supervisor Status Register (sstatus)</li>
<li>4.1.2 Base ISA Control insstatusRegister</li>
<li>4.1.3 Memory Privilege insstatusRegister</li>
<li>4.1.4 Supervisor Trap Vector Base Address Register (stvec)</li>
<li>4.1.5 Supervisor Interrupt Registers (sipandsie)</li>
<li>4.1.6 Supervisor Timers and Performance Counters</li>
<li>4.1.7 Counter-Enable Register (scounteren)</li>
<li>4.1.8 Supervisor Scratch Register (sscratch)</li>
<li>4.1.9 Supervisor Exception Program Counter (sepc)</li>
<li>4.1.10 Supervisor Cause Register (scause)</li>
<li>4.1.11 Supervisor Trap Value (stval) Register</li>
<li>4.1.12 Supervisor Address Translation and Protection (satp) Register</li>
</ul>
</li>
<li>4.2 Supervisor Instructions
<ul>
<li>4.2.1 Supervisor Memory-Management Fence Instruction</li>
</ul>
</li>
<li>4.3 Sv32: Page-Based 32-bit Virtual-Memory Systems
<ul>
<li>4.3.1 Addressing and Memory Protection</li>
<li>4.3.2 Virtual Address Translation Process</li>
</ul>
</li>
<li>4.4 Sv39: Page-Based 39-bit Virtual-Memory System
<ul>
<li>4.4.1 Addressing and Memory Protection</li>
</ul>
</li>
<li>4.5 Sv48: Page-Based 48-bit Virtual-Memory System
<ul>
<li>4.5.1 Addressing and Memory Protection</li>
</ul>
</li>
</ul>
</li>
<li>5 RISC-V Privileged Instruction Set Listings</li>
</ul>
<p>x Volume II: RISC-V Privileged Architectures V20190608-Priv-MSU-Ratified</p>
<p>6 History 77</p>
<pre><code>6.1 Research Funding at UC Berkeley............................ 77
</code></pre>
<h2 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h2>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document describes the RISC-V privileged architecture, which covers all aspects of RISC-
V systems beyond the unprivileged ISA, including privileged instructions as well as additional
functionality required for running operating systems and attaching external devices.</p>
<pre><code>Commentary on our design decisions is formatted as in this paragraph, and can be skipped if the
reader is only interested in the specification itself.
</code></pre>
<pre><code>We briefly note that the entire privileged-level design described in this document could be replaced
with an entirely different privileged-level design without changing the unprivileged ISA, and pos-
sibly without even changing the ABI. In particular, this privileged specification was designed to
run existing popular operating systems, and so embodies the conventional level-based protection
model. Alternate privileged specifications could embody other more flexible protection-domain
models. For simplicity of expression, the text is written as if this was the only possible privileged
architecture.
</code></pre>
<h3 id="11-risc-v-privileged-software-stack-terminology"><a class="header" href="#11-risc-v-privileged-software-stack-terminology">1.1 RISC-V Privileged Software Stack Terminology</a></h3>
<p>This section describes the terminology we use to describe components of the wide range of possible
privileged software stacks for RISC-V.</p>
<p>Figure 1.1 shows some of the possible software stacks that can be supported by the RISC-V archi-
tecture. The left-hand side shows a simple system that supports only a single application running
on an application execution environment (AEE). The application is coded to run with a particular
application binary interface (ABI). The ABI includes the supported user-level ISA plus a set of
ABI calls to interact with the AEE. The ABI hides details of the AEE from the application to al-
low greater flexibility in implementing the AEE. The same ABI could be implemented natively on
multiple different host OSs, or could be supported by a user-mode emulation environment running
on a machine with a different native ISA.</p>
<pre><code>Our graphical convention represents abstract interfaces using black boxes with white text, to
separate them from concrete instances of components implementing the interfaces.
</code></pre>
<pre><code>1
</code></pre>
<pre><code>Application
ABI
AEE
</code></pre>
<pre><code>Application
ABI
OS
SBI
SEE
</code></pre>
<pre><code>Application
ABI
</code></pre>
<pre><code>SBI
Hypervisor
</code></pre>
<pre><code>Application
ABI
OS
</code></pre>
<pre><code>Application
ABI
</code></pre>
<pre><code>Application
ABI
OS
</code></pre>
<pre><code>Application
ABI
</code></pre>
<pre><code>SBI
</code></pre>
<pre><code>HBI
HEE
</code></pre>
<pre><code>Figure 1.1: Different implementation stacks supporting various forms of privileged execution.
</code></pre>
<p>The middle configuration shows a conventional operating system (OS) that can support multipro-
grammed execution of multiple applications. Each application communicates over an ABI with
the OS, which provides the AEE. Just as applications interface with an AEE via an ABI, RISC-V
operating systems interface with a supervisor execution environment (SEE) via a supervisor binary
interface (SBI). An SBI comprises the user-level and supervisor-level ISA together with a set of
SBI function calls. Using a single SBI across all SEE implementations allows a single OS binary
image to run on any SEE. The SEE can be a simple boot loader and BIOS-style IO system in a
low-end hardware platform, or a hypervisor-provided virtual machine in a high-end server, or a
thin translation layer over a host operating system in an architecture simulation environment.</p>
<pre><code>Most supervisor-level ISA definitions do not separate the SBI from the execution environment
and/or the hardware platform, complicating virtualization and bring-up of new hardware plat-
forms.
</code></pre>
<p>The rightmost configuration shows a virtual machine monitor configuration where multiple multi-
programmed OSs are supported by a single hypervisor. Each OS communicates via an SBI with
the hypervisor, which provides the SEE. The hypervisor communicates with the hypervisor execu-
tion environment (HEE) using a hypervisor binary interface (HBI), to isolate the hypervisor from
details of the hardware platform.</p>
<pre><code>The ABI, SBI, and HBI are still a work-in-progress, but we are now prioritizing support for
Type-2 hypervisors where the SBI is provided recursively by an S-mode OS.
</code></pre>
<p>Hardware implementations of the RISC-V ISA will generally require additional features beyond the
privileged ISA to support the various execution environments (AEE, SEE, or HEE).</p>
<h3 id="12-privilege-levels"><a class="header" href="#12-privilege-levels">1.2 Privilege Levels</a></h3>
<p>At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode
in one or more CSRs (control and status registers). Three RISC-V privilege levels are currently
defined as shown in Table 1.1.</p>
<p>Privilege levels are used to provide protection between different components of the software stack,
and attempts to perform operations not permitted by the current privilege mode will cause an
exception to be raised. These exceptions will normally cause traps into an underlying execution
environment.</p>
<pre><code>Level Encoding Name Abbreviation
0 00 User/Application U
1 01 Supervisor S
2 10 Reserved
3 11 Machine M
</code></pre>
<pre><code>Table 1.1: RISC-V privilege levels.
</code></pre>
<pre><code>In the description, we try to separate the privilege level for which code is written, from the
privilege mode in which it runs, although the two are often tied. For example, a supervisor-
level operating system can run in supervisor-mode on a system with three privilege modes, but
can also run in user-mode under a classic virtual machine monitor on systems with two or
more privilege modes. In both cases, the same supervisor-level operating system binary code can
be used, coded to a supervisor-level SBI and hence expecting to be able to use supervisor-level
privileged instructions and CSRs. When running a guest OS in user mode, all supervisor-level
actions will be trapped and emulated by the SEE running in the higher-privilege level.
</code></pre>
<p>The machine level has the highest privileges and is the only mandatory privilege level for a RISC-V
hardware platform. Code run in machine-mode (M-mode) is usually inherently trusted, as it has
low-level access to the machine implementation. M-mode can be used to manage secure execution
environments on RISC-V. User-mode (U-mode) and supervisor-mode (S-mode) are intended for
conventional application and operating system usage respectively.</p>
<p>Each privilege level has a core set of privileged ISA extensions with optional extensions and variants.
For example, machine-mode supports an optional standard extension for memory protection.</p>
<p>Implementations might provide anywhere from 1 to 3 privilege modes trading off reduced isolation
for lower implementation cost, as shown in Table 1.2.</p>
<pre><code>Number of levels Supported Modes Intended Usage
1 M Simple embedded systems
2 M, U Secure embedded systems
3 M, S, U Systems running Unix-like operating systems
</code></pre>
<pre><code>Table 1.2: Supported combinations of privilege modes.
</code></pre>
<p>All hardware implementations must provide M-mode, as this is the only mode that has unfettered
access to the whole machine. The simplest RISC-V implementations may provide only M-mode,
though this will provide no protection against incorrect or malicious application code.</p>
<pre><code>The lock feature of the optional PMP facility can provide some limited protection even with only
M-mode implemented.
</code></pre>
<p>Many RISC-V implementations will also support at least user mode (U-mode) to protect the rest
of the system from application code. Supervisor mode (S-mode) can be added to provide isolation
between a supervisor-level operating system and the SEE.</p>
<p>A hart normally runs application code in U-mode until some trap (e.g., a supervisor call or a timer
interrupt) forces a switch to a trap handler, which usually runs in a more privileged mode. The hart</p>
<p>will then execute the trap handler, which will eventually resume execution at or after the original
trapped instruction in U-mode. Traps that increase privilege level are termedverticaltraps, while
traps that remain at the same privilege level are termedhorizontaltraps. The RISC-V privileged
architecture provides flexible routing of traps to different privilege layers.</p>
<pre><code>Horizontal traps can be implemented as vertical traps that return control to a horizontal trap
handler in the less-privileged mode.
</code></pre>
<h3 id="13-debug-mode"><a class="header" href="#13-debug-mode">1.3 Debug Mode</a></h3>
<p>Implementations may also include a debug mode to support off-chip debugging and/or manufac-
turing test. Debug mode (D-mode) can be considered an additional privilege mode, with even more
access than M-mode. The separate debug specification proposal describes operation of a RISC-V
hart in debug mode. Debug mode reserves a few CSR addresses that are only accessible in D-mode,
and may also reserve some portions of the physical address space on a platform.</p>
<h2 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h2>
<h1 id="control-and-status-registers-csrs"><a class="header" href="#control-and-status-registers-csrs">Control and Status Registers (CSRs)</a></h1>
<p>The SYSTEM major opcode is used to encode all privileged instructions in the RISC-V ISA. These
can be divided into two main classes: those that atomically read-modify-write control and status
registers (CSRs), and all other privileged instructions. In addition to the user-level state described
in Volume I of this manual, an implementation may contain additional CSRs, accessible by some
subset of the privilege levels using the CSR instructions described in the user-level manual. In
this chapter, we map out the CSR address space. The following chapters describe the function of
each of the CSRs according to privilege level, as well as the other privileged instructions which
are generally closely associated with a particular privilege level. Note that although CSRs and
instructions are associated with one privilege level, they are also accessible at all higher privilege
levels.</p>
<h3 id="21-csr-address-mapping-conventions"><a class="header" href="#21-csr-address-mapping-conventions">2.1 CSR Address Mapping Conventions</a></h3>
<p>The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs.
By convention, the upper 4 bits of the CSR address (csr[11:8]) are used to encode the read and
write accessibility of the CSRs according to privilege level as shown in Table 2.1. The top two bits
(csr[11:10]) indicate whether the register is read/write ( 00 , 01 , or 10 ) or read-only ( 11 ). The next
two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.</p>
<pre><code>The CSR address convention uses the upper bits of the CSR address to encode default access
privileges. This simplifies error checking in the hardware and provides a larger CSR space, but
does constrain the mapping of CSRs into the address space.
Implementations might allow a more-privileged level to trap otherwise permitted CSR ac-
cesses by a less-privileged level to allow these accesses to be intercepted. This change should be
transparent to the less-privileged software.
</code></pre>
<p>Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a
CSR without appropriate privilege level or to write a read-only register also raise illegal instruction
exceptions. A read/write register might also contain some bits that are read-only, in which case
writes to the read-only bits are ignored.</p>
<pre><code>5
</code></pre>
<p>Table 2.1 also indicates the convention to allocate CSR addresses between standard and custom uses.
The CSR addresses reserved for custom uses will not be redefined by future standard extensions.</p>
<p>Machine-mode standard read-write CSRs0x7A0‚Äì0x7BFare reserved for use by the debug system.
Of these CSRs,0x7A0‚Äì0x7AFare accessible to machine mode, whereas0x7B0‚Äì0x7BFare only visible
to debug mode. Implementations should raise illegal instruction exceptions on machine-mode access
to the latter set of registers.</p>
<pre><code>Effective virtualization requires that as many instructions run natively as possible inside a virtu-
alized environment, while any privileged accesses trap to the virtual machine monitor [1]. CSRs
that are read-only at some lower privilege level are shadowed into separate CSR addresses if they
are made read-write at a higher privilege level. This avoids trapping permitted lower-privilege ac-
cesses while still causing traps on illegal accesses. Currently, the counters are the only shadowed
CSRs.
</code></pre>
<h3 id="22-csr-listing"><a class="header" href="#22-csr-listing">2.2 CSR Listing</a></h3>
<p>Tables 2.2‚Äì2.5 list the CSRs that have currently been allocated CSR addresses. The timers, coun-
ters, and floating-point CSRs are standard user-level CSRs, as well as the additional user trap
registers added by the N extension. The other registers are used by privileged code, as described
in the following chapters. Note that not all registers are required on all implementations.</p>
<p>CSR Address Hex Use and Accessibility
[11:10] [9:8] [7:4]
User CSRs
00 00 XXXX 0x000-0x0FF Standard read/write
01 00 XXXX 0x400-0x4FF Standard read/write
10 00 XXXX 0x800-0x8FF Custom read/write
11 00 0XXX 0xC00-0xC7F Standard read-only
11 00 10XX 0xC80-0xCBF Standard read-only
11 00 11XX 0xCC0-0xCFF Custom read-only
Supervisor CSRs
00 01 XXXX 0x100-0x1FF Standard read/write
01 01 0XXX 0x500-0x57F Standard read/write
01 01 10XX 0x580-0x5BF Standard read/write
01 01 11XX 0x5C0-0x5FF Custom read/write
10 01 0XXX 0x900-0x97F Standard read/write
10 01 10XX 0x980-0x9BF Standard read/write
10 01 11XX 0x9C0-0x9FF Custom read/write
11 01 0XXX 0xD00-0xD7F Standard read-only
11 01 10XX 0xD80-0xDBF Standard read-only
11 01 11XX 0xDC0-0xDFF Custom read-only
Hypervisor CSRs
00 10 XXXX 0x200-0x2FF Standard read/write
01 10 0XXX 0x600-0x67F Standard read/write
01 10 10XX 0x680-0x6BF Standard read/write
01 10 11XX 0x6C0-0x6FF Custom read/write
10 10 0XXX 0xA00-0xA7F Standard read/write
10 10 10XX 0xA80-0xABF Standard read/write
10 10 11XX 0xAC0-0xAFF Custom read/write
11 10 0XXX 0xE00-0xE7F Standard read-only
11 10 10XX 0xE80-0xEBF Standard read-only
11 10 11XX 0xEC0-0xEFF Custom read-only
Machine CSRs
00 11 XXXX 0x300-0x3FF Standard read/write
01 11 0XXX 0x700-0x77F Standard read/write
01 11 100X 0x780-0x79F Standard read/write
01 11 1010 0x7A0-0x7AF Standard read/write debug CSRs
01 11 1011 0x7B0-0x7BF Debug-mode-only CSRs
01 11 11XX 0x7C0-0x7FF Custom read/write
10 11 0XXX 0xB00-0xB7F Standard read/write
10 11 10XX 0xB80-0xBBF Standard read/write
10 11 11XX 0xBC0-0xBFF Custom read/write
11 11 0XXX 0xF00-0xF7F Standard read-only
11 11 10XX 0xF80-0xFBF Standard read-only
11 11 11XX 0xFC0-0xFFF Custom read-only</p>
<pre><code>Table 2.1: Allocation of RISC-V CSR address ranges.
</code></pre>
<p>Number Privilege Name Description
User Trap Setup
0x000 URW ustatus User status register.
0x004 URW uie User interrupt-enable register.
0x005 URW utvec User trap handler base address.
User Trap Handling
0x040 URW uscratch Scratch register for user trap handlers.
0x041 URW uepc User exception program counter.
0x042 URW ucause User trap cause.
0x043 URW utval User bad address or instruction.
0x044 URW uip User interrupt pending.
User Floating-Point CSRs
0x001 URW fflags Floating-Point Accrued Exceptions.
0x002 URW frm Floating-Point Dynamic Rounding Mode.
0x003 URW fcsr Floating-Point Control and Status Register (frm+fflags).
User Counter/Timers
0xC00 URO cycle Cycle counter for RDCYCLE instruction.
0xC01 URO time Timer for RDTIME instruction.
0xC02 URO instret Instructions-retired counter for RDINSTRET instruction.
0xC03 URO hpmcounter3 Performance-monitoring counter.
0xC04 URO hpmcounter4 Performance-monitoring counter.
..
.
0xC1F URO hpmcounter31 Performance-monitoring counter.
0xC80 URO cycleh Upper 32 bits ofcycle, RV32I only.
0xC81 URO timeh Upper 32 bits oftime, RV32I only.
0xC82 URO instreth Upper 32 bits ofinstret, RV32I only.
0xC83 URO hpmcounter3h Upper 32 bits ofhpmcounter3, RV32I only.
0xC84 URO hpmcounter4h Upper 32 bits ofhpmcounter4, RV32I only.
..
.
0xC9F URO hpmcounter31h Upper 32 bits ofhpmcounter31, RV32I only.</p>
<pre><code>Table 2.2: Currently allocated RISC-V user-level CSR addresses.
</code></pre>
<p>Number Privilege Name Description
Supervisor Trap Setup
0x100 SRW sstatus Supervisor status register.
0x102 SRW sedeleg Supervisor exception delegation register.
0x103 SRW sideleg Supervisor interrupt delegation register.
0x104 SRW sie Supervisor interrupt-enable register.
0x105 SRW stvec Supervisor trap handler base address.
0x106 SRW scounteren Supervisor counter enable.
Supervisor Trap Handling
0x140 SRW sscratch Scratch register for supervisor trap handlers.
0x141 SRW sepc Supervisor exception program counter.
0x142 SRW scause Supervisor trap cause.
0x143 SRW stval Supervisor bad address or instruction.
0x144 SRW sip Supervisor interrupt pending.
Supervisor Protection and Translation
0x180 SRW satp Supervisor address translation and protection.</p>
<pre><code>Table 2.3: Currently allocated RISC-V supervisor-level CSR addresses.
</code></pre>
<p>Number Privilege Name Description
Machine Information Registers
0xF11 MRO mvendorid Vendor ID.
0xF12 MRO marchid Architecture ID.
0xF13 MRO mimpid Implementation ID.
0xF14 MRO mhartid Hardware thread ID.
Machine Trap Setup
0x300 MRW mstatus Machine status register.
0x301 MRW misa ISA and extensions
0x302 MRW medeleg Machine exception delegation register.
0x303 MRW mideleg Machine interrupt delegation register.
0x304 MRW mie Machine interrupt-enable register.
0x305 MRW mtvec Machine trap-handler base address.
0x306 MRW mcounteren Machine counter enable.
Machine Trap Handling
0x340 MRW mscratch Scratch register for machine trap handlers.
0x341 MRW mepc Machine exception program counter.
0x342 MRW mcause Machine trap cause.
0x343 MRW mtval Machine bad address or instruction.
0x344 MRW mip Machine interrupt pending.
Machine Memory Protection
0x3A0 MRW pmpcfg0 Physical memory protection configuration.
0x3A1 MRW pmpcfg1 Physical memory protection configuration, RV32 only.
0x3A2 MRW pmpcfg2 Physical memory protection configuration.
0x3A3 MRW pmpcfg3 Physical memory protection configuration, RV32 only.
0x3B0 MRW pmpaddr0 Physical memory protection address register.
0x3B1 MRW pmpaddr1 Physical memory protection address register.
..
.
0x3BF MRW pmpaddr15 Physical memory protection address register.</p>
<pre><code>Table 2.4: Currently allocated RISC-V machine-level CSR addresses.
</code></pre>
<p>Number Privilege Name Description
Machine Counter/Timers
0xB00 MRW mcycle Machine cycle counter.
0xB02 MRW minstret Machine instructions-retired counter.
0xB03 MRW mhpmcounter3 Machine performance-monitoring counter.
0xB04 MRW mhpmcounter4 Machine performance-monitoring counter.
..
.
0xB1F MRW mhpmcounter31 Machine performance-monitoring counter.
0xB80 MRW mcycleh Upper 32 bits ofmcycle, RV32I only.
0xB82 MRW minstreth Upper 32 bits ofminstret, RV32I only.
0xB83 MRW mhpmcounter3h Upper 32 bits ofmhpmcounter3, RV32I only.
0xB84 MRW mhpmcounter4h Upper 32 bits ofmhpmcounter4, RV32I only.
..
.
0xB9F MRW mhpmcounter31h Upper 32 bits ofmhpmcounter31, RV32I only.
Machine Counter Setup
0x320 MRW mcountinhibit Machine counter-inhibit register.
0x323 MRW mhpmevent3 Machine performance-monitoring event selector.
0x324 MRW mhpmevent4 Machine performance-monitoring event selector.
..
.
0x33F MRW mhpmevent31 Machine performance-monitoring event selector.
Debug/Trace Registers (shared with Debug Mode)
0x7A0 MRW tselect Debug/Trace trigger register select.
0x7A1 MRW tdata1 First Debug/Trace trigger data register.
0x7A2 MRW tdata2 Second Debug/Trace trigger data register.
0x7A3 MRW tdata3 Third Debug/Trace trigger data register.
Debug Mode Registers
0x7B0 DRW dcsr Debug control and status register.
0x7B1 DRW dpc Debug PC.
0x7B2 DRW dscratch0 Debug scratch register 0.
0x7B3 DRW dscratch1 Debug scratch register 1.</p>
<pre><code>Table 2.5: Currently allocated RISC-V machine-level CSR addresses.
</code></pre>
<h3 id="23-csr-field-specifications"><a class="header" href="#23-csr-field-specifications">2.3 CSR Field Specifications</a></h3>
<p>The following definitions and abbreviations are used in specifying the behavior of fields within the
CSRs.</p>
<h4 id="reserved-writes-preserve-values-reads-ignore-values-wpri"><a class="header" href="#reserved-writes-preserve-values-reads-ignore-values-wpri">Reserved Writes Preserve Values, Reads Ignore Values (WPRI)</a></h4>
<p>Some whole read/write fields are reserved for future use. Software should ignore the values read
from these fields, and should preserve the values held in these fields when writing values to other
fields of the same register. For forward compatibility, implementations that do not furnish these
fields must hardwire them to zero. These fields are labeledWPRIin the register descriptions.</p>
<pre><code>To simplify the software model, any backward-compatible future definition of previously reserved
fields within a CSR must cope with the possibility that a non-atomic read/modify/write sequence
is used to update other fields in the CSR. Alternatively, the original CSR definition must specify
that subfields can only be updated atomically, which may require a two-instruction clear bit/set
bit sequence in general that can be problematic if intermediate values are not legal.
</code></pre>
<h4 id="writeread-only-legal-values-wlrl"><a class="header" href="#writeread-only-legal-values-wlrl">Write/Read Only Legal Values (WLRL)</a></h4>
<p>Some read/write CSR fields specify behavior for only a subset of possible bit encodings, with other
bit encodings reserved. Software should not write anything other than legal values to such a field,
and should not assume a read will return a legal value unless the last write was of a legal value,
or the register has not been written since another operation (e.g., reset) set the register to a legal
value. These fields are labeledWLRLin the register descriptions.</p>
<pre><code>Hardware implementations need only implement enough state bits to differentiate between the
supported values, but must always return the complete specified bit-encoding of any supported
value when read.
</code></pre>
<p>Implementations are permitted but not required to raise an illegal instruction exception if an
instruction attempts to write a non-supported value to a WLRL field. Implementations can
return arbitrary bit patterns on the read of aWLRLfield when the last write was of an illegal
value, but the value returned should deterministically depend on the illegal written value and the
value of the field prior to the write.</p>
<h4 id="write-any-values-reads-legal-values-warl"><a class="header" href="#write-any-values-reads-legal-values-warl">Write Any Values, Reads Legal Values (WARL)</a></h4>
<p>Some read/write CSR fields are only defined for a subset of bit encodings, but allow any value to be
written while guaranteeing to return a legal value whenever read. Assuming that writing the CSR
has no other side effects, the range of supported values can be determined by attempting to write
a desired setting then reading to see if the value was retained. These fields are labeledWARLin
the register descriptions.</p>
<p>Implementations will not raise an exception on writes of unsupported values to aWARLfield.
Implementations can return any legal value on the read of aWARLfield when the last write was of</p>
<p>an illegal value, but the legal value returned should deterministically depend on the illegal written
value and the value of the field prior to the write.</p>
<h3 id="24-csr-width-modulation"><a class="header" href="#24-csr-width-modulation">2.4 CSR Width Modulation</a></h3>
<p>If the width of a CSR is changed (for example, by changing MXLEN or UXLEN, as described in
Section 3.1.6.2), the values of thewritablefields and bits of the new-width CSR are, unless specified
otherwise, determined from the previous-width CSR as though by this algorithm:</p>
<ol>
<li>The value of the previous-width CSR is copied to a temporary register of the same width.</li>
<li>For the read-only bits of the previous-width CSR, the bits at the same positions in the
temporary register are set to zeros.</li>
<li>The width of the temporary register is changed to the new width. If the new widthW is
narrower than the previous width, the least-significantW bits of the temporary register are
retained and the more-significant bits are discarded. If the new width is wider than the
previous width, the temporary register is zero-extended to the wider width.</li>
<li>Each writable field of the new-width CSR takes the value of the bits at the same positions in
the temporary register.</li>
</ol>
<p>Changing the width of a CSR is not a read or write of the CSR and thus does not trigger any side
effects.</p>
<h2 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h2>
<h1 id="machine-level-isa-version-111"><a class="header" href="#machine-level-isa-version-111">Machine-Level ISA, Version 1.11</a></h1>
<p>This chapter describes the machine-level operations available in machine-mode (M-mode), which is
the highest privilege mode in a RISC-V system. M-mode is used for low-level access to a hardware
platform and is the first mode entered at reset. M-mode can also be used to implement features that
are too difficult or expensive to implement in hardware directly. The RISC-V machine-level ISA
contains a common core that is extended depending on which other privilege levels are supported
and other details of the hardware implementation.</p>
<h3 id="31-machine-level-csrs"><a class="header" href="#31-machine-level-csrs">3.1 Machine-Level CSRs</a></h3>
<p>In addition to the machine-level CSRs described in this section, M-mode code can access all CSRs
at lower privilege levels.</p>
<h4 id="311-machine-isa-registermisa"><a class="header" href="#311-machine-isa-registermisa">3.1.1 Machine ISA Registermisa</a></h4>
<p>ThemisaCSR is aWARLread-write register reporting the ISA supported by the hart. This
register must be readable in any implementation, but a value of zero can be returned to indicate
themisaregister has not been implemented, requiring that CPU capabilities be determined through
a separate non-standard mechanism.</p>
<pre><code>MXLEN-1 MXLEN-2 MXLEN-3 26 25 0
MXL[1:0] (WARL) WLRL Extensions[25:0] (WARL)
2 MXLEN-28 26
</code></pre>
<pre><code>Figure 3.1: Machine ISA register (misa).
</code></pre>
<p>The MXL (Machine XLEN) field encodes the native base integer ISA width as shown in Table 3.1.
The MXL field may be writable in implementations that support multiple base ISA widths. The
effective XLEN in M-mode,MXLEN, is given by the setting of MXL, or has a fixed value ifmisa
is zero. The MXL field is always set to the widest supported ISA variant at reset.</p>
<p>ThemisaCSR is MXLEN bits wide. If the value read frommisais nonzero, field MXL of that value</p>
<pre><code>15
</code></pre>
<h6 id="mxl-xlen"><a class="header" href="#mxl-xlen">MXL XLEN</a></h6>
<h6 id="1-32"><a class="header" href="#1-32">1 32</a></h6>
<h6 id="2-64"><a class="header" href="#2-64">2 64</a></h6>
<h6 id="3-128"><a class="header" href="#3-128">3 128</a></h6>
<pre><code>Table 3.1: Encoding of MXL field inmisa
</code></pre>
<p>always denotes the current MXLEN. If a write tomisacauses MXLEN to change, the position of
MXL moves to the most-significant two bits ofmisaat the new width.</p>
<pre><code>The base width can be quickly ascertained using branches on the sign of the returnedmisavalue,
and possibly a shift left by one and a second branch on the sign. These checks can be written
in assembly code without knowing the register width (XLEN) of the machine. The base width is
given by XLEN= 2MXL+4.
The base width can also be found ifmisais zero, by placing the immediate 4 in a register
then shifting the register left by 31 bits at a time. If zero after one shift, then the machine is
RV32. If zero after two shifts, then the machine is RV64, else RV128.
</code></pre>
<p>The Extensions field encodes the presence of the standard extensions, with a single bit per letter
of the alphabet (bit 0 encodes presence of extension ‚ÄúA‚Äù , bit 1 encodes presence of extension ‚ÄúB‚Äù,
through to bit 25 which encodes ‚ÄúZ‚Äù). The ‚ÄúI‚Äù bit will be set for RV32I, RV64I, RV128I base ISAs,
and the ‚ÄúE‚Äù bit will be set for RV32E. The Extensions field is aWARLfield that can contain
writable bits where the implementation allows the supported ISA to be modified. At reset, the
Extensions field should contain the maximal set of supported extensions, and I should be selected
over E if both are available.</p>
<p>The RV128I base ISA is not yet frozen, and while much of the remainder of this specification is
expected to apply to RV128, this version of the document focuses only on RV32 and RV64.</p>
<p>The ‚ÄúG‚Äù bit is used as an escape to allow expansion to a larger space of standard extension names.</p>
<pre><code>G is used to indicate the combination IMAFD, so is redundant in themisaCSR, hence we
reserve the bit to indicate that additional standard extensions are present.
</code></pre>
<p>The ‚ÄúU‚Äù and ‚ÄúS‚Äù bits will be set if there is support for user and supervisor modes respectively.</p>
<p>The ‚ÄúX‚Äù bit will be set if there are any non-standard extensions.</p>
<pre><code>ThemisaCSR exposes a rudimentary catalog of CPU features to machine-mode code. More
extensive information can be obtained in machine mode by probing other machine registers, and
examining other ROM storage in the system as part of the boot process.
We require that lower privilege levels execute environment calls instead of reading CPU
registers to determine features available at each privilege level. This enables virtualization layers
to alter the ISA observed at any level, and supports a much richer command interface without
burdening hardware designs.
</code></pre>
<p>The ‚ÄúE‚Äù bit is read-only. Unlessmisa is hardwired to zero, the ‚ÄúE‚Äù bit always reads as the
complement of the ‚ÄúI‚Äù bit. An implementation that supports both RV32E and RV32I can select
RV32E by clearing the ‚ÄúI‚Äù bit.</p>
<pre><code>Bit Character Description
0 A Atomic extension
1 B Tentatively reserved for Bit-Manipulation extension
2 C Compressed extension
3 D Double-precision floating-point extension
4 E RV32E base ISA
5 F Single-precision floating-point extension
6 G Additional standard extensions present
7 H Hypervisor extension
8 I RV32I/64I/128I base ISA
9 J Tentatively reserved for Dynamically Translated Languages extension
10 K Reserved
11 L Tentatively reserved for Decimal Floating-Point extension
12 M Integer Multiply/Divide extension
13 N User-level interrupts supported
14 O Reserved
15 P Tentatively reserved for Packed-SIMD extension
16 Q Quad-precision floating-point extension
17 R Reserved
18 S Supervisor mode implemented
19 T Tentatively reserved for Transactional Memory extension
20 U User mode implemented
21 V Tentatively reserved for Vector extension
22 W Reserved
23 X Non-standard extensions present
24 Y Reserved
25 Z Reserved
</code></pre>
<p>Table 3.2: Encoding of Extensions field inmisa. All bits that are reserved for future use must
return zero when read.</p>
<p>If an ISA featurexdepends on an ISA featurey, then attempting to enable featurexbut disable
featureyresults in both features being disabled. For example, setting ‚ÄúF‚Äù=0 and ‚ÄúD‚Äù=1 results
in both ‚ÄúF‚Äù and ‚ÄúD‚Äù being cleared.</p>
<p>An implementation may impose additional constraints on the collective setting of two or moremisa
fields, in which case they function collectively as a singleWARLfield. An attempt to write an
unsupported combination causes those bits to be set to some supported combination.</p>
<p>Writingmisamay increase IALIGN, e.g., by disabling the ‚ÄúC‚Äù extension. If an instruction that
would writemisaincreases IALIGN, and the subsequent instruction‚Äôs address is not IALIGN-bit
aligned, the write tomisais suppressed, leavingmisaunchanged.</p>
<h4 id="312-machine-vendor-id-registermvendorid"><a class="header" href="#312-machine-vendor-id-registermvendorid">3.1.2 Machine Vendor ID Registermvendorid</a></h4>
<p>ThemvendoridCSR is a 32-bit read-only register providing the JEDEC manufacturer ID of the
provider of the core. This register must be readable in any implementation, but a value of 0 can be
returned to indicate the field is not implemented or that this is a non-commercial implementation.</p>
<pre><code>31 7 6 0
Bank Offset
25 7
</code></pre>
<pre><code>Figure 3.2: Vendor ID register (mvendorid).
</code></pre>
<p>JEDEC manufacturer IDs are ordinarily encoded as a sequence of one-byte continuation codes0x7f,
terminated by a one-byte ID not equal to0x7f, with an odd parity bit in the most-significant bit
of each byte.mvendoridencodes the number of one-byte continuation codes in the Bank field, and
encodes the final byte in the Offset field, discarding the parity bit. For example, the JEDEC man-
ufacturer ID0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a(twelve
continuation codes followed by0x8a) would be encoded in themvendoridfield as0x60a.</p>
<pre><code>Previously the vendor ID was to be a number allocated by the RISC-V Foundation, but this
duplicates the work of JEDEC in maintaining a manufacturer ID standard. At time of writing,
registering a manufacturer ID with JEDEC has a one-time cost of$500.
</code></pre>
<h4 id="313-machine-architecture-id-registermarchid"><a class="header" href="#313-machine-architecture-id-registermarchid">3.1.3 Machine Architecture ID Registermarchid</a></h4>
<p>ThemarchidCSR is an MXLEN-bit read-only register encoding the base microarchitecture of the
hart. This register must be readable in any implementation, but a value of 0 can be returned to
indicate the field is not implemented. The combination ofmvendoridandmarchidshould uniquely
identify the type of hart microarchitecture that is implemented.</p>
<pre><code>MXLEN-1 0
Architecture ID
MXLEN
</code></pre>
<pre><code>Figure 3.3: Machine Architecture ID register (marchid).
</code></pre>
<p>Open-source project architecture IDs are allocated globally by the RISC-V Foundation, and have
non-zero architecture IDs with a zero most-significant-bit (MSB). Commercial architecture IDs are
allocated by each commercial vendor independently, but must have the MSB set and cannot contain
zero in the remaining MXLEN-1 bits.</p>
<pre><code>The intent is for the architecture ID to represent the microarchitecture associated with the repo
around which development occurs rather than a particular organization. Commercial fabrica-
tions of open-source designs should (and might be required by the license to) retain the original
architecture ID. This will aid in reducing fragmentation and tool support costs, as well as provide
attribution. Open-source architecture IDs should be administered by the Foundation and should
only be allocated to released, functioning open-source projects. Commercial architecture IDs can
be managed independently by any registered vendor but are required to have IDs disjoint from
the open-source architecture IDs (MSB set) to prevent collisions if a vendor wishes to use both
closed-source and open-source microarchitectures.
The convention adopted within the following Implementation field can be used to segregate
branches of the same architecture design, including by organization. Themisaregister also helps
distinguish different variants of a design.
</code></pre>
<h4 id="314-machine-implementation-id-registermimpid"><a class="header" href="#314-machine-implementation-id-registermimpid">3.1.4 Machine Implementation ID Registermimpid</a></h4>
<p>ThemimpidCSR provides a unique encoding of the version of the processor implementation. This
register must be readable in any implementation, but a value of 0 can be returned to indicate that
the field is not implemented. The Implementation value should reflect the design of the RISC-V
processor itself and not any surrounding system.</p>
<pre><code>MXLEN-1 0
Implementation
MXLEN
</code></pre>
<pre><code>Figure 3.4: Machine Implementation ID register (mimpid).
</code></pre>
<pre><code>The format of this field is left to the provider of the architecture source code, but will often be
printed by standard tools as a hexadecimal string without any leading or trailing zeros, so the
Implementation value can be left-justified (i.e., filled in from most-significant nibble down) with
subfields aligned on nibble boundaries to ease human readability.
</code></pre>
<h4 id="315-hart-id-registermhartid"><a class="header" href="#315-hart-id-registermhartid">3.1.5 Hart ID Registermhartid.</a></h4>
<p>ThemhartidCSR is an MXLEN-bit read-only register containing the integer ID of the hardware
thread running the code. This register must be readable in any implementation. Hart IDs might
not necessarily be numbered contiguously in a multiprocessor system, but at least one hart must
have a hart ID of zero. Hart IDs must be unique.</p>
<pre><code>MXLEN-1 0
Hart ID
MXLEN
</code></pre>
<pre><code>Figure 3.5: Hart ID register (mhartid).
</code></pre>
<pre><code>In certain cases, we must ensure exactly one hart runs some code (e.g., at reset), and so require
one hart to have a known hart ID of zero.
For efficiency, system implementers should aim to reduce the magnitude of the largest hart
ID used in a system.
</code></pre>
<h4 id="316-machine-status-register-mstatus"><a class="header" href="#316-machine-status-register-mstatus">3.1.6 Machine Status Register (mstatus)</a></h4>
<p>Themstatusregister is an MXLEN-bit read/write register formatted as shown in Figure 3.6 for
RV32 and Figure 3.7 for RV64. Themstatusregister keeps track of and controls the hart‚Äôs current
operating state. Restricted views of themstatusregister appear as thesstatusandustatus
registers in the S-level and U-level ISAs respectively.</p>
<pre><code>31 30 23 22 21 20 19 18 17
SD WPRI TSR TW TVM MXR SUM MPRV
1 8 1 1 1 1 1 1
</code></pre>
<pre><code>16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
XS[1:0] FS[1:0] MPP[1:0] WPRI SPP MPIE WPRI SPIE UPIE MIE WPRI SIE UIE
2 2 2 2 1 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 3.6: Machine-mode status register (mstatus) for RV32.
</code></pre>
<pre><code>MXLEN-1 MXLEN-2 36 35 34 33 32 31 23 22 21 20 19 18 17
SD WPRI SXL[1:0] UXL[1:0] WPRI TSR TW TVM MXR SUM MPRV
1 MXLEN-37 2 2 9 1 1 1 1 1 1
</code></pre>
<pre><code>16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
XS[1:0] FS[1:0] MPP[1:0] WPRI SPP MPIE WPRI SPIE UPIE MIE WPRI SIE UIE
2 2 2 2 1 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 3.7: Machine-mode status register (mstatus) for RV64.
</code></pre>
<h5 id="3161-privilege-and-global-interrupt-enable-stack-inmstatusregister"><a class="header" href="#3161-privilege-and-global-interrupt-enable-stack-inmstatusregister">3.1.6.1 Privilege and Global Interrupt-Enable Stack inmstatusregister</a></h5>
<p>Global interrupt-enable bits, MIE, SIE, and UIE, are provided for each privilege mode. These bits
are primarily used to guarantee atomicity with respect to interrupt handlers in the current privilege
mode.</p>
<pre><code>The globalxIE bits are located in the low-order bits ofmstatus, allowing them to be atomically
set or cleared with a single CSR instruction.
</code></pre>
<p>When a hart is executing in privilege modex, interrupts are globally enabled whenxIE=1 and
globally disabled whenxIE=0. Interrupts for lower-privilege modes, w&lt;x, are always globally
disabled regardless of the setting of the lower-privilege mode‚Äôs global wIE bit. Interrupts for
higher-privilege modes,y&gt;x, are always globally enabled regardless of the setting of the higher-
privilege mode‚Äôs globalyIE bit. Higher-privilege-level code can use separate per-interrupt enable
bits to disable selected higher-privilege-mode interrupts before ceding control to a lower-privilege
mode.</p>
<pre><code>A higher-privilege modeycould disable all of its interrupts before ceding control to a lower-
privilege mode but this would be unusual as it would leave only a synchronous trap, non-maskable
interrupt, or reset as means to regain control of the hart.
</code></pre>
<p>To support nested traps, each privilege modexhas a two-level stack of interrupt-enable bits and
privilege modes. xPIE holds the value of the interrupt-enable bit active prior to the trap, and
xPP holds the previous privilege mode. ThexPP fields can only hold privilege modes up tox, so
MPP is two bits wide, SPP is one bit wide, and UPP is implicitly zero. When a trap is taken from
privilege modeyinto privilege modex,xPIE is set to the value ofxIE;xIE is set to 0; andxPP
is set toy.</p>
<pre><code>For lower privilege modes, any trap (synchronous or asynchronous) is usually taken at a higher
privilege mode with interrupts disabled upon entry. The higher-level trap handler will either
service the trap and return using the stacked information, or, if not returning immediately to
the interrupted context, will save the privilege stack before re-enabling interrupts, so only one
entry per stack is required.
</code></pre>
<p>The MRET, SRET, or URET instructions are used to return from traps in M-mode, S-mode, or
U-mode respectively. When executing anxRET instruction, supposingxPP holds the valuey,xIE
is set toxPIE; the privilege mode is changed toy;xPIE is set to 1; andxPP is set to U (or M if
user-mode is not supported).</p>
<p>xPP fields areWARLfields that can hold only privilege modexand any implemented privilege
mode lower thanx. If privilege modexis not implemented, thenxPP must be hardwired to 0.</p>
<pre><code>M-mode software can determine whether a privilege mode is implemented by writing that mode
to MPP then reading it back.
If the machine provides only U and M modes, then only a single hardware storage bit is
required to represent either 00 or 11 in MPP.
</code></pre>
<p>User-level interrupts are an optional extension and have been allocated the ISA extension letter N.
If user-level interrupts are omitted, the UIE and UPIE bits are hardwired to zero. For all other
supported privilege modesx, thexIE andxPIE must not be hardwired.</p>
<pre><code>User-level interrupts are primarily intended to support secure embedded systems with only M-
mode and U-mode present, but can also be supported in systems running Unix-like operating
systems to support user-level trap handling.
</code></pre>
<p>3.1.6.2 Base ISA Control inmstatusRegister</p>
<p>For RV64 systems, the SXL and UXL fields areWARLfields that control the value of XLEN for
S-mode and U-mode, respectively. The encoding of these fields is the same as the MXL field of
misa, shown in Table 3.1. The effective XLEN in S-mode and U-mode are termedSXLENand
UXLEN, respectively.</p>
<p>For RV32 systems, the SXL and UXL fields do not exist, and SXLEN=32 and UXLEN=32.</p>
<p>For RV64 systems, if S-mode is not supported, then SXL is hardwired to zero. Otherwise, it is
aWARLfield that encodes the current value of SXLEN. In particular, the implementation may
hardwire SXL so that SXLEN=MXLEN.</p>
<p>For RV64 systems, if U-mode is not supported, then UXL is hardwired to zero. Otherwise, it is
aWARLfield that encodes the current value of UXLEN. In particular, the implementation may
hardwire UXL so that UXLEN=MXLEN or UXLEN=SXLEN.</p>
<p>Whenever XLEN in any mode is set to a value less than the widest supported XLEN, all operations
must ignore source operand register bits above the configured XLEN, and must sign-extend results
to fill the entire widest supported XLEN in the destination register.</p>
<pre><code>We require that operations always fill the entire underlying hardware registers with defined values
to avoid implementation-defined behavior.
To reduce hardware complexity, the architecture imposes no checks that lower-privilege modes
have XLEN settings less than or equal to the next-higher privilege mode. In practice, such
settings would almost always be a software bug, but machine operation is well-defined even in
this case.
</code></pre>
<p>If MXLEN is changed from 32 to a wider width, each ofmstatusfields SXL and UXL, if not
hardwired to a forced value, gets the value corresponding to the widest supported width not wider
than the new MXLEN.</p>
<h4 id="3163-memory-privilege-inmstatusregister"><a class="header" href="#3163-memory-privilege-inmstatusregister">3.1.6.3 Memory Privilege inmstatusRegister</a></h4>
<p>The MPRV (Modify PRiVilege) bit modifies the privilege level at which loads and stores execute in
all privilege modes. When MPRV=0, loads and stores behave as normal, using the translation and
protection mechanisms of the current privilege mode. When MPRV=1, load and store memory
addresses are translated and protected as though the current privilege mode were set to MPP.
Instruction address-translation and protection are unaffected by the setting of MPRV. MPRV is
hardwired to 0 if U-mode is not supported.</p>
<p>The MXR (Make eXecutable Readable) bit modifies the privilege with which loads access virtual
memory. When MXR=0, only loads from pages marked readable (R=1 in Figure 4.15) will succeed.
When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed.
MXR has no effect when page-based virtual memory is not in effect. MXR is hardwired to 0 if
S-mode is not supported.</p>
<pre><code>The MPRV and MXR mechanisms were conceived to improve the efficiency of M-mode routines
that emulate missing hardware features, e.g., misaligned loads and stores. MPRV obviates the
need to perform address translation in software. MXR allows instruction words to be loaded
from pages marked execute-only.
For simplicity, MPRV and MXR are in effect regardless of privilege mode, but in normal
use will only be enabled for short sequences in machine mode.
The current privilege mode and the privilege mode specified by MPP might have different
XLEN settings. When MPRV=1, load and store memory addresses are treated as though the
current XLEN were set to MPP‚Äôs XLEN, following the rules in Section 3.1.6.2.
</code></pre>
<p>The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode
loads and stores access virtual memory. When SUM=0, S-mode memory accesses to pages that are
accessible by U-mode (U=1 in Figure 4.15) will fault. When SUM=1, these accesses are permitted.
SUM has no effect when page-based virtual memory is not in effect. Note that, while SUM is
ordinarily ignored when not executing in S-mode, itisin effect when MPRV=1 and MPP=S. SUM
is hardwired to 0 if S-mode is not supported.</p>
<pre><code>The MXR and SUM mechanisms only affect the interpretation of permissions encoded in page-
table entries. In particular, they have no impact on whether access exceptions are raised due to
PMAs or PMP.
</code></pre>
<h4 id="3164-virtualization-support-inmstatusregister"><a class="header" href="#3164-virtualization-support-inmstatusregister">3.1.6.4 Virtualization Support inmstatusRegister</a></h4>
<p>The TVM (Trap Virtual Memory) bit supports intercepting supervisor virtual-memory man-
agement operations. When TVM=1, attempts to read or write thesatpCSR or execute the
SFENCE.VMA instruction while executing in S-mode will raise an illegal instruction exception.
When TVM=0, these operations are permitted in S-mode. TVM is hard-wired to 0 when S-mode
is not supported.</p>
<pre><code>The TVM mechanism improves virtualization efficiency by permitting guest operating systems to
execute in S-mode, rather than classically virtualizing them in U-mode. This approach obviates
the need to trap accesses to most S-mode CSRs.
Trappingsatpaccesses and the SFENCE.VMA instruction provides the hooks necessary to
lazily populate shadow page tables.
</code></pre>
<p>The TW (Timeout Wait) bit supports intercepting the WFI instruction (see Section 3.2.3). When
TW=0, the WFI instruction may execute in lower privilege modes when not prevented for some
other reason. When TW=1, then if WFI is executed in any less-privileged mode, and it does not
complete within an implementation-specific, bounded time limit, the WFI instruction causes an
illegal instruction exception. The time limit may always be 0, in which case WFI always causes an
illegal instruction exception in less-privileged modes when TW=1. TW is hard-wired to 0 when
there are no modes less privileged than M.</p>
<pre><code>Trapping the WFI instruction can trigger a world switch to another guest OS, rather than
wastefully idling in the current guest.
</code></pre>
<p>When S-mode is implemented, then executing WFI in U-mode causes an illegal instruction excep-
tion, unless it completes within an implementation-specific, bounded time limit. A future revision
of this specification might add a feature that allows S-mode to selectively permit WFI in U-mode.
Such a feature would only be active when TW=0.</p>
<p>The TSR (Trap SRET) bit supports intercepting the supervisor exception return instruction, SRET.
When TSR=1, attempts to execute SRET while executing in S-mode will raise an illegal instruction
exception. When TSR=0, this operation is permitted in S-mode. TSR is hard-wired to 0 when
S-mode is not supported.</p>
<pre><code>Trapping SRET is necessary to emulate the hypervisor extension on implementations that do
not provide it.
</code></pre>
<h4 id="3165-extension-context-status-inmstatusregister"><a class="header" href="#3165-extension-context-status-inmstatusregister">3.1.6.5 Extension Context Status inmstatusRegister</a></h4>
<p>Supporting substantial extensions is one of the primary goals of RISC-V, and hence we define a
standard interface to allow unchanged privileged-mode code, particularly a supervisor-level OS, to
support arbitrary user-mode state extensions.</p>
<pre><code>To date, the V extension is the only standard extension that defines additional state beyond the
floating-point CSR and data registers.
</code></pre>
<p>The FS[1:0]WARLfield and the XS[1:0] read-only field are used to reduce the cost of context save
and restore by setting and tracking the current state of the floating-point unit and any other user-
mode extensions respectively. The FS field encodes the status of the floating-point unit, including
the CSRfcsrand floating-point data registersf0‚Äìf31, while the XS field encodes the status of
additional user-mode extensions and associated state. These fields can be checked by a context
switch routine to quickly determine whether a state save or restore is required. If a save or restore is
required, additional instructions and CSRs are typically required to effect and optimize the process.</p>
<pre><code>The design anticipates that most context switches will not need to save/restore state in either
or both of the floating-point unit or other extensions, so provides a fast check via the SD bit.
</code></pre>
<p>The FS and XS fields use the same status encoding as shown in Table 3.3, with the four possible
status values being Off, Initial, Clean, and Dirty.</p>
<pre><code>Status FS Meaning XS Meaning
0 Off All off
1 Initial None dirty or clean, some on
2 Clean None dirty, some clean
3 Dirty Some dirty
</code></pre>
<pre><code>Table 3.3: Encoding of FS[1:0] and XS[1:0] status fields.
</code></pre>
<p>In systems that do not implement S-mode and do not have a floating-point unit, the FS field is
hardwired to zero.</p>
<p>In systems without additional user extensions requiring new state, the XS field is hardwired to
zero. Every additional extension with state provides a CSR field that encodes the equivalent of the
XS states. The XS field represents a summary of all extensions‚Äô status as shown in Table 3.3.</p>
<pre><code>The XS field effectively reports the maximum status value across all user-extension status fields,
though individual extensions can use a different encoding than XS.
</code></pre>
<p>The SD bit is a read-only bit that summarizes whether either the FS field or XS field signals the
presence of some dirty state that will require saving extended user context to memory. If both XS
and FS are hardwired to zero, then SD is also always zero.</p>
<p>When an extension‚Äôs status is set to Off, any instruction that attempts to read or write the cor-
responding state will cause an illegal instruction exception. When the status is Initial, the corre-
sponding state should have an initial constant value. When the status is Clean, the corresponding
state is potentially different from the initial value, but matches the last value stored on a context
swap. When the status is Dirty, the corresponding state has potentially been modified since the
last context save.</p>
<p>During a context save, the responsible privileged code need only write out the corresponding state
if its status is Dirty, and can then reset the extension‚Äôs status to Clean. During a context restore,
the context need only be loaded from memory if the status is Clean (it should never be Dirty at</p>
<p>restore). If the status is Initial, the context must be set to an initial constant value on context
restore to avoid a security hole, but this can be done without accessing memory. For example, the
floating-point registers can all be initialized to the immediate value 0.</p>
<p>The FS and XS fields are read by the privileged code before saving the context. The FS field is
set directly by privileged code when resuming a user context, while the XS field is set indirectly by
writing to the status register of the individual extensions. The status fields will also be updated
during execution of instructions, regardless of privilege mode.</p>
<p>Extensions to the user-mode ISA often include additional user-mode state, and this state can be
considerably larger than the base integer registers. The extensions might only be used for some
applications, or might only be needed for short phases within a single application. To improve
performance, the user-mode extension can define additional instructions to allow user-mode software
to return the unit to an initial state or even to turn off the unit.</p>
<p>For example, a coprocessor might require to be configured before use and can be ‚Äúunconfigured‚Äù
after use. The unconfigured state would be represented as the Initial state for context save. If the
same application remains running between the unconfigure and the next configure (which would
set status to Dirty), there is no need to actually reinitialize the state at the unconfigure instruction,
as all state is local to the user process, i.e., the Initial state may only cause the coprocessor state
to be initialized to a constant value at context restore, not at every unconfigure.</p>
<p>Executing a user-mode instruction to disable a unit and place it into the Off state will cause an
illegal instruction exception to be raised if any subsequent instruction tries to use the unit before
it is turned back on. A user-mode instruction to turn a unit on must also ensure the unit‚Äôs state is
properly initialized, as the unit might have been used by another context meantime.</p>
<p>Changing the setting of FS has no effect on the contents of the floating-point register state. In
particular, setting FS=Off does not destroy the state, nor does setting FS=Initial clear the contents.
Other extensions might not preserve state when set to Off.</p>
<p>Implementations may choose to track the dirtiness of the floating-point register state imprecisely
by reporting the state to be dirty even when it has not been modified. On some implementations,
some instructions that do not mutate the floating-point state may cause the state to transition
from Initial or Clean to Dirty. On other implementations, dirtiness might not be tracked at all,
in which case the valid FS states are Off and Dirty, and an attempt to set FS to Initial or Clean
causes it to be set to Dirty.</p>
<pre><code>This definition of FS does not disallow setting FS to Dirty as a result of errant speculation. Some
platforms may choose to disallow speculatively writing FS to close a potential side channel.
</code></pre>
<p>Table 3.4 shows all the possible state transitions for the FS or XS status bits. Note that the standard
floating-point extensions do not support user-mode unconfigure or disable/enable instructions.</p>
<p>Standard privileged instructions to initialize, save, and restore extension state are provided to
insulate privileged code from details of the added extension state by treating the state as an
opaque object.</p>
<pre><code>Many coprocessor extensions are only used in limited contexts that allows software to safely
unconfigure or even disable units when done. This reduces the context-switch overhead of large
stateful coprocessors.
</code></pre>
<pre><code>Current State Off Initial Clean Dirty
Action
At context save in privileged code
Save state? No No No Yes
Next state Off Initial Clean Clean
At context restore in privileged code
Restore state? No Yes, to initial Yes, from memory N/A
Next state Off Initial Clean N/A
Execute instruction to read state
Action? Exception Execute Execute Execute
Next state Off Initial Clean Dirty
Execute instruction to modify state, including configuration
Action? Exception Execute Execute Execute
Next state Off Dirty Dirty Dirty
Execute instruction to unconfigure unit
Action? Exception Execute Execute Execute
Next state Off Initial Initial Initial
Execute instruction to disable unit
Action? Execute Execute Execute Execute
Next state Off Off Off Off
Execute instruction to enable unit
Action? Execute Execute Execute Execute
Next state Initial Initial Initial Initial
</code></pre>
<pre><code>Table 3.4: FS and XS state transitions.
</code></pre>
<pre><code>We separate out floating-point state from other extension state, as when a floating-point
unit is present the floating-point registers are part of the standard calling convention, and so
user-mode software cannot know when it is safe to disable the floating-point unit.
</code></pre>
<p>The XS field provides a summary of all added extension state, but additional microarchitectural
bits might be maintained in the extension to further reduce context save and restore overhead.</p>
<p>The SD bit is read-only and is set when either the FS or XS bits encode a Dirty state (i.e.,
SD=((FS==11) OR (XS==11))). This allows privileged code to quickly determine when no addi-
tional context save is required beyond the integer register set and PC.</p>
<p>The floating-point unit state is always initialized, saved, and restored using standard instructions
(F, D, and/or Q), and privileged code must be aware of FLEN to determine the appropriate space
to reserve for eachfregister.</p>
<p>All privileged modes share a single copy of the FS and XS bits. In a system with more than one
privileged mode, supervisor mode would normally use the FS and XS bits directly to record the
status with respect to the supervisor-level saved context. Other more-privileged active modes must
be more conservative in saving and restoring the extension state in their corresponding version of
the context.</p>
<pre><code>In any reasonable use case, the number of context switches between user and supervisor level
should far outweigh the number of context switches to other privilege levels. Note that coproces-
sors should not require their context to be saved and restored to service asynchronous interrupts,
unless the interrupt results in a user-level context swap.
</code></pre>
<h3 id="317-machine-trap-vector-base-address-register-mtvec"><a class="header" href="#317-machine-trap-vector-base-address-register-mtvec">3.1.7 Machine Trap-Vector Base-Address Register (mtvec)</a></h3>
<p>Themtvecregister is an MXLEN-bit read/write register that holds trap vector configuration,
consisting of a vector base address (BASE) and a vector mode (MODE).</p>
<pre><code>MXLEN-1 2 1 0
BASE[MXLEN-1:2] (WARL) MODE (WARL)
MXLEN-2 2
</code></pre>
<pre><code>Figure 3.8: Machine trap-vector base-address register (mtvec).
</code></pre>
<p>Themtvecregister must always be implemented, but can contain a hardwired read-only value. If
mtvecis writable, the set of values the register may hold can vary by implementation. The value in
the BASE field must always be aligned on a 4-byte boundary, and the MODE setting may impose
additional alignment constraints on the value in the BASE field.</p>
<pre><code>We allow for considerable flexibility in implementation of the trap vector base address. On the
one hand, we do not wish to burden low-end implementations with a large number of state bits,
but on the other hand, we wish to allow flexibility for larger systems.
Value Name Description
0 Direct All exceptions setpcto BASE.
1 Vectored Asynchronous interrupts setpcto BASE+4√ócause.
‚â• 2 ‚Äî Reserved
</code></pre>
<pre><code>Table 3.5: Encoding ofmtvecMODE field.
</code></pre>
<p>The encoding of the MODE field is shown in Table 3.5. When MODE=Direct, all traps into
machine mode cause thepcto be set to the address in the BASE field. When MODE=Vectored,
all synchronous exceptions into machine mode cause thepcto be set to the address in the BASE
field, whereas interrupts cause thepcto be set to the address in the BASE field plus four times the
interrupt cause number. For example, a machine-mode timer interrupt (see Table 3.6 on page 37)
causes thepcto be set to BASE+0x1c.</p>
<pre><code>When vectored interrupts are enabled, interrupt cause 0, which corresponds to user-mode soft-
ware interrupts, are vectored to the same location as synchronous exceptions. This ambiguity
does not arise in practice, since user-mode software interrupts are either disabled or delegated
to a less-privileged mode.
</code></pre>
<p>An implementation may have different alignment constraints for different modes. In particular,
MODE=Vectored may have stricter alignment constraints than MODE=Direct.</p>
<pre><code>Allowing coarser alignments in Vectored mode enables vectoring to be implemented without a
hardware adder circuit.
</code></pre>
<pre><code>Reset and NMI vector locations are given in a platform specification.
</code></pre>
<h3 id="318-machine-trap-delegation-registers-medelegandmideleg"><a class="header" href="#318-machine-trap-delegation-registers-medelegandmideleg">3.1.8 Machine Trap Delegation Registers (medelegandmideleg)</a></h3>
<p>By default, all traps at any privilege level are handled in machine mode, though a machine-mode
handler can redirect traps back to the appropriate level with the MRET instruction (Section 3.2.2).
To increase performance, implementations can provide individual read/write bits withinmedeleg
andmidelegto indicate that certain exceptions and interrupts should be processed directly by a
lower privilege level. The machine exception delegation register (medeleg) and machine interrupt
delegation register (mideleg) are MXLEN-bit read/write registers.</p>
<p>In systems with all three privilege modes (M/S/U), setting a bit inmedeleg ormidelegwill
delegate the corresponding trap in S-mode or U-mode to the S-mode trap handler. If U-mode traps
are supported, S-mode may in turn set corresponding bits in thesedelegandsidelegregisters
to delegate traps that occur in U-mode to the U-mode trap handler. In systems with S-mode, the
medelegandmidelegregisters must exist, whereas thesedelegandsidelegregisters should only
exist if the N extension for user-mode interrupts is also implemented.</p>
<p>In systems with two privilege modes (M/U) and support for U-mode traps, setting a bit inmedeleg
ormidelegwill delegate the corresponding trap in U-mode to the U-mode trap handler. In systems
with only M-mode and U-mode, themedelegandmidelegregisters should only be implemented
if the N extension for user-mode interrupts is implemented.</p>
<p>In systems with only M-mode, or with both M-mode and U-mode but without U-mode trap support,
themedelegandmidelegregisters should not exist.</p>
<pre><code>In versions 1.9.1 and earlier , these registers existed but were hardwired to zero in M-mode only,
or M/U without N systems. There is no reason to require they return zero in those cases, as the
misaregister indicates whether they exist.
</code></pre>
<p>When a trap is delegated to a less-privileged modex, thexcauseregister is written with the trap
cause; thexepcregister is written with the virtual address of the instruction that took the trap;
thextvalregister is written with an exception-specific datum; thexPP field ofmstatusis written
with the active privilege mode at the time of the trap; thexPIE field ofmstatusis written with
the value of thexIE field at the time of the trap; and thexIE field ofmstatusis cleared. The
mcauseandmepcregisters and the MPP and MPIE fields ofmstatusare not written.</p>
<p>An implementation shall not hardwire any delegation bits to one, i.e., any trap that can be delegated
must support not being delegated. An implementation can choose to subset the delegatable traps,
with the supported delegatable bits found by writing one to every bit location, then reading back
the value inmedelegormidelegto see which bit positions hold a one.</p>
<p>Traps never transition from a more-privileged mode to a less-privileged mode. For example, if M-
mode has delegated illegal instruction exceptions to S-mode, and M-mode software later executes
an illegal instruction, the trap is taken in M-mode, rather than being delegated to S-mode. By
contrast, traps may be taken horizontally. Using the same example, if M-mode has delegated illegal
instruction exceptions to S-mode, and S-mode software later executes an illegal instruction, the trap
is taken in S-mode.</p>
<p>Delegated interrupts result in the interrupt being masked at the delegator privilege level. For
example, if the supervisor timer interrupt (STI) is delegated to S-mode by settingmideleg[5], STIs
will not be taken when executing in M-mode. By contrast, ifmideleg[5] is clear, STIs can be taken</p>
<p>in any mode and regardless of current mode will transfer control to M-mode.</p>
<pre><code>MXLEN-1 0
Synchronous Exceptions (WARL)
MXLEN
</code></pre>
<pre><code>Figure 3.9: Machine Exception Delegation Registermedeleg.
</code></pre>
<p>medeleghas a bit position allocated for every synchronous exception shown in Table 3.6 on page 37,
with the index of the bit position equal to the value returned in themcauseregister (i.e., setting
bit 8 allows user-mode environment calls to be delegated to a lower-privilege trap handler).</p>
<pre><code>MXLEN-1 0
Interrupts (WARL)
MXLEN
</code></pre>
<pre><code>Figure 3.10: Machine Interrupt Delegation Registermideleg.
</code></pre>
<p>midelegholds trap delegation bits for individual interrupts, with the layout of bits matching those
in themipregister (i.e., STIP interrupt delegation control is located in bit 5).</p>
<p>Some exceptions cannot occur at less privileged modes, and correspondingxedelegbits should be
hardwired to zero. In particular,medeleg[11] andsedeleg[11:9] are all hardwired to zero.</p>
<h3 id="319-machine-interrupt-registers-mipandmie"><a class="header" href="#319-machine-interrupt-registers-mipandmie">3.1.9 Machine Interrupt Registers (mipandmie)</a></h3>
<p>Themipregister is an MXLEN-bit read/write register containing information on pending interrupts,
whilemieis the corresponding MXLEN-bit read/write register containing interrupt enable bits.
Only the bits corresponding to lower-privilege software interrupts (USIP, SSIP), timer interrupts
(UTIP, STIP), and external interrupts (UEIP, SEIP) inmipare writable through this CSR address;
the remaining bits are read-only.</p>
<pre><code>The machine-level interrupt registers handle a few root interrupt sources which are assigned a
fixed service priority for simplicity, while separate external interrupt controllers can implement
a more complex prioritization scheme over a much larger set of interrupts that are then muxed
into the machine-level interrupt sources.
</code></pre>
<p>Restricted views of themipandmieregisters appear as thesip/sie, anduip/uieregisters in
S-mode and U-mode respectively. If an interrupt is delegated to privilege modexby setting a bit in
themidelegregister, it becomes visible in thexipregister and is maskable using thexieregister.
Otherwise, the corresponding bits inxipandxieappear to be hardwired to zero.</p>
<pre><code>MXLEN-1 12 11 10 9 8 7 6 5 4 3 2 1 0
WPRI MEIP WPRI SEIP UEIP MTIP WPRI STIP UTIP MSIP WPRI SSIP USIP
MXLEN-12 1 1 1 1 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 3.11: Machine interrupt-pending register (mip).
</code></pre>
<p>The MTIP, STIP, UTIP bits correspond to timer interrupt-pending bits for machine, supervisor,
and user timer interrupts, respectively. The MTIP bit is read-only and is cleared by writing to the</p>
<pre><code>MXLEN-1 12 11 10 9 8 7 6 5 4 3 2 1 0
WPRI MEIE WPRI SEIE UEIE MTIE WPRI STIE UTIE MSIE WPRI SSIE USIE
MXLEN-12 1 1 1 1 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 3.12: Machine interrupt-enable register (mie).
</code></pre>
<p>memory-mapped machine-mode timer compare register. The UTIP and STIP bits may be written
by M-mode software to deliver timer interrupts to lower privilege levels. User and supervisor
software may clear the UTIP and STIP bits with calls to the AEE and SEE respectively.</p>
<p>There is a separate timer interrupt-enable bit, named MTIE, STIE, and UTIE for M-mode, S-mode,
and U-mode timer interrupts respectively.</p>
<p>Each lower privilege level has a separate software interrupt-pending bit (SSIP, USIP), which can
be both read and written by CSR accesses from code running on the local hart at the associated or
any higher privilege level. The machine-level MSIP bits are written by accesses to memory-mapped
control registers, which are used by remote harts to provide machine-mode interprocessor interrupts.
Interprocessor interrupts for lower privilege levels are implemented through implementation-specific
mechanisms, e.g., via calls to an AEE or SEE, which might ultimately result in a machine-mode
write to the receiving hart‚Äôs MSIP bit. A hart can write its own MSIP bit using the same memory-
mapped control register.</p>
<p>The MSIE, SSIE, and USIE fields in themieCSR enable M-mode software interrupts, S-mode
software interrupts, and U-mode software interrupts, respectively.</p>
<pre><code>We only allow a hart to directly write its own SSIP or USIP bits when running in the appropriate
mode, as other harts might be virtualized and possibly descheduled by higher privilege levels. We
rely on calls to the AEE and SEE to provide interprocessor interrupts for this reason. Machine-
mode harts are not virtualized and can directly interrupt other harts by setting their MSIP
bits, typically using uncached I/O writes to memory-mapped control registers depending on the
platform specification.
</code></pre>
<p>The MEIP field in mipis a read-only bit that indicates a machine-mode external interrupt is
pending. MEIP is set and cleared by a platform-specific interrupt controller. The MEIE field in
mieenables machine external interrupts when set.</p>
<p>The SEIP field inmipcontains a single read-write bit. SEIP may be written by M-mode soft-
ware to indicate to S-mode that an external interrupt is pending. Additionally, the platform-
level interrupt controller may generate supervisor-level external interrupts. The logical-OR of the
software-writable bit and the signal from the external interrupt controller is used to generate exter-
nal interrupts to the supervisor. When the SEIP bit is read with a CSRRW, CSRRS, or CSRRC
instruction, the value returned in therddestination register contains the logical-OR of the software-
writable bit and the interrupt signal from the interrupt controller. However, the value used in the
read-modify-write sequence of a CSRRS or CSRRC instruction is only the software-writable SEIP
bit, ignoring the interrupt value from the external interrupt controller.</p>
<pre><code>The SEIP field behavior is designed to allow a higher privilege layer to mimic external interrupts
cleanly, without losing any real external interrupts. The behavior of the CSR instructions is
slightly modified from regular CSR accesses as a result.
</code></pre>
<p>The UEIP field inmipprovides user-mode external interrupts when the N extension for user-mode
interrupts is implemented. It is defined analogously to SEIP.</p>
<p>The MEIE, SEIE, and UEIE fields in themieCSR enable M-mode external interrupts, S-mode
external interrupts, and U-mode external interrupts, respectively.</p>
<pre><code>The non-maskable interrupt is not made visible via themipregister as its presence is implicitly
known when executing the NMI trap handler.
</code></pre>
<p>For all the various interrupt types (software, timer, and external), if a privilege level is not sup-
ported, or if U-mode is supported but the N extension is not supported, then the associated pending
and interrupt-enable bits are hardwired to zero in themipandmieregisters respectively. Hence,
these are all effectivelyWARLfields.</p>
<p>Implementations may add additional platform-specific interrupt sources to bits 16 and above of
themipandmieregisters. Some platforms may avail these interrupts for custom use. The other
unallocated interrupt sources (15‚Äì12, 10, 6, and 2) are reserved for future standard use.</p>
<p>An interruptiwill be taken if bitiis set in bothmipandmie, and if interrupts are globally enabled.
By default, M-mode interrupts are globally enabled if the hart‚Äôs current privilege mode is less than
M, or if the current privilege mode is M and the MIE bit in themstatusregister is set. If biti
inmidelegis set, however, interrupts are considered to be globally enabled if the hart‚Äôs current
privilege mode equals the delegated privilege mode (S or U) and that mode‚Äôs interrupt enable bit
(SIE or UIE inmstatus) is set, or if the current privilege mode is less than the delegated privilege
mode.</p>
<p>Multiple simultaneous interrupts destined for different privilege modes are handled in decreasing
order of destined privilege mode. Multiple simultaneous interrupts destined for the same privilege
mode are handled in the following decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI, UEI,
USI, UTI. Synchronous exceptions are of lower priority than all interrupts.</p>
<pre><code>The machine-level interrupt fixed-priority ordering rules were developed with the following ra-
tionale.
Interrupts for higher privilege modes must be serviced before interrupts for lower privilege
modes to support preemption.
The platform-specific machine-level interrupt sources in bits 16 and above have platform-
specific priority, but are typically chosen to have the highest service priority to support very fast
local vectored interrupts.
External interrupts are handled before internal (timer/software) interrupts as external in-
terrupts are usually generated by devices that might require low interrupt service times.
Software interrupts are handled before internal timer interrupts, because internal timer in-
terrupts are usually intended for time slicing, where time precision is less important, whereas
software interrupts are used for inter-processor messaging. Software interrupts can be avoided
when high-precision timing is required, or high-precision timer interrupts can be routed via a
different interrupt path. Software interrupts are located in the lowest four bits ofmipas these
are often written by software, and this position allows the use of a single CSR instruction with
a five-bit immediate.
Synchronous exceptions are given the lowest priority to minimize worst-case interrupt la-
tency.
</code></pre>
<h3 id="3110-machine-timer-registers-mtimeandmtimecmp"><a class="header" href="#3110-machine-timer-registers-mtimeandmtimecmp">3.1.10 Machine Timer Registers (mtimeandmtimecmp)</a></h3>
<p>Platforms provide a real-time counter, exposed as a memory-mapped machine-mode read-write
register,mtime.mtimemust run at constant frequency, and the platform must provide a mechanism
for determining the timebase ofmtime.</p>
<p>Themtimeregister has a 64-bit precision on all RV32 and RV64 systems. Platforms provide a
64-bit memory-mapped machine-mode timer compare register (mtimecmp), which causes a timer
interrupt to be posted when themtimeregister contains a value greater than or equal to the value
in themtimecmpregister. The interrupt remains posted until it is cleared by writing themtimecmp
register. The interrupt will only be taken if interrupts are enabled and the MTIE bit is set in the
mieregister.</p>
<pre><code>63 0
mtime
64
</code></pre>
<pre><code>Figure 3.13: Machine time register (memory-mapped control register).
</code></pre>
<pre><code>63 0
mtimecmp
64
</code></pre>
<pre><code>Figure 3.14: Machine time compare register (memory-mapped control register).
</code></pre>
<pre><code>The timer facility is defined to use wall-clock time rather than a cycle counter to support modern
processors that run with a highly variable clock frequency to save energy through dynamic voltage
and frequency scaling.
Accurate real-time clocks (RTCs) are relatively expensive to provide (requiring a crystal
or MEMS oscillator) and have to run even when the rest of system is powered down, and so
there is usually only one in a system located in a different frequency/voltage domain from the
processors. Hence, the RTC must be shared by all the harts in a system and accesses to the RTC
will potentially incur the penalty of a voltage-level-shifter and clock-domain crossing. It is thus
more natural to exposemtimeas a memory-mapped register than as a CSR.
Lower privilege levels do not have their owntimecmpregisters. Instead, machine-mode
software can implement any number of virtual timers on a hart by multiplexing the next timer
interrupt into themtimecmpregister.
Simple fixed-frequency systems can use a single clock for both cycle counting and wall-clock
time.
</code></pre>
<p>Writes tomtimeandmtimecmpare guaranteed to be reflected in MTIP eventually, but not neces-
sarily immediately.</p>
<pre><code>A spurious timer interrupt might occur if an interrupt handler incrementsmtimecmpthen im-
mediately returns, because MTIP might not yet have fallen in the interim. All software should be
written to assume this event is possible, but most software should assume this event is extremely
unlikely. It is almost always more performant to incur an occasional spurious timer interrupt
than to poll MTIP until it falls.
</code></pre>
<p>In RV32, memory-mapped writes tomtimecmpmodify only one 32-bit part of the register. The
following code sequence sets a 64-bitmtimecmpvalue without spuriously generating a timer interrupt
due to the intermediate value of the comparand:</p>
<pre><code># New comparand is in a1:a0.
li t0, -1
sw t0, mtimecmp # No smaller than old value.
sw a1, mtimecmp+4 # No smaller than new value.
sw a0, mtimecmp # New value.
</code></pre>
<p>Figure 3.15: Sample code for setting the 64-bit time comparand in RV32 assuming the registers
live in a strongly ordered I/O region.</p>
<h3 id="3111-hardware-performance-monitor"><a class="header" href="#3111-hardware-performance-monitor">3.1.11 Hardware Performance Monitor</a></h3>
<p>M-mode includes a basic hardware performance-monitoring facility. ThemcycleCSR counts the
number of clock cycles executed by the processor core on which the hart is running. Theminstret
CSR counts the number of instructions the hart has retired. Themcycleandminstretregisters
have 64-bit precision on all RV32 and RV64 systems.</p>
<p>The counter registers have an arbitrary value after system reset, and can be written with a given
value. Any CSR write takes effect after the writing instruction has otherwise completed.</p>
<p>The hardware performance monitor includes 29 additional 64-bit event counters,mhpmcounter3‚Äì
mhpmcounter31. The event selector CSRs,mhpmevent3‚Äìmhpmevent31, are MXLEN-bitWARL
registers that control which event causes the corresponding counter to increment. The meaning
of these events is defined by the platform, but event 0 is defined to mean ‚Äúno event.‚Äù All coun-
ters should be implemented, but a legal implementation is to hard-wire both the counter and its
corresponding event selector to 0.</p>
<pre><code>63 0
mcycle
minstret
MXLEN-1 0
mhpmcounter3 mhpmevent3
mhpmcounter4 mhpmevent4
..
.
</code></pre>
<pre><code>..
.
mhpmcounter30 mhpmevent30
mhpmcounter31 mhpmevent31
64 MXLEN
</code></pre>
<pre><code>Figure 3.16: Hardware performance monitor counters.
</code></pre>
<p>Themhpmcounters areWARLregisters that support up to 64 bits of precision on RV32 and RV64.</p>
<pre><code>A future revision of this specification will define a mechanism to generate an interrupt when a
hardware performance monitor counter overflows.
</code></pre>
<p>On RV32 only, reads of themcycle,minstret, andmhpmcounternCSRs return the low 32 bits, while
reads of themcycleh,minstreth, andmhpmcounternhCSRs return bits 63‚Äì32 of the corresponding
counter.</p>
<pre><code>31 0
mcycleh
minstreth
mhpmcounter3h
mhpmcounter4h
</code></pre>
<pre><code>mhpmcounter30h
mhpmcounter31h
32
</code></pre>
<pre><code>Figure 3.17: Upper 32 bits of hardware performance monitor counters, RV32 only.
</code></pre>
<h3 id="3112-counter-enable-registers-mscounteren"><a class="header" href="#3112-counter-enable-registers-mscounteren">3.1.12 Counter-Enable Registers ([m|s]counteren)</a></h3>
<p>The counter-enable registers mcounterenandscounterenare 32-bit registers that control the
availability of the hardware performance-monitoring counters to the next-lowest privileged mode.</p>
<pre><code>31 30 29 28 6 5 4 3 2 1 0
HPM31 HPM30 HPM29 ... HPM5 HPM4 HPM3 IR TM CY
1 1 1 23 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 3.18: Counter-enable registers (mcounterenandscounteren).
</code></pre>
<p>The settings in these registers only control accessibility. The act of reading or writing these registers
does not affect the underlying counters, which continue to increment even when not accessible.</p>
<p>When the CY, TM, IR, or HPMnbit in themcounterenregister is clear, attempts to read the
cycle,time,instret, orhpmcounternregister while executing in S-mode or U-mode will cause
an illegal instruction exception. When one of these bits is set, access to the corresponding register
is permitted in the next implemented privilege mode (S-mode if implemented, otherwise U-mode).</p>
<p>If S-mode is implemented, the same bit positions in thescounterenregister analogously control
access to these registers while executing in U-mode. If S-mode is permitted to access a counter
register and the corresponding bit is set inscounteren, then U-mode is also permitted to access
that register.</p>
<p>RegistersmcounterenandscounterenareWARLregisters that must be implemented if U-mode
and S-mode are implemented. Any of the bits may contain a hardwired value of zero, indicating
reads to the corresponding counter will cause an illegal instruction exception when executing in a
less-privileged mode.</p>
<pre><code>The counter-enable bits support two common use cases with minimal hardware. For systems that
do not need high-performance timers and counters, machine-mode software can trap accesses and
implement all features in software. For systems that need high-performance timers and counters
but are not concerned with obfuscating the underlying hardware counters, the counters can be
directly exposed to lower privilege modes.
</code></pre>
<p>Thecycle,instret, andhpmcounternCSRs are read-only shadows ofmcycle,minstret, and
mhpmcountern, respectively. ThetimeCSR is a read-only shadow of the memory-mappedmtime
register.</p>
<pre><code>Implementations can convert reads of thetimeCSR into loads to the memory-mappedmtime
register, or emulate this functionality in M-mode software.
</code></pre>
<h3 id="3113-machine-counter-inhibit-csr-mcountinhibit"><a class="header" href="#3113-machine-counter-inhibit-csr-mcountinhibit">3.1.13 Machine Counter-Inhibit CSR (mcountinhibit)</a></h3>
<pre><code>31 30 29 28 6 5 4 3 2 1 0
HPM31 HPM30 HPM29 ... HPM5 HPM4 HPM3 IR 0 CY
1 1 1 23 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 3.19: Counter-inhibit registermcountinhibit.
</code></pre>
<p>The counter-inhibit registermcountinhibitis a 32-bitWARLregister that controls which of the
hardware performance-monitoring counters increment. The settings in this register only control
whether the counters increment; their accessibility is not affected by the setting of this register.</p>
<p>When the CY, IR, or HPMnbit in themcountinhibitregister is clear, thecycle,instret, or
hpmcounternregister increments as usual. When the CY, IR, or HPMnbit is set, the corresponding
counter does not increment.</p>
<p>If themcountinhibit register is not implemented, the implementation behaves as though the
register were set to zero.</p>
<pre><code>When thecycleandinstretcounters are not needed, it is desirable to conditionally inhibit
them to reduce energy consumption. Providing a single CSR to inhibit all counters also allows
the counters to be atomically sampled.
As all the harts on a processor core share a cycle counter, so they share an
mcountinhibit.CY bit.
Because thetimecounter can be shared between multiple cores, it cannot be inhibited with
themcountinhibitmechanism.
</code></pre>
<h3 id="3114-machine-scratch-register-mscratch"><a class="header" href="#3114-machine-scratch-register-mscratch">3.1.14 Machine Scratch Register (mscratch)</a></h3>
<p>Themscratchregister is an MXLEN-bit read/write register dedicated for use by machine mode.
Typically, it is used to hold a pointer to a machine-mode hart-local context space and swapped
with a user register upon entry to an M-mode trap handler.</p>
<pre><code>MXLEN-1 0
mscratch
MXLEN
</code></pre>
<pre><code>Figure 3.20: Machine-mode scratch register.
</code></pre>
<pre><code>The MIPS ISA allocated two user registers (k0/k1) for use by the operating system. Although
the MIPS scheme provides a fast and simple implementation, it also reduces available user
registers, and does not scale to further privilege levels, or nested traps. It can also require both
registers are cleared before returning to user level to avoid a potential security hole and to provide
deterministic debugging behavior.
</code></pre>
<pre><code>The RISC-V user ISA was designed to support many possible privileged system environments
and so we did not want to infect the user-level ISA with any OS-dependent features. The RISC-
V CSR swap instructions can quickly save/restore values to themscratchregister. Unlike the
MIPS design, the OS can rely on holding a value in themscratchregister while the user context
is running.
</code></pre>
<h3 id="3115-machine-exception-program-counter-mepc"><a class="header" href="#3115-machine-exception-program-counter-mepc">3.1.15 Machine Exception Program Counter (mepc)</a></h3>
<p>mepcis an MXLEN-bit read/write register formatted as shown in Figure 3.21. The low bit ofmepc
(mepc[0]) is always zero. On implementations that support only IALIGN=32, the two low bits
(mepc[1:0]) are always zero.</p>
<p>If an implementation allows IALIGN to be either 16 or 32 (by changing CSRmisa, for example),
then, whenever IALIGN=32, bitmepc[1]is masked on reads so that it appears to be 0. This
masking occurs also for the implicit read by the MRET instruction. Though masked,mepc[1]
remains writable when IALIGN=32.</p>
<p>mepcis aWARLregister that must be able to hold all valid physical and virtual addresses. It
need not be capable of holding all possible invalid addresses. Implementations may convert some
invalid address patterns into other invalid addresses prior to writing them tomepc.</p>
<p>When a trap is taken into M-mode,mepcis written with the virtual address of the instruction
that was interrupted or that encountered the exception. Otherwise,mepcis never written by the
implementation, though it may be explicitly written by software.</p>
<pre><code>MXLEN-1 0
mepc
MXLEN
</code></pre>
<pre><code>Figure 3.21: Machine exception program counter register.
</code></pre>
<h3 id="3116-machine-cause-register-mcause"><a class="header" href="#3116-machine-cause-register-mcause">3.1.16 Machine Cause Register (mcause)</a></h3>
<p>Themcauseregister is an MXLEN-bit read-write register formatted as shown in Figure 3.22. When
a trap is taken into M-mode,mcauseis written with a code indicating the event that caused the
trap. Otherwise,mcause is never written by the implementation, though it may be explicitly
written by software.</p>
<p>The Interrupt bit in themcauseregister is set if the trap was caused by an interrupt. The Exception
Code field contains a code identifying the last exception. Table 3.6 lists the possible machine-level
exception codes. The Exception Code is aWLRLfield, so is only guaranteed to hold supported
exception codes.</p>
<pre><code>MXLEN-1 MXLEN-2 0
Interrupt Exception Code (WLRL)
1 MXLEN-1
</code></pre>
<pre><code>Figure 3.22: Machine Cause registermcause.
</code></pre>
<pre><code>Interrupt Exception Code Description
1 0 User software interrupt
1 1 Supervisor software interrupt
1 2 Reserved for future standard use
1 3 Machine software interrupt
1 4 User timer interrupt
1 5 Supervisor timer interrupt
1 6 Reserved for future standard use
1 7 Machine timer interrupt
1 8 User external interrupt
1 9 Supervisor external interrupt
1 10 Reserved for future standard use
1 11 Machine external interrupt
1 12‚Äì15 Reserved for future standard use
1 ‚â• 16 Reserved for platform use
0 0 Instruction address misaligned
0 1 Instruction access fault
0 2 Illegal instruction
0 3 Breakpoint
0 4 Load address misaligned
0 5 Load access fault
0 6 Store/AMO address misaligned
0 7 Store/AMO access fault
0 8 Environment call from U-mode
0 9 Environment call from S-mode
0 10 Reserved
0 11 Environment call from M-mode
0 12 Instruction page fault
0 13 Load page fault
0 14 Reserved for future standard use
0 15 Store/AMO page fault
0 16‚Äì23 Reserved for future standard use
0 24‚Äì31 Reserved for custom use
0 32‚Äì47 Reserved for future standard use
0 48‚Äì63 Reserved for custom use
0 ‚â• 64 Reserved for future standard use
</code></pre>
<pre><code>Table 3.6: Machine cause register (mcause) values after trap.
</code></pre>
<p>Interrupts can be separated from other traps with a single branch on the sign of themcause
register value. A shift left can remove the interrupt bit and scale the exception codes to index
into a trap vector table.</p>
<p>We do not distinguish privileged instruction exceptions from illegal opcode exceptions. This sim-
plifies the architecture and also hides details of which higher-privilege instructions are supported
by an implementation. The privilege level servicing the trap can implement a policy on whether</p>
<pre><code>these need to be distinguished, and if so, whether a given opcode should be treated as illegal or
privileged.
</code></pre>
<p>If an instruction raises multiple synchronous exceptions, the decreasing priority order of Table 3.7
indicates which exception is taken and reported inmcause. The priority of any custom synchronous
exceptions is implementation-defined.</p>
<pre><code>Priority Exception Code Description
Highest 3 Instruction address breakpoint
12 Instruction page fault
1 Instruction access fault
2 Illegal instruction
0 Instruction address misaligned
8, 9, 11 Environment call
3 Environment break
3 Load/Store/AMO address breakpoint
6 Store/AMO address misaligned
4 Load address misaligned
15 Store/AMO page fault
13 Load page fault
7 Store/AMO access fault
Lowest 5 Load access fault
</code></pre>
<pre><code>Table 3.7: Synchronous exception priority in decreasing priority order.
</code></pre>
<pre><code>Instruction address breakpoints have the same cause value as, but different priority than, data
address breakpoints (a.k.a. watchpoints) and environment break exceptions (which are raised by
the EBREAK instruction).
</code></pre>
<pre><code>Instruction address misaligned exceptions are raised by control-flow instructions with misaligned
targets, rather than by the act of fetching an instruction. Therefore, these exceptions have lower
priority than other instruction address exceptions.
</code></pre>
<h3 id="3117-machine-trap-value-mtval-register"><a class="header" href="#3117-machine-trap-value-mtval-register">3.1.17 Machine Trap Value (mtval) Register</a></h3>
<p>Themtvalregister is an MXLEN-bit read-write register formatted as shown in Figure 3.23. When a
trap is taken into M-mode,mtvalis either set to zero or written with exception-specific information
to assist software in handling the trap. Otherwise,mtvalis never written by the implementation,
though it may be explicitly written by software. The hardware platform will specify which excep-
tions must setmtvalinformatively and which may unconditionally set it to zero.</p>
<p>When a hardware breakpoint is triggered, or an instruction-fetch, load, or store address-misaligned,
access, or page-fault exception occurs,mtvalis written with the faulting virtual address. On an
illegal instruction trap,mtvalmay be written with the first XLEN or ILEN bits of the faulting
instruction as described below. For other traps,mtvalis set to zero, but a future standard may
redefinemtval‚Äôs setting for other traps.</p>
<pre><code>Themtvalregister replaces thembadaddrregister in the previous specification. In addition
</code></pre>
<pre><code>to providing bad addresses, the register can now provide the bad instruction that triggered an
illegal instruction trap (and may in future be used to return other information). Returning the
instruction bits accelerates instruction emulation and also removes some races that might be
present when trying to emulate illegal instructions.
When page-based virtual memory is enabled,mtvalis written with the faulting virtual address,
even for physical-memory access exceptions. This design reduces datapath cost for most imple-
mentations, particularly those with hardware page-table walkers.
MXLEN-1 0
mtval
MXLEN
</code></pre>
<pre><code>Figure 3.23: Machine Trap Value register.
</code></pre>
<p>For misaligned loads and stores that cause access or page-fault exceptions,mtvalwill contain the
virtual address of the portion of the access that caused the fault. For instruction-fetch access or
page-fault exceptions on systems with variable-length instructions,mtvalwill contain the virtual
address of the portion of the instruction that caused the fault whilemepcwill point to the beginning
of the instruction.</p>
<p>Themtvalregister can optionally also be used to return the faulting instruction bits on an illegal
instruction exception (mepcpoints to the faulting instruction in memory).</p>
<p>If this feature is not provided, thenmtvalis set to zero on an illegal instruction fault.</p>
<p>If this feature is provided, after an illegal instruction trap,mtvalwill contain the shortest of:</p>
<ul>
<li>the actual faulting instruction</li>
<li>the first ILEN bits of the faulting instruction</li>
<li>the first XLEN bits of the faulting instruction</li>
</ul>
<p>The value loaded intomtvalis right-justified and all unused upper bits are cleared to zero.</p>
<pre><code>Capturing the faulting instruction inmtvalreduces the overhead of instruction emulation, po-
tentially avoiding several partial instruction loads if the instruction is misaligned, and likely data
cache misses or slow uncached accesses when loads are used to fetch the instruction into a data
register. There is also a problem of atomicity if another agent is manipulating the instruction
memory, as might occur in a dynamic translation system.
A requirement is that the entire instruction (or at least the first XLEN bits) are fetched into
mtvalbefore taking the trap. This should not constrain implementations, which would typically
fetch the entire instruction before attempting to decode the instruction, and avoids complicating
software handlers.
A value of zero inmtvalsignifies either that the feature is not supported, or an illegal zero
instruction was fetched. A load from the instruction memory pointed to bymepccan be used
to distinguish these two cases (or alternatively, the system configuration information can be
interrogated to install the appropriate trap handling before runtime).
</code></pre>
<p>If the hardware platform specifies that no exceptions setmtvalto a nonzero value, then it may
be hardwired to zero. Otherwise,mtvalis aWARLregister that must be able to hold all valid
physical and virtual addresses and the value 0. It need not be capable of holding all possible invalid
addresses. Implementations may convert some invalid address patterns into other invalid addresses
prior to writing them tomtval. If the feature to return the faulting instruction bits is implemented,
mtvalmust also be able to hold all values less than 2N, whereNis the smaller of XLEN and ILEN.</p>
<h2 id="32-machine-mode-privileged-instructions"><a class="header" href="#32-machine-mode-privileged-instructions">3.2 Machine-Mode Privileged Instructions</a></h2>
<h3 id="321-environment-call-and-breakpoint"><a class="header" href="#321-environment-call-and-breakpoint">3.2.1 Environment Call and Breakpoint</a></h3>
<pre><code>31 20 19 15 14 12 11 7 6 0
funct12 rs1 funct3 rd opcode
12 5 3 5 7
ECALL 0 PRIV 0 SYSTEM
EBREAK 0 PRIV 0 SYSTEM
</code></pre>
<p>The ECALL instruction is used to make a request to the supporting execution environment.
When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode
exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception,
respectively, and performs no other operation.</p>
<pre><code>ECALL generates a different exception for each originating privilege mode so that environment
call exceptions can be selectively delegated. A typical use case for Unix-like operating systems is
to delegate to S-mode the environment-call-from-U-mode exception but not the others.
</code></pre>
<p>The EBREAK instruction is used by debuggers to cause control to be transferred back to a debug-
ging environment. It generates a breakpoint exception and performs no other operation.</p>
<pre><code>As described in the ‚ÄúC‚Äù Standard Extension for Compressed Instructions in Volume I of this
manual, the C.EBREAK instruction performs the same operation as the EBREAK instruction.
</code></pre>
<p>ECALL and EBREAK cause the receiving privilege mode‚Äôsepcregister to be set to the address of
the ECALL or EBREAK instruction itself,notthe address of the following instruction.</p>
<h3 id="322-trap-return-instructions"><a class="header" href="#322-trap-return-instructions">3.2.2 Trap-Return Instructions</a></h3>
<p>Instructions to return from trap are encoded under the PRIV minor opcode.</p>
<pre><code>31 20 19 15 14 12 11 7 6 0
funct12 rs1 funct3 rd opcode
12 5 3 5 7
MRET/SRET/URET 0 PRIV 0 SYSTEM
</code></pre>
<p>To return after handling a trap, there are separate trap return instructions per privilege level:
MRET, SRET, and URET. MRET is always provided. SRET must be provided if supervisor mode
is supported, and should raise an illegal instruction exception otherwise. SRET should also raise an
illegal instruction exception when TSR=1 inmstatus, as described in Section 3.1.6.4. URET is only
provided if user-mode traps are supported, and should raise an illegal instruction otherwise. An
xRET instruction can be executed in privilege modexor higher, where executing a lower-privilege
xRET instruction will pop the relevant lower-privilege interrupt enable and privilege mode stack.
In addition to manipulating the privilege stack as described in Section 3.1.6.1,xRET sets thepc
to the value stored in thexepcregister.</p>
<pre><code>Previously, there was only a single ERET instruction (which was also earlier known as SRET).
To support the addition of user-level interrupts, we needed to add a separate URET instruction
to continue to allow classic virtualization of OS code using the ERET instruction. It then became
more orthogonal to support a differentxRET instruction per privilege level.
</code></pre>
<p>If the A extension is supported, thexRET instruction is allowed to clear any outstanding LR
address reservation but is not required to. Trap handlers should explicitly clear the reservation if
required (e.g., by using a dummy SC) before executing thexRET.</p>
<pre><code>IfxRET instructions always cleared LR reservations, it would be impossible to single-step
through LR/SC sequences using a debugger.
</code></pre>
<h3 id="323-wait-for-interrupt"><a class="header" href="#323-wait-for-interrupt">3.2.3 Wait for Interrupt</a></h3>
<p>The Wait for Interrupt instruction (WFI) provides a hint to the implementation that the current
hart can be stalled until an interrupt might need servicing. Execution of the WFI instruction
can also be used to inform the hardware platform that suitable interrupts should preferentially be
routed to this hart. WFI is available in all privileged modes, and optionally available to U-mode.
This instruction may raise an illegal instruction exception when TW=1 inmstatus, as described
in Section 3.1.6.4.</p>
<pre><code>31 20 19 15 14 12 11 7 6 0
funct12 rs1 funct3 rd opcode
12 5 3 5 7
WFI 0 PRIV 0 SYSTEM
</code></pre>
<p>If an enabled interrupt is present or later becomes present while the hart is stalled, the interrupt
exception will be taken on the following instruction, i.e., execution resumes in the trap handler and
mepc=pc+ 4.</p>
<pre><code>The following instruction takes the interrupt exception and trap, so that a simple return from
the trap handler will execute code after the WFI instruction.
</code></pre>
<p>The purpose of the WFI instruction is to provide a hint to the implementation, and so a legal
implementation is to simply implement WFI as a NOP.</p>
<pre><code>If the implementation does not stall the hart on execution of the instruction, then the interrupt
will be taken on some instruction in the idle loop containing the WFI, and on a simple return
from the handler, the idle loop will resume execution.
</code></pre>
<p>The WFI instruction can also be executed when interrupts are disabled. The operation of WFI must
be unaffected by the global interrupt bits inmstatus(MIE/SIE/UIE) and the delegation registers
[m|s]ideleg(i.e., the hart must resume if a locally enabled interrupt becomes pending, even if it
has been delegated to a less-privileged mode), but should honor the individual interrupt enables
(e.g, MTIE) (i.e., implementations should avoid resuming the hart if the interrupt is pending but
not individually enabled). WFI is also required to resume execution for locally enabled interrupts
pending at any privilege level, regardless of the global interrupt enable at each privilege level.</p>
<p>If the event that causes the hart to resume execution does not cause an interrupt to be taken,
execution will resume atpc+ 4, and software must determine what action to take, including
looping back to repeat the WFI if there was no actionable event.</p>
<pre><code>By allowing wakeup when interrupts are disabled, an alternate entry point to an interrupt handler
can be called that does not require saving the current context, as the current context can be saved
or discarded before the WFI is executed.
As implementations are free to implement WFI as a NOP, software must explicitly check
for any relevant pending but disabled interrupts in the code following an WFI, and should loop
back to the WFI if no suitable interrupt was detected. Themip,sip, oruipregisters can be
interrogated to determine the presence of any interrupt in machine, supervisor, or user mode
respectively.
The operation of WFI is unaffected by the delegation register settings.
WFI is defined so that an implementation can trap into a higher privilege mode, either im-
mediately on encountering the WFI or after some interval to initiate a machine-mode transition
to a lower power state, for example.
</code></pre>
<pre><code>The same ‚Äúwait-for-event‚Äù template might be used for possible future extensions that wait on
memory locations changing, or message arrival.
</code></pre>
<h2 id="33-reset"><a class="header" href="#33-reset">3.3 Reset</a></h2>
<p>Upon reset, a hart‚Äôs privilege mode is set to M. Themstatusfields MIE and MPRV are reset to 0.
Themisaregister is reset to enable the maximal set of supported extensions and widest MXLEN,
as described in Section 3.1.1. Thepcis set to an implementation-defined reset vector. Themcause
register is set to a value indicating the cause of the reset. Writable PMP registers‚Äô A and L fields
are set to 0. All other hart state is unspecified.</p>
<p>Themcausevalues after reset have implementation-specific interpretation, but the value 0 should
be returned on implementations that do not distinguish different reset conditions. Implementations
that distinguish different reset conditions should only use 0 to indicate the most complete reset
(e.g., hard reset).</p>
<pre><code>Some designs may have multiple causes of reset (e.g., power-on reset, external hard reset,
brownout detected, watchdog timer elapse, sleep-mode wakeup), which machine-mode software
and debuggers may wish to distinguish.
mcausereset values may aliasmcausevalues following synchronous exceptions. There should
be no ambiguity in this overlap, since on reset thepcis typically set to a different value than
on other traps.
</code></pre>
<h2 id="34-non-maskable-interrupts"><a class="header" href="#34-non-maskable-interrupts">3.4 Non-Maskable Interrupts</a></h2>
<p>Non-maskable interrupts (NMIs) are only used for hardware error conditions, and cause an imme-
diate jump to an implementation-defined NMI vector running in M-mode regardless of the state of
a hart‚Äôs interrupt enable bits. Themepcregister is written with the address of the next instruction
to be executed at the time the NMI was taken, andmcauseis set to a value indicating the source
of the NMI. The NMI can thus overwrite state in an active machine-mode interrupt handler.</p>
<p>The values written tomcauseon an NMI are implementation-defined, but a value of 0 is reserved
to mean ‚Äúunknown cause‚Äù and implementations that do not distinguish sources of NMIs via the
mcauseregister should return 0.</p>
<p>Unlike resets, NMIs do not reset processor state, enabling diagnosis, reporting, and possible con-
tainment of the hardware error.</p>
<h2 id="35-physical-memory-attributes"><a class="header" href="#35-physical-memory-attributes">3.5 Physical Memory Attributes</a></h2>
<p>The physical memory map for a complete system includes various address ranges, some correspond-
ing to memory regions, some to memory-mapped control registers, and some to empty holes in the
address space. Some memory regions might not support reads, writes, or execution; some might
not support subword or subblock accesses; some might not support atomic operations; and some
might not support cache coherence or might have different memory models. Similarly, memory-
mapped control registers vary in their supported access widths, support for atomic operations, and
whether read and write accesses have associated side effects. In RISC-V systems, these properties
and capabilities of each region of the machine‚Äôs physical address space are termedphysical memory
attributes(PMAs). This section describes RISC-V PMA terminology and how RISC-V systems
implement and check PMAs.</p>
<p>PMAs are inherent properties of the underlying hardware and rarely change during system oper-
ation. Unlike physical memory protection values described in Section 3.6, PMAs do not vary by
execution context. The PMAs of some memory regions are fixed at chip design time‚Äîfor example,
for an on-chip ROM. Others are fixed at board design time, depending, for example, on which
other chips are connected to off-chip buses. Off-chip buses might also support devices that could
be changed on every power cycle (cold pluggable) or dynamically while the system is running (hot
pluggable). Some devices might be configurable at run time to support different uses that imply
different PMAs‚Äîfor example, an on-chip scratchpad RAM might be cached privately by one core
in one end-application, or accessed as a shared non-cached memory in another end-application.</p>
<p>Most systems will require that at least some PMAs are dynamically checked in hardware later in
the execution pipeline after the physical address is known, as some operations will not be supported
at all physical memory addresses, and some operations require knowing the current setting of a
configurable PMA attribute. While many other architectures specify some PMAs in the virtual
memory page tables and use the TLB to inform the pipeline of these properties, this approach
injects platform-specific information into a virtualized layer and can cause system errors unless
attributes are correctly initialized in each page-table entry for each physical memory region. In
addition, the available page sizes might not be optimal for specifying attributes in the physical
memory space, leading to address-space fragmentation and inefficient use of expensive TLB entries.</p>
<p>For RISC-V, we separate out specification and checking of PMAs into a separate hardware structure,
thePMA checker. In many cases, the attributes are known at system design time for each physical
address region, and can be hardwired into the PMA checker. Where the attributes are run-time
configurable, platform-specific memory-mapped control registers can be provided to specify these
attributes at a granularity appropriate to each region on the platform (e.g., for an on-chip SRAM
that can be flexibly divided between cacheable and uncacheable uses). PMAs are checked for any
access to physical memory, including accesses that have undergone virtual to physical memory</p>
<p>translation. To aid in system debugging, we strongly recommend that, where possible, RISC-V
processors precisely trap physical memory accesses that fail PMA checks. Precisely trapped PMA
violations manifest as load, store, or instruction-fetch access exceptions, distinct from virtual-
memory page-fault exceptions. Precise PMA traps might not always be possible, for example, when
probing a legacy bus architecture that uses access failures as part of the discovery mechanism. In
this case, error responses from slave devices will be reported as imprecise bus-error interrupts.</p>
<p>PMAs must also be readable by software to correctly access certain devices or to correctly configure
other hardware components that access memory, such as DMA engines. As PMAs are tightly tied
to a given physical platform‚Äôs organization, many details are inherently platform-specific, as is the
means by which software can learn the PMA values for a platform. Some devices, particularly
legacy buses, do not support discovery of PMAs and so will give error responses or time out if
an unsupported access is attempted. Typically, platform-specific machine-mode code will extract
PMAs and ultimately present this information to higher-level less-privileged software using some
standard representation.</p>
<p>Where platforms support dynamic reconfiguration of PMAs, an interface will be provided to set
the attributes by passing requests to a machine-mode driver that can correctly reconfigure the
platform. For example, switching cacheability attributes on some memory regions might involve
platform-specific operations, such as cache flushes, that are available only to machine-mode.</p>
<h3 id="351-main-memory-versus-io-versus-empty-regions"><a class="header" href="#351-main-memory-versus-io-versus-empty-regions">3.5.1 Main Memory versus I/O versus Empty Regions</a></h3>
<p>The most important characterization of a given memory address range is whether it holds regular
main memory, or I/O devices, or is empty. Regular main memory is required to have a number
of properties, specified below, whereas I/O devices can have a much broader range of attributes.
Memory regions that do not fit into regular main memory, for example, device scratchpad RAMs,
are categorized as I/O regions. Empty regions are also classified as I/O regions but with attributes
specifying that no accesses are supported.</p>
<h3 id="352-supported-access-type-pmas"><a class="header" href="#352-supported-access-type-pmas">3.5.2 Supported Access Type PMAs</a></h3>
<p>Access types specify which access widths, from 8-bit byte to long multi-word burst, are supported,
and also whether misaligned accesses are supported for each access width.</p>
<pre><code>Although software running on a RISC-V hart cannot directly generate bursts to memory, software
might have to program DMA engines to access I/O devices and might therefore need to know
which access sizes are supported.
</code></pre>
<p>Main memory regions always support read, write, and execute of all access widths required by the
attached devices.</p>
<pre><code>In some cases, the design of a processor or device accessing main memory might support other
widths, but must be able to function with the types supported by the main memory.
</code></pre>
<p>I/O regions can specify which combinations of read, write, or execute accesses to which data widths
are supported.</p>
<h3 id="353-atomicity-pmas"><a class="header" href="#353-atomicity-pmas">3.5.3 Atomicity PMAs</a></h3>
<p>Atomicity PMAs describes which atomic instructions are supported in this address region. Main
memory regions must support the atomic operations required by the processors attached. I/O
regions may only support a subset or none of the processor-supported atomic operations.</p>
<p>Support for atomic instructions is divided into two categories: LR/SC and AMOs. Within
AMOs, there are four levels of support: AMONone,AMOSwap,AMOLogical, andAMOArith-
metic. AMONone indicates that no AMO operations are supported. AMOSwap indicates that
onlyamoswapinstructions are supported in this address range. AMOLogical indicates that swap
instructions plus all the logical AMOs (amoand,amoor,amoxor) are supported. AMOArithmetic
indicates that all RISC-V AMOs are supported. For each level of support, naturally aligned AMOs
of a given width are supported if the underlying memory region supports reads and writes of that
width.</p>
<pre><code>AMO Class Supported Operations
AMONone None
AMOSwap amoswap
AMOLogical above +amoand,amoor,amoxor
AMOArithmetic above +amoadd,amomin,amomax,amominu,amomaxu
</code></pre>
<p>Table 3.8: Classes of AMOs supported by I/O regions. Main memory regions must always support
all AMOs required by the processor.</p>
<pre><code>We recommend providing at least AMOLogical support for I/O regions where possible. Most
I/O regions will not support LR/SC accesses, as these are most conveniently built on top of a
cache-coherence scheme.
</code></pre>
<p>Memory regions that support LR/SC will define the conditions under which LR/SC sequences must
succeed or must fail. Main memory must guarantee the eventual success of any LR/SC sequence
that meets the requirements described in the user ISA specification.</p>
<p>Memory regions that support aligned LR/SC or aligned AMOs might also support misaligned
LR/SC or misaligned AMOs for some addresses and access widths. If, for a given address and
access width, a misaligned LR/SC or AMO generates an address-misaligned exception, thenall
loads, stores, LRs/SCs, and AMOs using that address and access width must generate address-
misaligned exceptions.</p>
<pre><code>The standard ‚ÄúA‚Äù extension does not support misaligned AMOs or LR/SC pairs. Support for
misaligned AMOs is provided by the standard ‚ÄúZam‚Äù extension. Support for misaligned LR/SC
sequences is not currently standardized, so LR and SC to misaligned addresses must raise an
exception.
Mandating that misaligned loads and stores raise address-misaligned exceptions wherever
misaligned AMOs raise address-misaligned exceptions permits the emulation of misaligned AMOs
in an M-mode trap handler. The handler guarantees atomicity by acquiring a global mutex and
emulating the access within the critical section. Provided that the handler for misaligned loads
and stores uses the same mutex, all accesses to a given address that use the same word size will
be mutually atomic.
</code></pre>
<p>Implementations may raise access exceptions instead of address-misaligned exceptions for some
misaligned accesses, indicating the instruction should not be emulated by a trap handler. If, for
a given address and access width, all misaligned LRs/SCs and AMOs generate access exceptions,
then regular misaligned loads and stores using the same address and access width are not required
to execute atomically.</p>
<h3 id="354-memory-ordering-pmas"><a class="header" href="#354-memory-ordering-pmas">3.5.4 Memory-Ordering PMAs</a></h3>
<p>Regions of the address space are classified as eithermain memoryorI/Ofor the purposes of ordering
by the FENCE instruction and atomic-instruction ordering bits.</p>
<p>Accesses by one hart to main memory regions are observable not only by other harts but also
by other devices with the capability to initiate requests in the main memory system (e.g., DMA
engines). Main memory regions always have either the RVWMO or RVTSO memory model.</p>
<p>Accesses by one hart to the I/O space are observable not only by other harts and bus mastering
devices, but also by targeted slave I/O devices. Within I/O, regions may further be classified as
implementing eitherrelaxedorstrongordering. A relaxed I/O region has no ordering guarantees
on how memory accesses made by one hart are observable by different harts or I/O devices beyond
those enforced by FENCE and AMO instructions. A strongly ordered I/O region ensures that all
accesses made by a hart to that region are only observable in program order by all other harts or
I/O devices.</p>
<p>Each strongly ordered I/O region specifies a numbered ordering channel, which is a mechanism by
which ordering guarantees can be provided between different I/O regions. Channel 0 is used to
indicate point-to-point strong ordering only, where only accesses by the hart to the single associated
I/O region are strongly ordered.</p>
<p>Channel 1 is used to provide global strong ordering across all I/O regions. Any accesses by a hart to
any I/O region associated with channel 1 can only be observed to have occurred in program order
by all other harts and I/O devices, including relative to accesses made by that hart to relaxed I/O
regions or strongly ordered I/O regions with different channel numbers. In other words, any access
to a region in channel 1 is equivalent to executing afence io,ioinstruction before and after the
instruction.</p>
<p>Other larger channel numbers provide program ordering to accesses by that hart across any regions
with the same channel number.</p>
<p>Systems might support dynamic configuration of ordering properties on each memory region.</p>
<pre><code>Strong ordering can be used to improve compatibility with legacy device driver code, or to enable
increased performance compared to insertion of explicit ordering instructions when the imple-
mentation is known to not reorder accesses.
Local strong ordering (channel 0) is the default form of strong ordering as it is often straight-
forward to provide if there is only a single in-order communication path between the hart and
the I/O device.
Generally, different strongly ordered I/O regions can share the same ordering channel without
additional ordering hardware if they share the same interconnect path and the path does not
reorder requests.
</code></pre>
<h3 id="355-coherence-and-cacheability-pmas"><a class="header" href="#355-coherence-and-cacheability-pmas">3.5.5 Coherence and Cacheability PMAs</a></h3>
<p>Coherence is a property defined for a single physical address, and indicates that writes to that
address by one agent will eventually be made visible to other agents in the system. Coherence
is not to be confused with the memory consistency model of a system, which defines what values
a memory read can return given the previous history of reads and writes to the entire memory
system. In RISC-V platforms, the use of hardware-incoherent regions is discouraged due to software
complexity, performance, and energy impacts.</p>
<p>The cacheability of a memory region should not affect the software view of the region except
for differences reflected in other PMAs, such as main memory versus I/O classification, memory
ordering, supported accesses and atomic operations, and coherence. For this reason, we treat
cacheability as a platform-level setting managed by machine-mode software only.</p>
<p>Where a platform supports configurable cacheability settings for a memory region, a platform-
specific machine-mode routine will change the settings and flush caches if necessary, so the system
is only incoherent during the transition between cacheability settings. This transitory state should
not be visible to lower privilege levels.</p>
<pre><code>We categorize RISC-V caches into three types: master-private, shared, and slave-private.
Master-private caches are attached to a single master agent, i.e., one that issues read/write
requests to the memory system. Shared caches are located between masters and slaves and may
be hierarchically organized. Slave-private caches do not impact coherence, as they are local to
a single slave and do not affect other PMAs at a master, so are not considered further here.
We useprivate cacheto mean a master-private cache in the following section, unless explicitly
stated otherwise.
Coherence is straightforward to provide for a shared memory region that is not cached by any
agent. The PMA for such a region would simply indicate it should not be cached in a private or
shared cache.
Coherence is also straightforward for read-only regions, which can be safely cached by multiple
agents without requiring a cache-coherence scheme. The PMA for this region would indicate that
it can be cached, but that writes are not supported.
Some read-write regions might only be accessed by a single agent, in which case they can be
cached privately by that agent without requiring a coherence scheme. The PMA for such regions
would indicate they can be cached. The data can also be cached in a shared cache, as other
agents should not access the region.
If an agent can cache a read-write region that is accessible by other agents, whether caching
or non-caching, a cache-coherence scheme is required to avoid use of stale values. In regions
lacking hardware cache coherence (hardware-incoherent regions), cache coherence can be im-
plemented entirely in software, but software coherence schemes are notoriously difficult to im-
plement correctly and often have severe performance impacts due to the need for conservative
software-directed cache-flushing. Hardware cache-coherence schemes require more complex hard-
ware and can impact performance due to the cache-coherence probes, but are otherwise invisible
to software.
For each hardware cache-coherent region, the PMA would indicate that the region is coherent
and which hardware coherence controller to use if the system has multiple coherence controllers.
For some systems, the coherence controller might be an outer-level shared cache, which might
itself access further outer-level cache-coherence controllers hierarchically.
Most memory regions within a platform will be coherent to software, because they will be
fixed as either uncached, read-only, hardware cache-coherent, or only accessed by one agent.
</code></pre>
<h3 id="356-idempotency-pmas"><a class="header" href="#356-idempotency-pmas">3.5.6 Idempotency PMAs</a></h3>
<p>Idempotency PMAs describe whether reads and writes to an address region are idempotent. Main
memory regions are assumed to be idempotent. For I/O regions, idempotency on reads and writes
can be specified separately (e.g., reads are idempotent but writes are not). If accesses are non-
idempotent, i.e., there is potentially a side effect on any read or write access, then speculative or
redundant accesses must be avoided.</p>
<p>For the purposes of defining the idempotency PMAs, changes in observed memory ordering created
by redundant accesses are not considered a side effect.</p>
<pre><code>While hardware should always be designed to avoid speculative or redundant accesses to memory
regions marked as non-idempotent, it is also necessary to ensure software or compiler optimiza-
tions do not generate spurious accesses to non-idempotent memory regions.
</code></pre>
<pre><code>Non-idempotent regions might not support misaligned accesses. Misaligned accesses to such
regions should raise access exceptions rather than address-misaligned exceptions, indicating that
software should not emulate the misaligned access using multiple smaller accesses, which could
cause unexpected side effects.
</code></pre>
<h3 id="36-physical-memory-protection"><a class="header" href="#36-physical-memory-protection">3.6 Physical Memory Protection</a></h3>
<p>To support secure processing and contain faults, it is desirable to limit the physical addresses
accessible by software running on a hart. An optional physical memory protection (PMP) unit
provides per-hart machine-mode control registers to allow physical memory access privileges (read,
write, execute) to be specified for each physical memory region. The PMP values are checked in
parallel with the PMA checks described in Section 3.5.</p>
<p>The granularity of PMP access control settings are platform-specific and within a platform may
vary by physical memory region, but the standard PMP encoding supports regions as small as four
bytes. Certain regions‚Äô privileges can be hardwired‚Äîfor example, some regions might only ever be
visible in machine mode but in no lower-privilege layers.</p>
<pre><code>Platforms vary widely in demands for physical memory protection, and some platforms may
provide other PMP structures in addition to or instead of the scheme described in this section.
</code></pre>
<p>PMP checks are applied to all accesses when the hart is running in S or U modes, and for loads
and stores when the MPRV bit is set in themstatusregister and the MPP field in themstatus
register contains S or U. PMP checks are also applied to page-table accesses for virtual-address
translation, for which the effective privilege mode is S. Optionally, PMP checks may additionally
apply to M-mode accesses, in which case the PMP registers themselves are locked, so that even
M-mode software cannot change them without a system reset. In effect, PMP cangrantpermissions
to S and U modes, which by default have none, and canrevokepermissions from M-mode, which
by default has full permissions.</p>
<p>PMP violations are always trapped precisely at the processor.</p>
<h4 id="361-physical-memory-protection-csrs"><a class="header" href="#361-physical-memory-protection-csrs">3.6.1 Physical Memory Protection CSRs</a></h4>
<p>PMP entries are described by an 8-bit configuration register and one MXLEN-bit address register.
Some PMP settings additionally use the address register associated with the preceding PMP entry.
Up to 16 PMP entries are supported. If any PMP entries are implemented, then all PMP CSRs
must be implemented, but all PMP CSR fields areWARLand may be hardwired to zero. PMP
CSRs are only accessible to M-mode.</p>
<p>The PMP configuration registers are densely packed into CSRs to minimize context-switch time.
For RV32, four CSRs,pmpcfg0‚Äìpmpcfg3, hold the configurationspmp0cfg‚Äìpmp15cfgfor the 16
PMP entries, as shown in Figure 3.24. For RV64,pmpcfg0andpmpcfg2hold the configurations
for the 16 PMP entries, as shown in Figure 3.25;pmpcfg1andpmpcfg3are illegal.</p>
<pre><code>RV64 systems usepmpcfg2, rather thanpmpcfg1, to hold configurations for PMP entries 8‚Äì15.
This design reduces the cost of supporting multiple MXLEN values, since the configurations for
PMP entries 8‚Äì11 appear inpmpcfg2[31:0] for both RV32 and RV64.
31 24 23 16 15 8 7 0
pmp3cfg pmp2cfg pmp1cfg pmp0cfg pmpcfg0
8 8 8 8
31 24 23 16 15 8 7 0
pmp7cfg pmp6cfg pmp5cfg pmp4cfg pmpcfg1
8 8 8 8
31 24 23 16 15 8 7 0
pmp11cfg pmp10cfg pmp9cfg pmp8cfg pmpcfg2
8 8 8 8
31 24 23 16 15 8 7 0
pmp15cfg pmp14cfg pmp13cfg pmp12cfg pmpcfg3
8 8 8 8
</code></pre>
<pre><code>Figure 3.24: RV32 PMP configuration CSR layout.
</code></pre>
<pre><code>63 56 55 48 47 40 39 32 31 24 23 16 15 8 7 0
pmp7cfg pmp6cfg pmp5cfg pmp4cfg pmp3cfg pmp2cfg pmp1cfg pmp0cfg pmpcfg0
8 8 8 8 8 8 8 8
63 56 55 48 47 40 39 32 31 24 23 16 15 8 7 0
pmp15cfg pmp14cfg pmp13cfg pmp12cfg pmp11cfg pmp10cfg pmp9cfg pmp8cfg pmpcfg2
8 8 8 8 8 8 8 8
</code></pre>
<pre><code>Figure 3.25: RV64 PMP configuration CSR layout.
</code></pre>
<p>The PMP address registers are CSRs namedpmpaddr0‚Äìpmpaddr15. Each PMP address register
encodes bits 33‚Äì2 of a 34-bit physical address for RV32, as shown in Figure 3.26. For RV64, each
PMP address register encodes bits 55‚Äì2 of a 56-bit physical address, as shown in Figure 3.27. Not
all physical address bits may be implemented, and so thepmpaddrregisters areWARL.</p>
<pre><code>The Sv32 page-based virtual-memory scheme described in Section 4.3 supports 34-bit physical
addresses for RV32, so the PMP scheme must support addresses wider than XLEN for RV32.
The Sv39 and Sv48 page-based virtual-memory schemes described in Sections 4.4 and 4.5 support
a 56-bit physical address space, so the RV64 PMP address registers impose the same limit.
</code></pre>
<p>Figure 3.28 shows the layout of a PMP configuration register. The R, W, and X bits, when set,
indicate that the PMP entry permits read, write, and instruction execution, respectively. When one</p>
<pre><code>31 0
address[33:2] (WARL)
32
</code></pre>
<pre><code>Figure 3.26: PMP address register format, RV32.
</code></pre>
<pre><code>63 54 53 0
0 (WARL) address[55:2] (WARL)
10 54
</code></pre>
<pre><code>Figure 3.27: PMP address register format, RV64.
</code></pre>
<p>of these bits is clear, the corresponding access type is denied. The combination R=0 and W=1 is
reserved for future use. The remaining two fields, A and L, are described in the following sections.</p>
<pre><code>7 6 5 4 3 2 1 0
L (WARL) 0 (WARL) A (WARL) X (WARL) W (WARL) R (WARL)
1 2 2 1 1 1
</code></pre>
<pre><code>Figure 3.28: PMP configuration register format.
</code></pre>
<p>Attempting to fetch an instruction from a PMP region that does not have execute permissions
raises a fetch access exception. Attempting to execute a load or load-reserved instruction whose
effective address lies within a PMP region without read permissions raises a load access exception.
Attempting to execute a store, store-conditional (regardless of success), or AMO instruction whose
effective address lies within a PMP region without write permissions raises a store access exception.</p>
<p>If MXLEN is changed, the contents of thepmpxcfgfields are preserved, but appear in thepmpcfgy
CSR prescribed by the new setting of MXLEN. For example, when MXLEN is changed from 64 to
32,pmp4cfgmoves frompmpcfg0[39:32] topmpcfg1[7:0]. ThepmpaddrCSRs follow the usual CSR
width modulation rules described in Section 2.4.</p>
<p>Address Matching</p>
<p>The A field in a PMP entry‚Äôs configuration register encodes the address-matching mode of the
associated PMP address register. The encoding of this field is shown in Table 3.9. When A=0,
this PMP entry is disabled and matches no addresses. Two other address-matching modes are
supported: naturally aligned power-of-2 regions (NAPOT), including the special case of naturally
aligned four-byte regions (NA4); and the top boundary of an arbitrary range (TOR). These modes
support four-byte granularity.</p>
<pre><code>A Name Description
0 OFF Null region (disabled)
1 TOR Top of range
2 NA4 Naturally aligned four-byte region
3 NAPOT Naturally aligned power-of-two region,‚â•8 bytes
</code></pre>
<pre><code>Table 3.9: Encoding of A field in PMP configuration registers.
</code></pre>
<p>NAPOT ranges make use of the low-order bits of the associated address register to encode the size
of the range, as shown in Table 3.10.</p>
<pre><code>pmpaddr pmpcfg.A Match type and size
yyyy...yyyy NA4 4-byte NAPOT range
yyyy...yyy0 NAPOT 8-byte NAPOT range
yyyy...yy01 NAPOT 16-byte NAPOT range
yyyy...y011 NAPOT 32-byte NAPOT range
</code></pre>
<p>.........
yy01...1111 NAPOT 2 XLEN-byte NAPOT range
y011...1111 NAPOT 2 XLEN+1-byte NAPOT range
0111...1111 NAPOT 2 XLEN+2-byte NAPOT range
1111...1111 NAPOT 2 XLEN+3-byte NAPOT range</p>
<pre><code>Table 3.10: NAPOT range encoding in PMP address and configuration registers.
</code></pre>
<p>If TOR is selected, the associated address register forms the top of the address range, and the
preceding PMP address register forms the bottom of the address range. If PMP entryi‚Äôs A field
is set to TOR, the entry matches any addressysuch thatpmpaddri‚àí 1 ‚â§y &lt;pmpaddri. If PMP
entry 0‚Äôs A field is set to TOR, zero is used for the lower bound, and so it matches any address
y &lt;pmpaddr 0.</p>
<p>Although the PMP mechanism supports regions as small as four bytes, platforms may specify
coarser PMP regions. In general, the PMP grain is 2G+2bytes and must be the same across all
PMP regions. WhenG‚â•1, the NA4 mode is not selectable. WhenG‚â•2 andpmpcfgi.A[1] is set,
i.e. the mode is NAPOT, then bitspmpaddri[G-2:0] read as all ones. WhenG‚â•1 andpmpcfgi.A[1]
is clear, i.e. the mode is OFF or TOR, then bitspmpaddri[G-1:0] read as all zeros. Bitspmpaddri[G-
1:0] do not affect the TOR address-matching logic. Although changingpmpcfgi.A[1] affects the value
read frompmpaddri, it does not affect the underlying value stored in that register‚Äîin particular,
pmpaddri[G-1] retains its original value whenpmpcfgi.A is changed from NAPOT to TOR/OFF
then back to NAPOT.</p>
<pre><code>Software may determine the PMP granularity by writing zero topmp0cfg, then writing all ones
topmpaddr0, then reading backpmpaddr0. IfGis the index of the least-significant bit set, the
PMP granularity is 2 G+2bytes.
</code></pre>
<p>If the current XLEN is greater than MXLEN, the PMP address registers are zero-extended from
MXLEN to XLEN bits for the purposes of address matching.</p>
<p>Locking and Privilege Mode</p>
<p>The L bit indicates that the PMP entry is locked, i.e., writes to the configuration register and
associated address registers are ignored. Locked PMP entries may only be unlocked with a system
reset. If PMP entryiis locked, writes topmpicfgandpmpaddriare ignored. Additionally, if
pmpicfg.A is set to TOR, writes topmpaddri-1 are ignored.</p>
<p>In addition to locking the PMP entry, the L bit indicates whether the R/W/X permissions are
enforced on M-mode accesses. When the L bit is set, these permissions are enforced for all privilege</p>
<p>modes. When the L bit is clear, any M-mode access matching the PMP entry will succeed; the
R/W/X permissions apply only to S and U modes.</p>
<p>Priority and Matching Logic</p>
<p>PMP entries are statically prioritized. The lowest-numbered PMP entry that matches any byte of
an access determines whether that access succeeds or fails. The matching PMP entry must match
all bytes of an access, or the access fails, irrespective of the L, R, W, and X bits. For example,
if a PMP entry is configured to match the four-byte range0xC‚Äì0xF, then an 8-byte access to the
range0x8‚Äì0xFwill fail, assuming that PMP entry is the highest-priority entry that matches those
addresses.</p>
<p>If a PMP entry matches all bytes of an access, then the L, R, W, and X bits determine whether the
access succeeds or fails. If the L bit is clear and the privilege mode of the access is M, the access
succeeds. Otherwise, if the L bit is set or the privilege mode of the access is S or U, then the access
succeeds only if the R, W, or X bit corresponding to the access type is set.</p>
<p>If no PMP entry matches an M-mode access, the access succeeds. If no PMP entry matches an
S-mode or U-mode access, but at least one PMP entry is implemented, the access fails.</p>
<p>Failed accesses generate a load, store, or instruction access exception. Note that a single instruction
may generate multiple accesses, which may not be mutually atomic. An access exception is gen-
erated if at least one access generated by an instruction fails, though other accesses generated by
that instruction may succeed with visible side effects. Notably, instructions that reference virtual
memory are decomposed into multiple accesses.</p>
<p>On some implementations, misaligned loads, stores, and instruction fetches may also be decomposed
into multiple accesses, some of which may succeed before an access exception occurs. In particular,
a portion of a misaligned store that passes the PMP check may become visible, even if another
portion fails the PMP check. The same behavior may manifest for floating-point stores wider than
XLEN bits (e.g., the FSD instruction in RV32D), even when the store address is naturally aligned.</p>
<h4 id="362-physical-memory-protection-and-paging"><a class="header" href="#362-physical-memory-protection-and-paging">3.6.2 Physical Memory Protection and Paging</a></h4>
<p>The Physical Memory Protection mechanism is designed to compose with the page-based virtual
memory systems described in Chapter 4. When paging is enabled, instructions that access virtual
memory may result in multiple physical-memory accesses, including implicit references to the page
tables. The PMP checks apply to all of these accesses. The effective privilege mode for implicit
page-table accesses is S.</p>
<p>Implementations with virtual memory are permitted to perform address translations speculatively
and earlier than required by an explicit virtual-memory access. The PMP settings for the resulting
physical address may be checked at any point between the address translation and the explicit
virtual-memory access. Hence, when the PMP settings are modified in a manner that affects either
the physical memory that holds the page tables or the physical memory to which the page tables
point, M-mode software must synchronize the PMP settings with the virtual memory system. This
is accomplished by executing an SFENCE.VMA instruction withrs1=x0andrs2=x0, after the</p>
<p>PMP CSRs are written.</p>
<p>If page-based virtual memory is not implemented, or when it is disabled, memory accesses check
the PMP settings synchronously, so no fence is needed.</p>
<h2 id="chapter-4"><a class="header" href="#chapter-4">Chapter 4</a></h2>
<h1 id="supervisor-level-isa-version-111"><a class="header" href="#supervisor-level-isa-version-111">Supervisor-Level ISA, Version 1.11</a></h1>
<p>This chapter describes the RISC-V supervisor-level architecture, which contains a common core
that is used with various supervisor-level address translation and protection schemes.</p>
<pre><code>Supervisor mode is deliberately restricted in terms of interactions with underlying physical hard-
ware, such as physical memory and device interrupts, to support clean virtualization. In this
spirit, certain supervisor-level facilities, including requests for timer and interprocessor inter-
rupts, are provided by implementation-specific mechanisms. In some systems, a supervisor execu-
tion environment (SEE) provides these facilities in a manner specified by a superivsor binary in-
terface (SBI). Other systems supply these facilities directly, through some other implementation-
defined mechanism.
</code></pre>
<h3 id="41-supervisor-csrs"><a class="header" href="#41-supervisor-csrs">4.1 Supervisor CSRs</a></h3>
<p>A number of CSRs are provided for the supervisor.</p>
<pre><code>The supervisor should only view CSR state that should be visible to a supervisor-level operating
system. In particular, there is no information about the existence (or non-existence) of higher
privilege levels (hypervisor or machine) visible in the CSRs accessible by the supervisor.
Many supervisor CSRs are a subset of the equivalent machine-mode CSR, and the machine-
mode chapter should be read first to help understand the supervisor-level CSR descriptions.
</code></pre>
<h4 id="411-supervisor-status-register-sstatus"><a class="header" href="#411-supervisor-status-register-sstatus">4.1.1 Supervisor Status Register (sstatus)</a></h4>
<p>Thesstatusregister is an SXLEN-bit read/write register formatted as shown in Figure 4.1 for
RV32 and Figure 4.2 for RV64. Thesstatusregister keeps track of the processor‚Äôs current operating
state.</p>
<p>The SPP bit indicates the privilege level at which a hart was executing before entering supervisor
mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise.
When an SRET instruction (see Section 3.2.2) is executed to return from the trap handler, the</p>
<pre><code>55
</code></pre>
<pre><code>31 30 20 19 18 17 16 15 14 13 12 9 8 7 6 5 4 3 2 1 0
SD WPRI MXR SUM WPRI XS[1:0] FS[1:0] WPRI SPP WPRI SPIE UPIE WPRI SIE UIE
1 11 1 1 1 2 2 4 1 2 1 1 2 1 1
</code></pre>
<pre><code>Figure 4.1: Supervisor-mode status register (sstatus) for RV32.
</code></pre>
<pre><code>SXLEN-1 SXLEN-2 34 33 32 31 20 19 18 17
SD WPRI UXL WPRI MXR SUM WPRI
1 SXLEN-35 2 12 1 1 1
</code></pre>
<pre><code>16 15 14 13 12 9 8 7 6 5 4 3 2 1 0
XS[1:0] FS[1:0] WPRI SPP WPRI SPIE UPIE WPRI SIE UIE
2 2 4 1 2 1 1 2 1 1
</code></pre>
<pre><code>Figure 4.2: Supervisor-mode status register (sstatus) for RV64.
</code></pre>
<p>privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP
is then set to 0.</p>
<p>The SIE bit enables or disables all interrupts in supervisor mode. When SIE is clear, interrupts
are not taken while in supervisor mode. When the hart is running in user-mode, the value in
SIE is ignored, and supervisor-level interrupts are enabled. The supervisor can disable individual
interrupt sources using thesieCSR.</p>
<p>The SPIE bit indicates whether supervisor interrupts were enabled prior to trapping into supervisor
mode. When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE is set to 0. When
an SRET instruction is executed, SIE is set to SPIE, then SPIE is set to 1.</p>
<p>The UIE bit enables or disables user-mode interrupts. User-level interrupts are enabled only if UIE
is set and the hart is running in user-mode. The UPIE bit indicates whether user-level interrupts
were enabled prior to taking a user-level trap. When a URET instruction is executed, UIE is set
to UPIE, and UPIE is set to 1. User-level interrupts are optional. If omitted, the UIE and UPIE
bits are hardwired to zero.</p>
<pre><code>Thesstatusregister is a subset of themstatusregister. In a straightforward implementation,
reading or writing any field insstatusis equivalent to reading or writing the homonymous field
inmstatus.
</code></pre>
<h4 id="412-base-isa-control-insstatusregister"><a class="header" href="#412-base-isa-control-insstatusregister">4.1.2 Base ISA Control insstatusRegister</a></h4>
<p>The UXL field controls the value of XLEN for U-mode, termedUXLEN, which may differ from the
value of XLEN for S-mode, termedSXLEN. The encoding of UXL is the same as that of the MXL
field ofmisa, shown in Table 3.1.</p>
<p>For RV32 systems, the UXL field does not exist, and UXLEN=32. For RV64 systems, it is a
WARLfield that encodes the current value of UXLEN. In particular, the implementation may
hardwire UXL so that UXLEN=SXLEN.</p>
<p>If UXLENÃ∏= SXLEN, instructions executed in the narrower mode must ignore source register
operand bits above the configured XLEN, and must sign-extend results to fill the widest supported
XLEN in the destination register.</p>
<p>If UXLEN&lt;SXLEN, user-mode instruction-fetch addresses and load and store effective addresses
are taken modulo 2UXLEN. For example, when UXLEN=32 and SXLEN=64, user-mode memory
accesses reference the lowest 4 GiB of the address space.</p>
<h4 id="413-memory-privilege-insstatusregister"><a class="header" href="#413-memory-privilege-insstatusregister">4.1.3 Memory Privilege insstatusRegister</a></h4>
<p>The MXR (Make eXecutable Readable) bit modifies the privilege with which loads access virtual
memory. When MXR=0, only loads from pages marked readable (R=1 in Figure 4.15) will succeed.
When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed.
MXR has no effect when page-based virtual memory is not in effect.</p>
<p>The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode
loads and stores access virtual memory. When SUM=0, S-mode memory accesses to pages that are
accessible by U-mode (U=1 in Figure 4.15) will fault. When SUM=1, these accesses are permitted.
SUM has no effect when page-based virtual memory is not in effect, nor when executing in U-mode.
Note that S-mode can never execute instructions from user pages, regardless of the state of SUM.</p>
<pre><code>The SUM mechanism prevents supervisor software from inadvertently accessing user memory.
Operating systems can execute the majority of code with SUM clear; the few code segments that
should access user memory can temporarily set SUM.
The SUM mechanism does not avail S-mode software of permission to execute instructions
in user code pages. Legitimate uses cases for execution from user memory in supervisor context
are rare in general and nonexistent in POSIX environments. However, bugs in supervisors that
lead to arbitrary code execution are much easier to exploit if the supervisor exploit code can be
stored in a user buffer at a virtual address chosen by an attacker.
Some non-POSIX single address space operating systems do allow certain privileged software
to partially execute in supervisor mode, while most programs run in user mode, all in a shared
address space. This use case can be realized by mapping the physical code pages at multiple
virtual addresses with different permissions, possibly with the assistance of the instruction page-
fault handler to direct supervisor software to use the alternate mapping.
</code></pre>
<h4 id="414-supervisor-trap-vector-base-address-register-stvec"><a class="header" href="#414-supervisor-trap-vector-base-address-register-stvec">4.1.4 Supervisor Trap Vector Base Address Register (stvec)</a></h4>
<p>Thestvecregister is an SXLEN-bit read/write register that holds trap vector configuration, con-
sisting of a vector base address (BASE) and a vector mode (MODE).</p>
<pre><code>SXLEN-1 2 1 0
BASE[SXLEN-1:2] (WARL) MODE (WARL)
SXLEN-2 2
</code></pre>
<pre><code>Figure 4.3: Supervisor trap vector base address register (stvec).
</code></pre>
<p>The BASE field instvecis aWARLfield that can hold any valid virtual or physical address,
subject to the following alignment constraints: the address must be 4-byte aligned, and MODE</p>
<p>settings other than Direct might impose additional alignment constraints on the value in the BASE
field.</p>
<pre><code>Value Name Description
0 Direct All exceptions setpcto BASE.
1 Vectored Asynchronous interrupts setpcto BASE+4√ócause.
‚â• 2 ‚Äî Reserved
</code></pre>
<pre><code>Table 4.1: Encoding ofstvecMODE field.
</code></pre>
<p>The encoding of the MODE field is shown in Table 4.1. When MODE=Direct, all traps into
supervisor mode cause thepcto be set to the address in the BASE field. When MODE=Vectored,
all synchronous exceptions into supervisor mode cause thepcto be set to the address in the BASE
field, whereas interrupts cause thepcto be set to the address in the BASE field plus four times the
interrupt cause number. For example, a supervisor-mode timer interrupt (see Table 4.2) causes the
pcto be set to BASE+0x14. Setting MODE=Vectored may impose a stricter alignment constraint
on BASE.</p>
<pre><code>When vectored interrupts are enabled, interrupt cause 0, which corresponds to user-mode soft-
ware interrupts, are vectored to the same location as synchronous exceptions. This ambiguity
does not arise in practice for supervisor software, since user-mode software interrupts are either
disabled or delegated to user mode.
</code></pre>
<h4 id="415-supervisor-interrupt-registers-sipandsie"><a class="header" href="#415-supervisor-interrupt-registers-sipandsie">4.1.5 Supervisor Interrupt Registers (sipandsie)</a></h4>
<p>Thesipregister is an SXLEN-bit read/write register containing information on pending interrupts,
whilesieis the corresponding SXLEN-bit read/write register containing interrupt enable bits.</p>
<pre><code>SXLEN-1 10 9 8 7 6 5 4 3 2 1 0
WPRI SEIP UEIP WPRI STIP UTIP WPRI SSIP USIP
SXLEN-10 1 1 2 1 1 2 1 1
</code></pre>
<pre><code>Figure 4.4: Supervisor interrupt-pending register (sip).
</code></pre>
<pre><code>SXLEN-1 10 9 8 7 6 5 4 3 2 1 0
WPRI SEIE UEIE WPRI STIE UTIE WPRI SSIE USIE
SXLEN-10 1 1 2 1 1 2 1 1
</code></pre>
<pre><code>Figure 4.5: Supervisor interrupt-enable register (sie).
</code></pre>
<p>Three types of interrupts are defined: software interrupts, timer interrupts, and external interrupts.
A supervisor-level software interrupt is triggered on the current hart by writing 1 to its supervisor
software interrupt-pending (SSIP) bit in thesipregister. A pending supervisor-level software
interrupt can be cleared by writing 0 to the SSIP bit insip. Supervisor-level software interrupts
are disabled when the SSIE bit in thesieregister is clear.</p>
<p>Interprocessor interrupts are sent to other harts by implementation-specific means, which will
ultimately cause the SSIP bit to be set in the recipient hart‚Äôssipregister.</p>
<p>A user-level software interrupt is triggered on the current hart by writing 1 to its user software
interrupt-pending (USIP) bit in thesipregister. A pending user-level software interrupt can be
cleared by writing 0 to the USIP bit insip. User-level software interrupts are disabled when the
USIE bit in thesieregister is clear. If user-level interrupts are not supported, USIP and USIE are
hardwired to zero.</p>
<p>All bits besides SSIP, USIP, and UEIP in thesipregister are read-only.</p>
<p>A supervisor-level timer interrupt is pending if the STIP bit in thesipregister is set. Supervisor-
level timer interrupts are disabled when the STIE bit in thesieregister is clear. The implemen-
tation must provide a mechanism to clear a pending timer interrupt.</p>
<p>A user-level timer interrupt is pending if the UTIP bit in thesipregister is set. User-level timer
interrupts are disabled when the UTIE bit in thesieregister is clear. If user-level interrupts are
supported, the ABI should provide a facility for scheduling timer interrupts in terms of real-time
counter values. If user-level interrupts are not supported, UTIP and UTIE are hardwired to zero.</p>
<p>A supervisor-level external interrupt is pending if the SEIP bit in thesipregister is set. Supervisor-
level external interrupts are disabled when the SEIE bit in thesieregister is clear. The imple-
mentation should provide facilities to mask, unmask, and query the cause of external interrupts.</p>
<p>The UEIP field insipcontains a single read-write bit. UEIP may be written by S-mode software to
indicate to U-mode that an external interrupt is pending. Additionally, the platform-level interrupt
controller may generate user-level external interrupts. The logical-OR of the software-writable bit
and the signal from the external interrupt controller are used to generate external interrupts for
user mode. When the UEIP bit is read with a CSRRW, CSRRS, or CSRRC instruction, the value
returned in therddestination register contains the logical-OR of the software-writable bit and the
interrupt signal from the interrupt controller. However, the value used in the read-modify-write
sequence of a CSRRS or CSRRC instruction is only the software-writable UEIP bit, ignoring the
interrupt value from the external interrupt controller.</p>
<pre><code>Analogous to SEIP, the UEIP field behavior is designed to allow a higher privilege layer to mimic
external interrupts without losing any real external interrupts.
</code></pre>
<p>User-level external interrupts are disabled when the UEIE bit in thesieregister is clear. If the N
extension for user-level interrupts is not implemented, UEIP and UEIE are hardwired to zero.</p>
<pre><code>Thesipandsieregisters are subsets of themipandmieregisters. Reading any field, or writing
any writable field, ofsip/sieeffects a read or write of the homonymous field ofmip/mie.
Bits 3, 7, and 11 ofsipandsiecorrespond to the machine-mode software, timer, and
external interrupts, respectively. Since most platforms will choose not to make these interrupts
delegatable from M-mode to S-mode, they are markedWPRIin Figures 4.4 and 4.5.
</code></pre>
<h4 id="416-supervisor-timers-and-performance-counters"><a class="header" href="#416-supervisor-timers-and-performance-counters">4.1.6 Supervisor Timers and Performance Counters</a></h4>
<p>Supervisor software uses the same hardware performance monitoring facility as user-mode software,
including thetime,cycle, andinstretCSRs. The implementation should provide a mechanism
to modify the counter values.</p>
<p>The implementation must provide a facility for scheduling timer interrupts in terms of the real-time
counter,time.</p>
<h4 id="417-counter-enable-register-scounteren"><a class="header" href="#417-counter-enable-register-scounteren">4.1.7 Counter-Enable Register (scounteren)</a></h4>
<pre><code>31 30 29 28 6 5 4 3 2 1 0
HPM31 HPM30 HPM29 ... HPM5 HPM4 HPM3 IR TM CY
1 1 1 23 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 4.6: Counter-enable register (scounteren).
</code></pre>
<p>The counter-enable registerscounterenis a 32-bit register that controls the availability of the
hardware performance monitoring counters to U-mode.</p>
<p>When the CY, TM, IR, or HPMnbit in thescounterenregister is clear, attempts to read thecycle,
time,instret, orhpmcounternregister while executing in U-mode will cause an illegal instruction
exception. When one of these bits is set, access to the corresponding register is permitted.</p>
<p>scounterenmust be implemented. However, any of the bits may contain a hardwired value of zero,
indicating reads to the corresponding counter will cause an exception when executing in U-mode.
Hence, they are effectivelyWARLfields.</p>
<h4 id="418-supervisor-scratch-register-sscratch"><a class="header" href="#418-supervisor-scratch-register-sscratch">4.1.8 Supervisor Scratch Register (sscratch)</a></h4>
<p>Thesscratchregister is an SXLEN-bit read/write register, dedicated for use by the supervisor.
Typically,sscratchis used to hold a pointer to the hart-local supervisor context while the hart is
executing user code. At the beginning of a trap handler,sscratchis swapped with a user register
to provide an initial working register.</p>
<pre><code>SXLEN-1 0
sscratch
SXLEN
</code></pre>
<pre><code>Figure 4.7: Supervisor Scratch Register.
</code></pre>
<h4 id="419-supervisor-exception-program-counter-sepc"><a class="header" href="#419-supervisor-exception-program-counter-sepc">4.1.9 Supervisor Exception Program Counter (sepc)</a></h4>
<p>sepcis an SXLEN-bit read/write register formatted as shown in Figure 4.8. The low bit ofsepc
(sepc[0]) is always zero. On implementations that support only IALIGN=32, the two low bits
(sepc[1:0]) are always zero.</p>
<p>If an implementation allows IALIGN to be either 16 or 32 (by changing CSRmisa, for example),
then, whenever IALIGN=32, bitsepc[1]is masked on reads so that it appears to be 0. This
masking occurs also for the implicit read by the SRET instruction. Though masked,sepc[1]
remains writable when IALIGN=32.</p>
<p>sepcis aWARLregister that must be able to hold all valid physical and virtual addresses. It
need not be capable of holding all possible invalid addresses. Implementations may convert some
invalid address patterns into other invalid addresses prior to writing them tosepc.</p>
<p>When a trap is taken into S-mode,sepcis written with the virtual address of the instruction
that was interrupted or that encountered the exception. Otherwise,sepcis never written by the
implementation, though it may be explicitly written by software.</p>
<pre><code>SXLEN-1 0
sepc
SXLEN
</code></pre>
<pre><code>Figure 4.8: Supervisor exception program counter register.
</code></pre>
<h4 id="4110-supervisor-cause-register-scause"><a class="header" href="#4110-supervisor-cause-register-scause">4.1.10 Supervisor Cause Register (scause)</a></h4>
<p>Thescauseregister is an SXLEN-bit read-write register formatted as shown in Figure 4.9. When a
trap is taken into S-mode,scauseis written with a code indicating the event that caused the trap.
Otherwise,scauseis never written by the implementation, though it may be explicitly written by
software.</p>
<p>The Interrupt bit in thescauseregister is set if the trap was caused by an interrupt. The Exception
Code field contains a code identifying the last exception. Table 4.2 lists the possible exception codes
for the current supervisor ISAs. The Exception Code is aWLRLfield, so is only guaranteed to
hold supported exception codes.</p>
<pre><code>SXLEN-1 SXLEN-2 0
Interrupt Exception Code (WLRL)
1 SXLEN-1
</code></pre>
<pre><code>Figure 4.9: Supervisor Cause registerscause.
</code></pre>
<h4 id="4111-supervisor-trap-value-stval-register"><a class="header" href="#4111-supervisor-trap-value-stval-register">4.1.11 Supervisor Trap Value (stval) Register</a></h4>
<p>Thestvalregister is an SXLEN-bit read-write register formatted as shown in Figure 4.10. When
a trap is taken into S-mode,stvalis written with exception-specific information to assist software
in handling the trap. Otherwise,stvalis never written by the implementation, though it may
be explicitly written by software. The hardware platform will specify which exceptions must set
stvalinformatively and which may unconditionally set it to zero.</p>
<p>When a hardware breakpoint is triggered, or an instruction-fetch, load, or store address-misaligned,
access, or page-fault exception occurs,stvalis written with the faulting virtual address. On an
illegal instruction trap,stvalmay be written with the first XLEN or ILEN bits of the faulting
instruction as described below. For other exceptions,stvalis set to zero, but a future standard
may redefinestval‚Äôs setting for other exceptions.</p>
<p>For misaligned loads and stores that cause access or page-fault exceptions,stvalwill contain the
virtual address of the portion of the access that caused the fault. For instruction-fetch access or</p>
<pre><code>Interrupt Exception Code Description
1 0 User software interrupt
1 1 Supervisor software interrupt
1 2‚Äì3 Reserved for future standard use
1 4 User timer interrupt
1 5 Supervisor timer interrupt
1 6‚Äì7 Reserved for future standard use
1 8 User external interrupt
1 9 Supervisor external interrupt
1 10‚Äì15 Reserved for future standard use
1 ‚â• 16 Reserved for platform use
0 0 Instruction address misaligned
0 1 Instruction access fault
0 2 Illegal instruction
0 3 Breakpoint
0 4 Load address misaligned
0 5 Load access fault
0 6 Store/AMO address misaligned
0 7 Store/AMO access fault
0 8 Environment call from U-mode
0 9 Environment call from S-mode
0 10‚Äì11 Reserved for future standard use
0 12 Instruction page fault
0 13 Load page fault
0 14 Reserved for future standard use
0 15 Store/AMO page fault
0 16‚Äì23 Reserved for future standard use
0 24‚Äì31 Reserved for custom use
0 32‚Äì47 Reserved for future standard use
0 48‚Äì63 Reserved for custom use
0 ‚â• 64 Reserved for future standard use
</code></pre>
<p>Table 4.2: Supervisor cause register (scause) values after trap. Synchronous exception priorities
are given by Table 3.7.</p>
<pre><code>SXLEN-1 0
stval
SXLEN
</code></pre>
<pre><code>Figure 4.10: Supervisor Trap Value register.
</code></pre>
<p>page-fault exceptions on systems with variable-length instructions,stvalwill contain the virtual
address of the portion of the instruction that caused the fault whilesepcwill point to the beginning
of the instruction.</p>
<p>Thestvalregister can optionally also be used to return the faulting instruction bits on an illegal
instruction exception (sepcpoints to the faulting instruction in memory).</p>
<p>If this feature is not provided, thenstvalis set to zero on an illegal instruction fault.</p>
<p>If this feature is provided, after an illegal instruction trap,stvalwill contain the shortest of:</p>
<ul>
<li>the actual faulting instruction</li>
<li>the first ILEN bits of the faulting instruction</li>
<li>the first XLEN bits of the faulting instruction</li>
</ul>
<p>The value loaded intostvalis right-justified and all unused upper bits are cleared to zero.</p>
<p>stvalis aWARLregister that must be able to hold all valid physical and virtual addresses and
the value 0. It need not be capable of holding all possible invalid addresses. Implementations may
convert some invalid address patterns into other invalid addresses prior to writing them tostval.
If the feature to return the faulting instruction bits is implemented,stvalmust also be able to
hold all values less than 2N, whereNis the smaller of XLEN and ILEN.</p>
<h4 id="4112-supervisor-address-translation-and-protection-satp-register"><a class="header" href="#4112-supervisor-address-translation-and-protection-satp-register">4.1.12 Supervisor Address Translation and Protection (satp) Register</a></h4>
<p>Thesatpregister is an SXLEN-bit read/write register, formatted as shown in Figure 4.11 for
SXLEN=32 and Figure 4.12 for SXLEN=64, which controls supervisor-mode address translation
and protection. This register holds the physical page number (PPN) of the root page table, i.e., its
supervisor physical address divided by 4 KiB; an address space identifier (ASID), which facilitates
address-translation fences on a per-address-space basis; and the MODE field, which selects the
current address-translation scheme. Further details on the access to this register are described in
Section 3.1.6.4.</p>
<pre><code>31 30 22 21 0
MODE(WARL) ASID(WARL) PPN(WARL)
1 9 22
</code></pre>
<pre><code>Figure 4.11: RV32 Supervisor address translation and protection registersatp.
</code></pre>
<pre><code>Storing a PPN insatp, rather than a physical address, supports a physical address space larger
than 4 GiB for RV32.
63 60 59 44 43 0
MODE(WARL) ASID(WARL) PPN(WARL)
4 16 44
</code></pre>
<p>Figure 4.12: RV64 Supervisor address translation and protection registersatp, for MODE values
Bare, Sv39, and Sv48.</p>
<pre><code>We store the ASID and the page table base address in the same CSR to allow the pair to be
changed atomically on a context switch. Swapping them non-atomically could pollute the old
virtual address space with new translations, or vice-versa. This approach also slightly reduces
the cost of a context switch.
</code></pre>
<p>Table 4.3 shows the encodings of the MODE field for RV32 and RV64. When MODE=Bare,
supervisor virtual addresses are equal to supervisor physical addresses, and there is no additional</p>
<p>memory protection beyond the physical memory protection scheme described in Section 3.6. In
this case, the remaining fields insatphave no effect.</p>
<p>For RV32, the only other valid setting for MODE is Sv32, a paged virtual-memory scheme described
in Section 4.3.</p>
<p>For RV64, two paged virtual-memory schemes are defined: Sv39 and Sv48, described in Sections 4.4
and 4.5, respectively. Two additional schemes, Sv57 and Sv64, will be defined in a later version
of this specification. The remaining MODE settings are reserved for future use and may define
different interpretations of the other fields insatp.</p>
<p>Implementations are not required to support all MODE settings, and ifsatpis written with an
unsupported MODE, the entire write has no effect; no fields insatpare modified.</p>
<pre><code>RV32
Value Name Description
0 Bare No translation or protection.
1 Sv32 Page-based 32-bit virtual addressing (see Section 4.3).
RV64
Value Name Description
0 Bare No translation or protection.
1‚Äì7 ‚Äî Reserved
8 Sv39 Page-based 39-bit virtual addressing (see Section 4.4).
9 Sv48 Page-based 48-bit virtual addressing (see Section 4.5).
10 Sv57 Reserved for page-based 57-bit virtual addressing.
11 Sv64 Reserved for page-based 64-bit virtual addressing.
12‚Äì15 ‚Äî Reserved
</code></pre>
<pre><code>Table 4.3: Encoding ofsatpMODE field.
</code></pre>
<p>The number of supervisor physical address bits is implementation-defined; any unimplemented
address bits are hardwired to zero in the satp register. The number of ASID bits is also
implementation-defined and may be zero. The number of implemented ASID bits, termed
ASIDLEN, may be determined by writing one to every bit position in the ASID field, then reading
back the value insatpto see which bit positions in the ASID field hold a one. The least-significant
bits of ASID are implemented first: that is, if ASIDLEN&gt;0, ASID[ASIDLEN-1:0] is writable.
The maximal value of ASIDLEN, termed ASIDMAX, is 9 for Sv32 or 16 for Sv39 and Sv48.</p>
<pre><code>For many applications, the choice of page size has a substantial performance impact. A large
page size increases TLB reach and loosens the associativity constraints on virtually-indexed,
physically-tagged caches. At the same time, large pages exacerbate internal fragmentation, wast-
ing physical memory and possibly cache capacity.
After much deliberation, we have settled on a conventional page size of 4 KiB for both RV32
and RV64. We expect this decision to ease the porting of low-level runtime software and device
drivers. The TLB reach problem is ameliorated by transparent superpage support in modern
operating systems [2]. Additionally, multi-level TLB hierarchies are quite inexpensive relative to
the multi-level cache hierarchies whose address space they map.
</code></pre>
<p>Note that writingsatpdoes not imply any ordering constraints between page-table updates and
subsequent address translations. If the new address space‚Äôs page tables have been modified, or if an</p>
<p>ASID is reused, it may be necessary to execute an SFENCE.VMA instruction (see Section 4.2.1)
after writingsatp.</p>
<pre><code>Not imposing upon implementations to flush address-translation caches uponsatpwrites reduces
the cost of context switches, provided a sufficiently large ASID space.
</code></pre>
<h3 id="42-supervisor-instructions"><a class="header" href="#42-supervisor-instructions">4.2 Supervisor Instructions</a></h3>
<p>In addition to the SRET instruction defined in Section 3.2.2, one new supervisor-level instruction
is provided.</p>
<h4 id="421-supervisor-memory-management-fence-instruction"><a class="header" href="#421-supervisor-memory-management-fence-instruction">4.2.1 Supervisor Memory-Management Fence Instruction</a></h4>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
funct7 rs2 rs1 funct3 rd opcode
7 5 5 3 5 7
SFENCE.VMA asid vaddr PRIV 0 SYSTEM
</code></pre>
<p>The supervisor memory-management fence instruction SFENCE.VMA is used to synchronize up-
dates to in-memory memory-management data structures with current execution. Instruction exe-
cution causes implicit reads and writes to these data structures; however, these implicit references
are ordinarily not ordered with respect to explicit loads and stores. Executing an SFENCE.VMA
instruction guarantees that any previous stores already visible to the current RISC-V hart are
ordered before all subsequent implicit references from that hart to the memory-management data
structures. Further details on the behavior of this instruction are described in Section 3.1.6.4 and
Section 3.6.2.</p>
<pre><code>The SFENCE.VMA is used to flush any local hardware caches related to address translation.
It is specified as a fence rather than a TLB flush to provide cleaner semantics with respect to
which instructions are affected by the flush operation and to support a wider variety of dynamic
caching structures and memory-management schemes. SFENCE.VMA is also used by higher
privilege levels to synchronize page table writes and the address translation hardware.
</code></pre>
<p>SFENCE.VMA orders only the local hart‚Äôs implicit references to the memory-management data
structures.</p>
<pre><code>Consequently, other harts must be notified separately when the memory-management data struc-
tures have been modified. One approach is to use 1) a local data fence to ensure local writes
are visible globally, then 2) an interprocessor interrupt to the other thread, then 3) a local
SFENCE.VMA in the interrupt handler of the remote thread, and finally 4) signal back to orig-
inating thread that operation is complete. This is, of course, the RISC-V analog to a TLB
shootdown.
</code></pre>
<p>For the common case that the translation data structures have only been modified for a single
address mapping (i.e., one page or superpage),rs1can specify a virtual address within that mapping
to effect a translation fence for that mapping only. Furthermore, for the common case that the
translation data structures have only been modified for a single address-space identifier,rs2can
specify the address space. The behavior of SFENCE.VMA depends onrs1andrs2as follows:</p>
<ul>
<li>Ifrs1=x0andrs2=x0, the fence orders all reads and writes made to any level of the page
tables, for all address spaces.</li>
<li>Ifrs1=x0andrs2Ã∏=x0, the fence orders all reads and writes made to any level of the page
tables, but only for the address space identified by integer registerrs2. Accesses toglobal
mappings (see Section 4.3.1) are not ordered.</li>
<li>Ifrs1Ã∏=x0andrs2=x0, the fence orders only reads and writes made to the leaf page table
entry corresponding to the virtual address inrs1, for all address spaces.</li>
<li>Ifrs1Ã∏=x0andrs2Ã∏=x0, the fence orders only reads and writes made to the leaf page table
entry corresponding to the virtual address inrs1, for the address space identified by integer
registerrs2. Accesses to global mappings are not ordered.</li>
</ul>
<p>Whenrs2Ã∏=x0, bits SXLEN-1:ASIDMAX of the value held inrs2are reserved for future use and
should be zeroed by software and ignored by current implementations. Furthermore, if ASI-
DLEN&lt;ASIDMAX, the implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value
held inrs2.</p>
<pre><code>Simpler implementations can ignore the virtual address inrs1and the ASID value inrs2and
always perform a global fence.
</code></pre>
<p>Implementations may perform implicit reads of the translation data structures pointed to by the
currentsatpregister arbitrarily early and speculatively. The results of these reads may be held in
an incoherent cache but not shared with other harts. Cache entries may only be established for
the ASID currently loaded into thesatpregister, or for global entries. The cache may only satisfy
implicit reads for entries that have been established for the ASID currently loaded intosatp, or for
global entries. Changes in thesatpregister do not necessarily flush any such translation caches.
To ensure the implicit reads observe writes to the same memory locations, an SFENCE.VMA
instruction must be executed after the writes to flush the relevant cached translations.</p>
<p>Implementations must only perform implicit reads of the translation data structures pointed to by
the current contents of the satp register, and must only raise exceptions for implicit accesses that
are generated as a result of instruction execution, not those that are performed speculatively.</p>
<pre><code>The following common situations typically require executing an SFENCE.VMA instruction:
</code></pre>
<ul>
<li>
<p>When software recycles an ASID (i.e., reassociates it with a different page table), it should
firstchangesatpto point to the new page table using the recycled ASID,thenexecute
SFENCE.VMA withrs1=x0andrs2set to the recycled ASID. Alternatively, software can
execute the same SFENCE.VMA instruction while a different ASID is loaded intosatp,
provided the next timesatpis loaded with the recycled ASID, it is simultaneously loaded
with the new page table.</p>
</li>
<li>
<p>If the implementation does not provide ASIDs, or software chooses to always use ASID 0,
then after everysatpwrite, software should execute SFENCE.VMA withrs1=x0. In the
common case that no global translations have been modified,rs2should be set to a register
other thanx0but which contains the value zero, so that global translations are not flushed.</p>
</li>
<li>
<p>If software modifies a non-leaf PTE, it should execute SFENCE.VMA withrs1=x0. If any
PTE along the traversal path had its G bit set,rs2must bex0; otherwise,rs2should be set
to the ASID for which the translation is being modified.</p>
</li>
<li>
<p>If software modifies a leaf PTE, it should execute SFENCE.VMA withrs1set to a virtual
address within the page. If any PTE along the traversal path had its G bit set,rs2must
bex0; otherwise,rs2should be set to the ASID for which the translation is being modified.</p>
</li>
<li>
<p>For the special cases of increasing the permissions on a leaf PTE and changing an invalid
PTE to a valid leaf, software may choose to execute the SFENCE.VMA lazily. After
modifying the PTE but before executing SFENCE.VMA, either the new or old permissions
will be used. In the latter case, a page fault exception might occur, at which point software
should execute SFENCE.VMA in accordance with the previous bullet point.</p>
</li>
</ul>
<p>For forward compatibility with future versions of this specification, supervisor software should
adhere to the following constraints on ASID usage. Supervisor software that uses ASIDs should
use a nonzero ASID value to refer to the same address space across all harts in the SEE and should
not use an ASID value of 0. Supervisor software that does not use ASIDs should always set the
ASID field in thesatpCSR to 0.</p>
<pre><code>A future extension may define ASIDs to be global across the SEE, facilitating such optimizations
as multicast TLB shootdown and sharing translation caches between harts.
The extension will provide a mechanism so that existing supervisor software that always uses
ASID 0 will continue to function as it currently does.
</code></pre>
<h3 id="43-sv32-page-based-32-bit-virtual-memory-systems"><a class="header" href="#43-sv32-page-based-32-bit-virtual-memory-systems">4.3 Sv32: Page-Based 32-bit Virtual-Memory Systems</a></h3>
<p>When Sv32 is written to the MODE field in thesatpregister (see Section 4.1.12), the supervisor
operates in a 32-bit paged virtual-memory system. In this mode, supervisor and user virtual
addresses are translated into supervisor physical addresses by traversing a radix-tree page table.
Sv32 is supported on RV32 systems and is designed to include mechanisms sufficient for supporting
modern Unix-based operating systems.</p>
<pre><code>The initial RISC-V paged virtual-memory architectures have been designed as straightforward
implementations to support existing operating systems. We have architected page table layouts
to support a hardware page-table walker. Software TLB refills are a performance bottleneck on
high-performance systems, and are especially troublesome with decoupled specialized coprocessors.
An implementation can choose to implement software TLB refills using a machine-mode trap
handler as an extension to M-mode.
</code></pre>
<h4 id="431-addressing-and-memory-protection"><a class="header" href="#431-addressing-and-memory-protection">4.3.1 Addressing and Memory Protection</a></h4>
<p>Sv32 implementations support a 32-bit virtual address space, divided into 4 KiB pages. An Sv32
virtual address is partitioned into a virtual page number (VPN) and page offset, as shown in
Figure 4.13. When Sv32 virtual memory mode is selected in the MODE field of thesatpregister,
supervisor virtual addresses are translated into supervisor physical addresses via a two-level page
table. The 20-bit VPN is translated into a 22-bit physical page number (PPN), while the 12-
bit page offset is untranslated. The resulting supervisor-level physical addresses are then checked
using any physical memory protection structures (Sections 3.6), before being directly converted to
machine-level physical addresses.</p>
<pre><code>31 22 21 12 11 0
VPN[1] VPN[0] page offset
10 10 12
</code></pre>
<pre><code>Figure 4.13: Sv32 virtual address.
</code></pre>
<pre><code>33 22 21 12 11 0
PPN[1] PPN[0] page offset
12 10 12
</code></pre>
<pre><code>Figure 4.14: Sv32 physical address.
</code></pre>
<pre><code>31 20 19 10 9 8 7 6 5 4 3 2 1 0
PPN[1] PPN[0] RSW D A G U X W R V
12 10 2 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 4.15: Sv32 page table entry.
</code></pre>
<p>Sv32 page tables consist of 2^10 page-table entries (PTEs), each of four bytes. A page table is exactly
the size of a page and must always be aligned to a page boundary. The physical page number of
the root page table is stored in thesatpregister.</p>
<p>The PTE format for Sv32 is shown in Figures 4.15. The V bit indicates whether the PTE is valid; if
it is 0, all other bits in the PTE are don‚Äôt-cares and may be used freely by software. The permission
bits, R, W, and X, indicate whether the page is readable, writable, and executable, respectively.
When all three are zero, the PTE is a pointer to the next level of the page table; otherwise, it is
a leaf PTE. Writable pages must also be marked readable; the contrary combinations are reserved
for future use. Table 4.4 summarizes the encoding of the permission bits.</p>
<pre><code>X W R Meaning
0 0 0 Pointer to next level of page table.
0 0 1 Read-only page.
0 1 0 Reserved for future use.
0 1 1 Read-write page.
1 0 0 Execute-only page.
1 0 1 Read-execute page.
1 1 0 Reserved for future use.
1 1 1 Read-write-execute page.
</code></pre>
<pre><code>Table 4.4: Encoding of PTE R/W/X fields.
</code></pre>
<p>Attempting to fetch an instruction from a page that does not have execute permissions raises a
fetch page-fault exception. Attempting to execute a load or load-reserved instruction whose effective
address lies within a page without read permissions raises a load page-fault exception. Attempting
to execute a store, store-conditional (regardless of success), or AMO instruction whose effective
address lies within a page without write permissions raises a store page-fault exception.</p>
<pre><code>AMOs never raise load page-fault exceptions. Since any unreadable page is also unwritable,
attempting to perform an AMO on an unreadable page always raises a store page-fault exception.
</code></pre>
<p>The U bit indicates whether the page is accessible to user mode. U-mode software may only access
the page when U=1. If the SUM bit in thesstatusregister is set, supervisor mode software may
also access pages with U=1. However, supervisor code normally operates with the SUM bit clear,
in which case, supervisor code will fault on accesses to user-mode pages. Irrespective of SUM, the
supervisor may not execute code on pages with U=1.</p>
<pre><code>An alternative PTE format would support different permissions for supervisor and user. We
omitted this feature because it would be largely redundant with the SUM mechanism (see Sec-
tion 4.1.3) and would require more encoding space in the PTE.
</code></pre>
<p>The G bit designates aglobalmapping. Global mappings are those that exist in all address spaces.
For non-leaf PTEs, the global setting implies that all mappings in the subsequent levels of the page
table are global. Note that failing to mark a global mapping as global merely reduces performance,
whereas marking a non-global mapping as global is a software bug that, after switching to an
address space with a different non-global mapping for that address range, can unpredictably result
in either mapping being used.</p>
<pre><code>Global mappings need not be stored redundantly in address-translation caches for multiple
ASIDs. Additionally, they need not be flushed from local address-translation caches when an
SFENCE.VMA instruction is executed withrs2Ã∏=x0.
</code></pre>
<p>The RSW field is reserved for use by supervisor software; the implementation shall ignore this field.</p>
<p>Each leaf PTE contains an accessed (A) and dirty (D) bit. The A bit indicates the virtual page has
been read, written, or fetched from since the last time the A bit was cleared. The D bit indicates
the virtual page has been written since the last time the D bit was cleared.</p>
<p>Two schemes to manage the A and D bits are permitted:</p>
<ul>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a
page-fault exception is raised.</li>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the
implementation sets the corresponding bit(s) in the PTE. The PTE update must be atomic
with respect to other accesses to the PTE, and must atomically check that the PTE is valid
and grants sufficient permissions. The PTE update must be exact (i.e., not speculative), and
observed in program order by the local hart. Furthermore, the PTE update must appear
in the global memory order no later than the explicit memory access, or any subsequent
explicit memory access to that virtual page by the local hart. The ordering on loads and
stores provided by FENCE instructions and the acquire/release bits on atomic instructions
also orders the PTE updates associated with those loads and stores as observed by remote
harts.
The PTE update is not required to be atomic with respect to the explicit memory access that
caused the update, and the sequence is interruptible. However, the hart must not perform
the explicit memory access before the PTE update is globally visible.</li>
</ul>
<p>All harts in a system must employ the same PTE-update scheme as each other.</p>
<pre><code>Mandating that the PTE updates to be exact, atomic, and in program order simplifies the spec-
ification, and makes the feature more useful for system software. Simple implementations may
instead generate page-fault exceptions.
The A and D bits are never cleared by the implementation. If the supervisor software does
not rely on accessed and/or dirty bits, e.g. if it does not swap memory pages to secondary storage
or if the pages are being used to map I/O space, it should always set them to 1 in the PTE to
improve performance.
</code></pre>
<p>Any level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv32 supports 4 MiBmegapages.
A megapage must be virtually and physically aligned to a 4 MiB boundary; a page-fault exception
is raised if the physical address is insufficiently aligned.</p>
<p>For non-leaf PTEs, the D, A, and U bits are reserved for future use and must be cleared by software
for forward compatibility.</p>
<h4 id="432-virtual-address-translation-process"><a class="header" href="#432-virtual-address-translation-process">4.3.2 Virtual Address Translation Process</a></h4>
<p>A virtual addressvais translated into a physical addresspaas follows:</p>
<ol>
<li>Letabesatp.ppn√óPAGESIZE, and leti= LEVELS‚àí1. (For Sv32, PAGESIZE=2^12 and
LEVELS=2.)</li>
<li>Letptebe the value of the PTE at addressa+va.vpn[i]√óPTESIZE. (For Sv32, PTESIZE=4.)
If accessingpteviolates a PMA or PMP check, raise an access exception corresponding to
the original access type.</li>
<li>Ifpte.v= 0, or ifpte.r= 0 andpte.w= 1, stop and raise a page-fault exception corresponding
to the original access type.</li>
<li>Otherwise, the PTE is valid. Ifpte.r= 1 orpte.x= 1, go to step 5. Otherwise, this PTE is a
pointer to the next level of the page table. Leti=i‚àí1. Ifi &lt;0, stop and raise a page-fault
exception corresponding to the original access type. Otherwise, leta=pte.ppn√óPAGESIZE
and go to step 2.</li>
<li>A leaf PTE has been found. Determine if the requested memory access is allowed by the
pte.r,pte.w,pte.x, andpte.ubits, given the current privilege mode and the value of the
SUM and MXR fields of themstatusregister. If not, stop and raise a page-fault exception
corresponding to the original access type.</li>
<li>Ifi &gt;0 andpte.ppn[i‚àí1 : 0]Ã∏= 0, this is a misaligned superpage; stop and raise a page-fault
exception corresponding to the original access type.</li>
<li>If pte.a= 0, or if the memory access is a store and pte.d = 0, either raise a page-fault
exception corresponding to the original access type, or:
- Setpte.ato 1 and, if the memory access is a store, also setpte.dto 1.
- If this access violates a PMA or PMP check, raise an access exception corresponding to
the original access type.</li>
</ol>
<ul>
<li>This update and the loading ofptein step 2 must be atomic; in particular, no intervening
store to the PTE may be perceived to have occurred in-between.</li>
</ul>
<ol start="8">
<li>The translation is successful. The translated physical address is given as follows:</li>
</ol>
<ul>
<li>pa.pgoff=va.pgoff.</li>
<li>Ifi &gt;0, then this is a superpage translation andpa.ppn[i‚àí1 : 0] =va.vpn[i‚àí1 : 0].</li>
<li>pa.ppn[LEVELS‚àí1 :i] =pte.ppn[LEVELS‚àí1 :i].</li>
</ul>
<h3 id="44-sv39-page-based-39-bit-virtual-memory-system"><a class="header" href="#44-sv39-page-based-39-bit-virtual-memory-system">4.4 Sv39: Page-Based 39-bit Virtual-Memory System</a></h3>
<p>This section describes a simple paged virtual-memory system designed for RV64 systems, which
supports 39-bit virtual address spaces. The design of Sv39 follows the overall scheme of Sv32, and
this section details only the differences between the schemes.</p>
<pre><code>We specified multiple virtual memory systems for RV64 to relieve the tension between providing
a large address space and minimizing address-translation cost. For many systems, 512 GiB of
virtual-address space is ample, and so Sv39 suffices. Sv48 increases the virtual address space
to 256 TiB, but increases the physical memory capacity dedicated to page tables, the latency of
page-table traversals, and the size of hardware structures that store virtual addresses.
</code></pre>
<h4 id="441-addressing-and-memory-protection"><a class="header" href="#441-addressing-and-memory-protection">4.4.1 Addressing and Memory Protection</a></h4>
<p>Sv39 implementations support a 39-bit virtual address space, divided into 4 KiB pages. An Sv39
address is partitioned as shown in Figure 4.16. Instruction fetch addresses and load and store
effective addresses, which are 64 bits, must have bits 63‚Äì39 all equal to bit 38, or else a page-fault
exception will occur. The 27-bit VPN is translated into a 44-bit PPN via a three-level page table,
while the 12-bit page offset is untranslated.</p>
<pre><code>When mapping between narrower and wider addresses, RISC-V usually zero-extends a narrower
address to a wider size. The mapping between 64-bit virtual addresses and the 39-bit usable
address space of Sv39 is not based on zero-extension but instead follows an entrenched convention
that allows an OS to use one or a few of the most-significant bits of a full-size (64-bit) virtual
address to quickly distinguish user and supervisor address regions.
38 30 29 21 20 12 11 0
VPN[2] VPN[1] VPN[0] page offset
9 9 9 12
</code></pre>
<pre><code>Figure 4.16: Sv39 virtual address.
</code></pre>
<pre><code>55 30 29 21 20 12 11 0
PPN[2] PPN[1] PPN[0] page offset
26 9 9 12
</code></pre>
<pre><code>Figure 4.17: Sv39 physical address.
</code></pre>
<pre><code>63 54 53 28 27 19 18 10 9 8 7 6 5 4 3 2 1 0
Reserved PPN[2] PPN[1] PPN[0] RSW D A G U X W R V
10 26 9 9 2 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 4.18: Sv39 page table entry.
</code></pre>
<p>Sv39 page tables contain 2^9 page table entries (PTEs), eight bytes each. A page table is exactly
the size of a page and must always be aligned to a page boundary. The physical page number of
the root page table is stored in thesatpregister‚Äôs PPN field.</p>
<p>The PTE format for Sv39 is shown in Figure 4.18. Bits 9‚Äì0 have the same meaning as for Sv32.
Bits 63‚Äì54 are reserved for future use and must be zeroed by software for forward compatibility.</p>
<pre><code>We reserved several PTE bits for a possible extension that improves support for sparse address
spaces by allowing page-table levels to be skipped, reducing memory usage and TLB refill latency.
These reserved bits may also be used to facilitate research experimentation. The cost is reducing
the physical address space, but 64 PiB is presently ample. When it no longer suffices, the reserved
bits that remain unallocated could be used to expand the physical address space.
</code></pre>
<p>Any level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv39 supports 2 MiBmegapages
and 1 GiBgigapages, each of which must be virtually and physically aligned to a boundary equal
to its size. A page-fault exception is raised if the physical address is insufficiently aligned.</p>
<p>The algorithm for virtual-to-physical address translation is the same as in Section 4.3.2, except
LEVELS equals 3 and PTESIZE equals 8.</p>
<h3 id="45-sv48-page-based-48-bit-virtual-memory-system"><a class="header" href="#45-sv48-page-based-48-bit-virtual-memory-system">4.5 Sv48: Page-Based 48-bit Virtual-Memory System</a></h3>
<p>This section describes a simple paged virtual-memory system designed for RV64 systems, which
supports 48-bit virtual address spaces. Sv48 is intended for systems for which a 39-bit virtual
address space is insufficient. It closely follows the design of Sv39, simply adding an additional level
of page table, and so this chapter only details the differences between the two schemes.</p>
<p>Implementations that support Sv48 must also support Sv39.</p>
<pre><code>Systems that support Sv48 can also support Sv39 at essentially no cost, and so should do so to
maintain compatibility with supervisor software that assumes Sv39.
</code></pre>
<h4 id="451-addressing-and-memory-protection"><a class="header" href="#451-addressing-and-memory-protection">4.5.1 Addressing and Memory Protection</a></h4>
<p>Sv48 implementations support a 48-bit virtual address space, divided into 4 KiB pages. An Sv48
address is partitioned as shown in Figure 4.19. Instruction fetch addresses and load and store
effective addresses, which are 64 bits, must have bits 63‚Äì48 all equal to bit 47, or else a page-fault
exception will occur. The 36-bit VPN is translated into a 44-bit PPN via a four-level page table,
while the 12-bit page offset is untranslated.</p>
<p>The PTE format for Sv48 is shown in Figure 4.21. Bits 9‚Äì0 have the same meaning as for Sv32. Any
level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv48 supports 2 MiBmegapages,</p>
<pre><code>47 39 38 30 29 21 20 12 11 0
VPN[3] VPN[2] VPN[1] VPN[0] page offset
9 9 9 9 12
</code></pre>
<pre><code>Figure 4.19: Sv48 virtual address.
</code></pre>
<pre><code>55 39 38 30 29 21 20 12 11 0
PPN[3] PPN[2] PPN[1] PPN[0] page offset
17 9 9 9 12
</code></pre>
<pre><code>Figure 4.20: Sv48 physical address.
</code></pre>
<pre><code>63 54 53 37 36 28 27 19 18 10 9 8 7 6 5 4 3 2 1 0
Reserved PPN[3] PPN[2] PPN[1] PPN[0] RSW D A G U X W R V
10 17 9 9 9 2 1 1 1 1 1 1 1 1
</code></pre>
<pre><code>Figure 4.21: Sv48 page table entry.
</code></pre>
<p>1 GiBgigapages, and 512 GiBterapages, each of which must be virtually and physically aligned to
a boundary equal to its size. A page-fault exception is raised if the physical address is insufficiently
aligned.</p>
<p>The algorithm for virtual-to-physical address translation is the same as in Section 4.3.2, except
LEVELS equals 4 and PTESIZE equals 8.</p>
<h2 id="chapter-5"><a class="header" href="#chapter-5">Chapter 5</a></h2>
<h1 id="risc-v-privileged-instruction-set"><a class="header" href="#risc-v-privileged-instruction-set">RISC-V Privileged Instruction Set</a></h1>
<h1 id="listings"><a class="header" href="#listings">Listings</a></h1>
<p>This chapter presents instruction-set listings for all instructions defined in the RISC-V Privileged
Architecture.</p>
<p>The instruction-set listings for unprivileged instructions, including the ECALL and EBREAK in-
structions, are provided in Volume I of this manual.</p>
<h6 id="75"><a class="header" href="#75">75</a></h6>
<p>31 27 26 25 24 20 19 15 14 12 11 7 6 0
funct7 rs2 rs1 funct3 rd opcode R-type
imm[11:0] rs1 funct3 rd opcode I-type</p>
<pre><code>Trap-Return Instructions
0000000 00010 00000 000 00000 1110011 URET
0001000 00010 00000 000 00000 1110011 SRET
0011000 00010 00000 000 00000 1110011 MRET
</code></pre>
<pre><code>Interrupt-Management Instructions
0001000 00101 00000 000 00000 1110011 WFI
</code></pre>
<pre><code>Supervisor Memory-Management Instructions
0001001 rs2 rs1 000 00000 1110011 SFENCE.VMA
</code></pre>
<pre><code>Hypervisor Memory-Management Instructions
0010001 rs2 rs1 000 00000 1110011 HFENCE.BVMA
1010001 rs2 rs1 000 00000 1110011 HFENCE.GVMA
</code></pre>
<pre><code>Table 5.1: RISC-V Privileged Instructions
</code></pre>
<h2 id="chapter-6"><a class="header" href="#chapter-6">Chapter 6</a></h2>
<h1 id="history"><a class="header" href="#history">History</a></h1>
<h3 id="61-research-funding-at-uc-berkeley"><a class="header" href="#61-research-funding-at-uc-berkeley">6.1 Research Funding at UC Berkeley</a></h3>
<p>Development of the RISC-V architecture and implementations has been partially funded by the
following sponsors.</p>
<ul>
<li>Par Lab: Research supported by Microsoft (Award #024263) and Intel (Award #024894)
funding and by matching funding by U.C. Discovery (Award #DIG07-10227). Additional
support came from Par Lab affiliates Nokia, NVIDIA, Oracle, and Samsung.</li>
<li>Project Isis:DoE Award DE-SC0003624.</li>
<li>ASPIRE Lab: DARPA PERFECT program, Award HR0011-12-2-0016. DARPA POEM
program Award HR0011-11-C-0100. The Center for Future Architectures Research (C-FAR),
a STARnet center funded by the Semiconductor Research Corporation. Additional sup-
port from ASPIRE industrial sponsor, Intel, and ASPIRE affiliates, Google, Huawei, Nokia,
NVIDIA, Oracle, and Samsung.</li>
</ul>
<p>The content of this paper does not necessarily reflect the position or the policy of the US government
and no official endorsement should be inferred.</p>
<h6 id="77"><a class="header" href="#77">77</a></h6>
<h1 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h1>
<p>[1] Robert P. Goldberg. Survey of virtual machine research.Computer, 7(6):34‚Äì45, June 1974.</p>
<p>[2] Juan Navarro, Sitaram Iyer, Peter Druschel, and Alan Cox. Practical, transparent operating
system support for superpages.SIGOPS Oper. Syst. Rev., 36(SI):89‚Äì104, December 2002.</p>
<h6 id="79"><a class="header" href="#79">79</a></h6>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="c2rust.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="c2rust.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
