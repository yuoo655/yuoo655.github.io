<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RISC-V-Reader</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">开始之前</a></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">1.</strong> 🚧 rust学习记录</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="daliy/7-2.html"><strong aria-hidden="true">1.1.</strong> 7.2</a></li><li class="chapter-item expanded "><a href="daliy/7-3.html"><strong aria-hidden="true">1.2.</strong> 7.3</a></li><li class="chapter-item expanded "><a href="daliy/7-4.html"><strong aria-hidden="true">1.3.</strong> 7.4</a></li><li class="chapter-item expanded "><a href="daliy/7-5.html"><strong aria-hidden="true">1.4.</strong> 7.5</a></li><li class="chapter-item expanded "><a href="daliy/7-6.html"><strong aria-hidden="true">1.5.</strong> 7.6</a></li><li class="chapter-item expanded "><a href="daliy/7-7.html"><strong aria-hidden="true">1.6.</strong> 7.7</a></li><li class="chapter-item expanded "><a href="1.html" class="active"><strong aria-hidden="true">1.7.</strong> RISC-V-Reader</a></li><li class="chapter-item expanded "><a href="2.html"><strong aria-hidden="true">1.8.</strong> riscv-privileged</a></li></ol></li><li class="chapter-item expanded "><a href="c2rust.html"><strong aria-hidden="true">2.</strong> 🚧 c2rust</a></li><li class="chapter-item expanded "><a href="foo.html"><strong aria-hidden="true">3.</strong> 🚧 foo</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <pre><code>2018
</code></pre>
<h1 id="risc-v-手册"><a class="header" href="#risc-v-手册">RISC-V 手册</a></h1>
<h3 id="一本开源指令集的指南"><a class="header" href="#一本开源指令集的指南">一本开源指令集的指南</a></h3>
<p>DAVID PATTERSON, ANDREW WATERMAN</p>
<p>翻译：勾凌睿、黄成、刘志刚</p>
<p>校阅：包云岗</p>
<h2 id="参考卡"><a class="header" href="#参考卡">参考卡</a></h2>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li>参考卡</li>
<li>致谢</li>
<li>关于作者</li>
<li>前言</li>
<li>译者序
<ul>
<li>翻译团队</li>
</ul>
</li>
<li>第一章 为什么要有RISC-V？
<ul>
<li>1.1 导言</li>
<li>1.2 模块化与增量型ISA</li>
<li>1.3 ISA设计</li>
<li>1.4 全书的总览</li>
<li>1.5 结束语</li>
<li>1.6 扩展阅读</li>
</ul>
</li>
<li>第二章 RV32I：RISC-V基础整数指令集
<ul>
<li>2.1 导言</li>
<li>2.2 RV32I指令格式</li>
<li>2.3 RV32I寄存器</li>
<li>2.4 RV32I整数计算</li>
<li>2.5 RV32I的Load和Store</li>
<li>2.6 RV32I条件分支</li>
<li>2.7 RV32I无条件跳转</li>
<li>2.8 RV32I杂项</li>
<li>2.9 使用插入排序比较RV32I，ARM- 32 ，MIPS- 32 和x86- 32 指令集</li>
<li>2.10 结束语</li>
<li>2.11 扩展阅读</li>
</ul>
</li>
<li>第三章 RISC-V汇编语言
<ul>
<li>3.1 导言</li>
<li>3.2 函数调用规范（Calling convention）</li>
<li>3.3 汇编器</li>
<li>3.4 链接器</li>
<li>3.5 静态链接和动态链接</li>
<li>3.6 加载器</li>
<li>3.7 结束语</li>
<li>3.8 扩展阅读</li>
</ul>
</li>
<li>第四章 乘法和除法指令
<ul>
<li>4.1 导言</li>
<li>4.2 结束语</li>
<li>4.3 扩展阅读</li>
</ul>
</li>
<li>第五章 RV32F和RV32D：单精度和双精度浮点数....................................................................
<ul>
<li>
<ol start="5">
<li>1 导言</li>
</ol>
</li>
<li>5.2浮点寄存器</li>
<li>5.3浮点加载，存储和算术指令</li>
<li>5.4浮点转换和搬运</li>
<li>5.5其他浮点指令</li>
<li>5.6使用DAXPY程序比较RV32FD，ARM- 32 ，MIPS- 32 和x86-</li>
<li>5.7结束语..............................................................................................................................................</li>
<li>5.8 扩展阅读</li>
</ul>
</li>
<li>第六章 原子指令
<ul>
<li>6.1 导言</li>
<li>
<ol start="6">
<li>2 结束语</li>
</ol>
</li>
<li>6.3 扩展阅读</li>
</ul>
</li>
<li>第七章 压缩指令
<ul>
<li>7.1 导言</li>
<li>7.2 RV32GC，Thumb- 2 ，microMIPS和x86- 32 的比较</li>
<li>7.3 结束语</li>
<li>7.4 扩展阅读</li>
</ul>
</li>
<li>第八章 向量
<ul>
<li>8.1 导言</li>
<li>8.2 向量计算指令</li>
<li>8.3 向量寄存器和动态类型</li>
<li>8.4 向量的Load和Store操作</li>
<li>8.5 向量操作期间的并行性</li>
<li>8.6 向量运算的条件执行</li>
<li>8.7 其他向量指令</li>
<li>8.8 例子：用RV32V写成的DAXPY程序</li>
<li>8.9 RV32V，MIPS-32 MSA SIMD和x86-32 AVX SIMD的比较</li>
<li>8.10 结束语</li>
<li>8.11 扩展阅读</li>
</ul>
</li>
<li>第九章 RV64： 64 位地址指令
<ul>
<li>9.1 导言</li>
<li>9.2使用插入排序来比较RV64与其他 64 位ISA</li>
<li>9.3程序大小</li>
<li>9.4结束语</li>
<li>9.5了解更多</li>
</ul>
</li>
<li>第十章 RV32/64特权架构
<ul>
<li>10.1 导言</li>
<li>10.2 简单嵌入式系统的机器模式</li>
<li>10.3 机器模式下的异常处理</li>
<li>10.4 嵌入式系统中的用户模式和进程隔离</li>
<li>10.5 现代操作系统的监管者模式</li>
<li>10.6 基于页面的虚拟内存</li>
<li>10.7 结束语</li>
<li>10.8 扩展阅读</li>
</ul>
</li>
<li>第十一章 RISC-V未来的可选扩展
<ul>
<li>11.1 “B”标准扩展：位操作</li>
<li>11.2 “E”标准扩展：嵌入式</li>
<li>11.3 “H”特权态架构扩展：支持管理程序（Hypervisor）</li>
<li>11.4 “J”标准扩展：动态翻译语言</li>
<li>11.5 “L”标准扩展：十进制浮点</li>
<li>11.6 “N”标准扩展：用户态中断</li>
<li>11.7 “P”标准扩展：封装的单指令多数据（Packed-SIMD）指令</li>
<li>11.8 “Q”标准扩展：四精度浮点</li>
<li>11.9 结束语</li>
</ul>
</li>
<li>附录A RISC-V指令列表</li>
</ul>
<h3 id="对这本risc-v手册的称赞"><a class="header" href="#对这本risc-v手册的称赞">对这本RISC-V手册的称赞</a></h3>
<h4 id="我喜欢risc-v和这本书因为它们优雅简洁扼要且完整书中的评论无偿提供"><a class="header" href="#我喜欢risc-v和这本书因为它们优雅简洁扼要且完整书中的评论无偿提供">我喜欢RISC-V和这本书，因为它们优雅——简洁、扼要且完整。书中的评论无偿提供</a></h4>
<h4 id="了一些历史设计的动机以及一些对于各种架构的批评"><a class="header" href="#了一些历史设计的动机以及一些对于各种架构的批评">了一些历史，设计的动机，以及一些对于各种架构的批评。</a></h4>
<pre><code>——C. Gordan Bell，微软公司成员，Digital PDP- 11 和
VAX- 11 指令集架构的设计者
</code></pre>
<pre><code>本书讲述了RISC-V可以做到什么，以及为什么它的设计师选择赋予它这些能力。更有
趣的是，作者说出了为什么RISC-V省略了早期计算机中存在的一些东西。这些原因至
少和RISC-V本身能做到什么与忽略了什么一样有意思。
——Ivan Sutherland，图灵奖获得者，被称作计算机图形学之父
</code></pre>
<pre><code>RISC-V会改变世界，这本书会助你成为改变的一部分。
——Michael B. Taylor，华盛顿大学教授
</code></pre>
<p>RISC-V是学生学习指令集架构和汇编级编程的理想选择，而它们是以后用高级语言工
作的基础。这本写得很清楚的书提供了对RISC-V的很好的介绍，再加上一些对其演化
历史的深刻见解及与其它常见架构的比较。以过去的指令集架构为鉴，RISC-V的设计
者能够避免一些不必要的、不合理的特征，这让教学过程变得容易。即使它很简洁，它
也足够强大，能在实际应用中广泛使用。很久以前我教过汇编编程的入门课，如果我现
在去教这门课的话，我会很乐意用这本书作为教材。
——John Mashey，MIPS指令集架构的设计者之一</p>
<p>这本书对于任何使用RISC-V ISA的人来说都是十分宝贵的参考。为了便于快速查阅，
操作码按几种有用的格式呈现，这让编写和解释汇编代码变得简单。此外，对于如何使
用这个ISA的解释和示例也让程序员的工作更容易。和其他ISA比较的部分很有意思，
它们解释了RISC-V设计者们做出他们的设计决策的原因。
——Megan Wachs，博士，SiFive工程师</p>
<h2 id="致谢"><a class="header" href="#致谢">致谢</a></h2>
<p>David Patterson把这本书献给他的父母：</p>
<p>——给我的父亲David，我从他那儿继承了创造
力、运动天赋和为正义奋斗的勇气；以及</p>
<p>——给我的母亲Lucy，我从她那儿继承了智慧、
乐观和良好的性格。</p>
<p>感谢你们成为我如此伟大的榜样，你们让我明
白了成为好的配偶、父亲和祖父的意义。</p>
<p>Andrew Waterman把这本书献给他的父母 John
和Elizabeth，他们即便在千里之外也支持着他。</p>
<h2 id="关于作者"><a class="header" href="#关于作者">关于作者</a></h2>
<pre><code>David Patterson在加州大学伯克利分校担任计算机科学教授 40 年后于 2016 年退休，
随后加入Google担任杰出工程师（distinguished engineer，Google的职位）。他还担任
了RISC-V基金会董事会副主席。过去，他曾被任命为伯克利计算机科学部（Computer
Science Division）主席，并当选为计算机研究协会（Computing Research Association）
主席和计算机协会（ACM，Association for Computing Machinery）主席。在 20 世纪
80 年代，他领导了四代精简指令集计算机（RISC，Reduced Instruction Set Computer）
项目，伯克利最新的RISC因此得名“RISC Five”。他和Andrew Waterman都是RISC-
V四位架构师中的一员。除了RISC以外，他最著名的研究项目有廉价磁盘冗余阵列
（RAID，Redundant Arrays of Inexpensive Disks）和工作站网络（NOW，Networks of
Workstations）。这项研究让他发表了许多论文，出版了 7 本书，获得了超过 35 个荣
誉，包括当选国家工程院和国家科学院院士，名列硅谷工程师名人堂，还成为了计算
机历史博物馆、ACM、IEEE和两个AAAS组织的研究员。他的教学奖项包括杰出教
学奖（加州大学伯克利分校），Karstrom杰出教育家奖（ACM）， Mulligan教育奖章
（IEEE）和本科教学奖（IEEE）。他还因为一本计算机体系结构方面的书和一本关于
软件工程的书被文本和学术作家协会（Text and Academic Authors Association）授予计
算机教科书卓越奖（“Texty”）。他在加州大学洛杉矶分校获得了他的所有学位，也被
授予了杰出工程学院校友奖。他在南加州长大，乐趣是踢足球、和他的儿子一起骑自
行车，以及和妻子在沙滩上散步。他们在高中时期就是情侣。在本书的测试版出版几
天后，他们庆祝了 50 周年结婚纪念日。
</code></pre>
<pre><code>Andrew Waterman是SiFive的总工程师和联合创始人。SiFive由RISC-V架构的创建
者们建立，旨在提供基于RISC-V的低成本定制芯片。他在加州大学伯克利分校获得
了计算机科学博士学位。在那里，他厌倦了现有的指令集架构的变幻莫测，于是共同
设计了RISC-V ISA和第一台RISC-V微处理器。Andrew是基于开源RISC-V的Rocket
芯片生成器、Chisel硬件构造语言以及Linux操作系统内核和GNU C编译器和C库
的RISC-V端口的主要贡献者之一。他还有加州大学伯克利分校的硕士学位，这是
</code></pre>
<h3 id="risc-v的rvc扩展的基础他还有杜克大学的工学学士学位"><a class="header" href="#risc-v的rvc扩展的基础他还有杜克大学的工学学士学位">RISC-V的RVC扩展的基础，他还有杜克大学的工学学士学位。</a></h3>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>欢迎！
RISC-V自 2011 年推出以来迅速地普及。我们认为一个精简的程序员指南将进一步促进
它的发展，并促使新人理解为什么它是一个有吸引力的指令集，以及它与传统指令集架构
(ISA)的不同。
我们的灵感部分来源于其它指令集架构书籍，但我们希望RISC-V自身的简洁性能让我
们写得比See MIPS Run一类 500 多页的详尽书籍少很多。我们把全书的长度控制到了前述
的三分之一，至少在这个意义上我们成功了。实际上，介绍模块化RISC-V指令集的每个组
成部分的十章只用了 100 页——即便为了有助于快速阅读，平均每页用到了一张图片（一共
75 张）。
在解释指令集设计的原理之后，我们将阐述RISC-V架构师在设计指令集的时候，如何
在过去 40 年的指令集的基础上取其精华，去其糟粕。要评判一个指令集架构，不仅要看它
包括了什么，而且要看它省略了什么。
随后我们会按顺序介绍这个模块化架构的每个组成部分。每一章都会包含一个用RISC-
V汇编语言写成的程序，这是为了展示那一章所述的指令的用法，这样有助于汇编语言程序
员学习RISC-V汇编。有时，我们还会列出用ARM，MIPS和x86写成的同样的程序，从而
突出RISC-V在简洁性，以及成本、功耗、性能方面的优势。
为了增加本书的趣味性，我们在页边加入了将近 50 个侧边栏，这里面放了一些有关书
中内容的评论，希望它们能带来一些乐趣。我们还在页边放了大约 75 个图片，用于展示设
计良好ISA的例子。（我们充分利用了侧边的空间！）最后，对于那些愿意钻研的读者，我们
在全书中加入了大概 25 段补充说明。如果你对某个主题感兴趣，可以深入研究这些可选部
分。略过这些部分不会影响对书中的其他内容的理解，所以如果你对他们不感兴趣的话，尽
管跳过它们。对于计算机体系结构爱好者，我们援引的 25 篇论文和书籍能够开阔你的视野。
在写这本书的过程中，我们从它们当中学到了很多东西！</p>
<p>为什么引用了这么多名言？
我们认为引用这些名言也能增加本书的趣味性，因此我们把这 25 个引用分散在整本书
里。 它们同样是一种将智慧从前辈传递给初学者的有效机制，且有助于为良好的ISA设计
设定文化标准。我们希望读者也能了解一点该领域的历史，这就是为什么我们在全书中引用
了众多著名计算机科学家和工程师的名言。</p>
<p>导言和参考
我们打算将这本薄薄的书作为RISC-V的介绍和参考资料，供有兴趣编写RISC-V代码的
学生和嵌入式系统程序员使用。本书假设读者事先已经了解过至少一个指令集。如果没
有，您可能希望浏览基于RISC-V的相关入门架构手册：Computer Organization and Design
RISC-V Edition: The Hardware Software Interface。
这本书中的参考资料包括：
⚫ 参考卡——这个一页（两面）的RISC-V的精简描述囊括了RV32GCV和
RV64GCV，同时包含了基本内容和所有已定义的指令扩展：RVI, RVM, RVA,
RVF, RVD，甚至包括了尚处在开发阶段的RVV。
⚫ 指令图——每个指令扩展的半页图形描述（它们是每章的第一个图）以同样的格
式列出了所有RISC-V指令的全称，让大家可以轻松查看每条指令的不同变种。见</p>
<h4 id="图214151617181919293和94"><a class="header" href="#图214151617181919293和94">图2.1、4.1、5.1、6.1、7.1、8.1、9.1、9.2、9.3和9.4。</a></h4>
<h4 id="-操作码映射这些表格在一页中显示了指令布局操作码格式类型和每页指"><a class="header" href="#-操作码映射这些表格在一页中显示了指令布局操作码格式类型和每页指">⚫ 操作码映射——这些表格在一页中显示了指令布局，操作码，格式类型和每页指</a></h4>
<h4 id="令扩展的指令助记符见图-2-3333442525362767577"><a class="header" href="#令扩展的指令助记符见图-2-3333442525362767577">令扩展的指令助记符。见图 2 .3、3.3、3.4、4.2、5.2、5.3、6.2、7.6、7.5、7.7、</a></h4>
<h4 id="95和101这些指令图和操作码映射启发了我们在书的副标题中使用单词图"><a class="header" href="#95和101这些指令图和操作码映射启发了我们在书的副标题中使用单词图">9.5和10.1。（这些指令图和操作码映射启发了我们在书的副标题中使用单词图</a></h4>
<h4 id="集"><a class="header" href="#集">集。）</a></h4>
<h4 id="-指令术语表附录a是对每个risc-v指令和伪指令的详尽描述1-它包括所有内"><a class="header" href="#-指令术语表附录a是对每个risc-v指令和伪指令的详尽描述1-它包括所有内">⚫ 指令术语表——附录A是对每个RISC-V指令和伪指令的详尽描述^1 。它包括所有内</a></h4>
<h4 id="容操作名称和操作数英文描述寄存器传输语言定义它所在的risc-v扩"><a class="header" href="#容操作名称和操作数英文描述寄存器传输语言定义它所在的risc-v扩">容：操作名称和操作数、英文描述、寄存器传输语言定义、它所在的RISC-V扩</a></h4>
<h4 id="展指令的全称指令格式显示操作码的指令图以及紧凑版本指令的参照"><a class="header" href="#展指令的全称指令格式显示操作码的指令图以及紧凑版本指令的参照">展、指令的全称、指令格式、显示操作码的指令图，以及紧凑版本指令的参照。</a></h4>
<h4 id="令人惊讶的是所有这些加起来不到-50-页"><a class="header" href="#令人惊讶的是所有这些加起来不到-50-页">令人惊讶的是，所有这些加起来不到 50 页。</a></h4>
<h4 id="-索引它可以帮你通过指令全称或助记符找到描述指令说明定义或图表的页"><a class="header" href="#-索引它可以帮你通过指令全称或助记符找到描述指令说明定义或图表的页">⚫ 索引——它可以帮你通过指令全称或助记符找到描述指令说明、定义或图表的页</a></h4>
<h4 id="面它是按照字典的形式组织的"><a class="header" href="#面它是按照字典的形式组织的">面。它是按照字典的形式组织的。</a></h4>
<p>勘误和补充内容
我们打算把勘误集中起来，每年发布几次更新。这本书的网站上会有本书的最新版
本，还会简单介绍一下当前版本相对上一版本的改变。可在本书的网站
（www.riscvbook.com）上查看勘误表的历史版本或报告新的错误。我们预先为您在这一版
中发现的问题表示歉意。我们期待您的反馈意见，来帮助我们改进这本书。</p>
<p>本书的诞生过程
在 2017 年 5 月 8 日至 11 日在上海举行的第六届RISC-V研讨会上，我们认识到了对这么一
本书的需求，几个星期后我们开始了编写。考虑到Patterson在写书方面的丰富经验，我们
计划让他写大部分的章节。我们两人在组织方面进行了合作，并且是彼此章节的第一个评
论者。Patterson撰写了第 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9 、 11 章，参考卡和本前言，而
Waterman写了第 10 章和附录A（本书的最大部分）， 并编写了书中的全部程序。Waterman还
维护了Armando Fox提供的LaTeX工具，使我们能做出这本书。
我们在 2017 年秋季学期为 800 名加州大学伯克利分校的学生提供了这本教科书的测试版
本。在融入了他们的反馈后，当 2017 年学期结束以后，第一个正式版将于 2017 年 11 月 28 日
至 30 日在硅谷举办的第七届RISC研讨会上及时发布。
RISC-V是一个伯克利研究项目的副产品。该项目正在针对更容易地同时构建硬件和软
件的目标进行开发。</p>
<p>致谢
我们要感谢Armando Fox，因为我们使用了他的LaTeX工具，以及采纳了他关于个人出
版的建议。
我们最深切的感谢要送给那些读了本书早期的草稿并提出了有用建议的人，比如：
Krste Asanovi ́c, Nikhil Athreya, C. Gordon Bell, Stuart Hoad, David Kanter, John Mashey, Ivan
Sutherland, Ted Speers, Michael Taylor, Megan Wachs,....
最后，我们要感谢数百名加州大学伯克利分校学生在调试方面的付出以及他们的对这
些素材的持续热忱！</p>
<pre><code>David Patterson 和 Andrew Waterman
2017 年 9 月 1 日于加州伯克利
</code></pre>
<p>(^1) 定义RV32V的委员会没有赶在本书的测试版本之前完成他们的工作，所以我们在附录A中省略了这些
指令。尽管到时候RV32V有可能会有一些微小的改变，第八章是我们对于它的最为接近的猜想。</p>
<h2 id="译者序"><a class="header" href="#译者序">译者序</a></h2>
<h4 id="大约四个月前的一天我收到加州大学伯克利分校毕业的谭章熹博士的消息告知图"><a class="header" href="#大约四个月前的一天我收到加州大学伯克利分校毕业的谭章熹博士的消息告知图">大约四个月前的一天，我收到加州大学伯克利分校毕业的谭章熹博士的消息，告知图</a></h4>
<p>灵奖得主David Patterson教授（谭博士的导师）希望将他和Andrew Waterman一起完成的
《The RISC-V Reader》翻译成中文。这让我想起了大约四年前的一天，我收到了正在加州
大学伯克利分校做博士后的钱学海博士的邮件，告知David Patterson教授希望将他和Krste
Asanovic教授一起撰写的文章在中文杂志上发表。当我收到了中文翻译稿《指令系统应该
免费：RISC-V的案例》后，动用了专栏编委的一点小权利，立刻向《中国计算机学会通
讯》强烈推荐了这篇文章。文章很快于 2015 年 2 月发表，然而略显遗憾的是彼时它并未得到
广泛关注，不过却让我们团队“近水楼台先得月”，成为国内最早将体系结构前沿研究全面
转到了RISC-V平台的团队。这一次，怀着对RISC-V的感激之情、对Patterson教授的敬仰之
心，更是为了便于更多中国爱好者了解RISC-V的愿望，我欣然接受了谭博士的请求。
过去几年深入接触RISC-V后，我心中时常呈现出一种愿景——RISC-V很可能像Linux
那样开启开源芯片设计的黄金时代。事实上，伯克利的科研侠客们发明RISC-V就是希望
“Instruction Sets Want to be Free”——全世界任何公司、大学、研究机构与个人都可以开
发兼容RISC-V指令集的处理器，都可以融入到基于RISC-V构建的软硬件生态系统，而不需
要为指令集付一分钱。这是伟大的理想！
在开源软件生态中，Linux是整个生态的基石。基于Linux，人们开发Python、LLVM、
GCC等完整的工具链，创造MySQL、Apache、Hadoop等大量开源软件，实验各种创新思想
与技术，逐渐形成一个价值超过 150 亿美元的开源软件生态。这对中国的互联网产业的意义
尤为重大，不仅提升了BAT等互联网企业的技术研发能力，也大大降低了互联网产业创新
的门槛，如今 3 - 5 位开发人员在几个月时间里就能快速开发出一个互联网应用。在芯片设计
领域，RISC-V有望像Linux那样成为计算机芯片与系统创新的基石。但是只有RISC-V又是
远远不够的，更重要的是要形成一个基于RISC-V的开源芯片设计生态，包括开源工具链、
开源IP、开源SoC等等。
RISC-V还只是星星之火，却已展露出燎原之潜力。作为全世界最大的芯片用户，中国
一直希望能把芯片产业做大做强，各方也都在努力。借鉴开源软件对于中国互联网产业发
展的作用，也许开源芯片设计是一条值得尝试的道路。这本中文版《RISC-V手册》，希望
能成为这条道路上一个小路标。</p>
<pre><code>包云岗
2018 年 11 月 3 日
</code></pre>
<h3 id="翻译团队"><a class="header" href="#翻译团队">翻译团队</a></h3>
<p> 包云岗 中科院计算所研究员，先进计算机系统研究中心主任，长期从事计算机体系结构研究
 勾凌睿 中国科学院大学计算机科学与技术专业本科生，有志于计算机体系结构研究
 黄成 中科院计算所研究生，研究方向为计算机系统结构
 刘志刚 中科院计算所硕士研究生，开展基于RISC-V的前沿研究，曾获第二届全国大学生计算机系统
能力培养大赛一等奖</p>
<h2 id="第一章-为什么要有risc-v"><a class="header" href="#第一章-为什么要有risc-v">第一章 为什么要有RISC-V？</a></h2>
<pre><code>简约是复杂的最终形式。 ——列奥纳多·达·芬奇(Leonardo da Vinci)
</code></pre>
<h3 id="11-导言"><a class="header" href="#11-导言">1.1 导言</a></h3>
<pre><code>RISC-V（“RISC five”）的目标是成为一个通用的指令集架构（ISA）：
⚫ 它要能适应包括从最袖珍的嵌入式控制器，到最快的高性能计算机等各种规模的
处理器。
⚫ 它应该能兼容各种流行的软件栈和编程语言。
⚫ 它应该适应所有实现技术，包括现场可编程门阵列（FPGA）、专用集成电路
（ASIC）、全定制芯片，甚至未来的设备技术。
⚫ 它应该对所有微体系结构样式都有效：例如微编码或硬连线控制;顺序或乱序执行
流水线; 单发射或超标量等等。
⚫ 它应该支持广泛的专业化，成为定制加速器的基础，因为随着摩尔定律的消退，
加速器的重要性日益提高。
⚫ 它应该是稳定的，基础的指令集架构不应该改变。更重要的是，它不能像以前的
专有指令集架构一样被弃用，例如AMD Am29000、Digital Alpha、Digital VAX、
Hewlett Packard PA-RISC、Intel i860、Intel i960、Motorola 88000、以及Zilog
Z8000。
</code></pre>
<pre><code>RISC-V的不同寻常不仅在于它是一个最近诞生的指令集架构（它诞生于最近十
年，而大多数其他指令集都诞生于 20 世纪 70 到 80 年代），而且在于它是一个开源的指
令集架构。与几乎所有的旧架构不同，它的未来不受任何单一公司的浮沉或一时兴起
的决定的影响（这一点让许多过去的指令集架构都遭了殃）。它属于一个开放的，非
营利性质的基金会。RISC-V基金会的目标是保持RISC-V的稳定性，仅仅出于技术原
因缓慢而谨慎地发展它，并力图让它之于硬件如同Linux之于操作系统一样受欢迎。
图1.1列出了RISC-V基金会最大的企业成员，作为其活力的证明。
</code></pre>
<pre><code>图 1.1 ： 2017 年 5 月第六届 RISC-V 研讨会上 RISC-V 基金会的企业成员按年销售额排名。左栏公
司的年销售额均超过 500 亿美元，中间栏目公司的销售额低于 500 亿美元但超过 50 亿美元，右栏
的销售额低于 50 亿美元但超过 5 亿美元。 RISC-V 基金会包括另外 25 家小公司， 5 家初创公司
（ Antmicro Ltd ， Blockstream ， Esperanto Technologies ， Greenwaves Technologies 和 SiFive ），
4 家非营利组织（ CSEM ， Draper Laboratory ， ICT 和 lowRISC ）和 6 所大学（ ETH Zurich ，
IIT Madras ， National University of Defense Technology ， Princeton 和 UC Berkeley ）。 60 个组
织中的大多数总部都在美国以外。要了解更多信息，请访问 http://www.riscv.org 。
</code></pre>
<pre><code>列奥纳多·达·芬奇
( 1452 - 1519)是一位文
艺复兴时期的建筑师，
工程师，雕塑家，同时
也是一名画家，创作了
著名的《蒙娜丽莎的微
笑》
</code></pre>
<p>我们在页边加入了侧
边栏，是希望能在里面
放入一些有意思的评
论。比如，RISC-V最初
是为加州大学伯克利
分校的内部研究和课
程开发的。外部人员的
使用使它变得开放。
RISC-V架构师在开始
收到有关网上ISA课程
变化的投诉时就了解
到了来自外部的兴趣。
只有在架构师理解了
需求之后，他们才会尝
试把它变为一个开放
的ISA标准。</p>
<p>图 <strong>1.2</strong> ： <strong>x86</strong> 指令集自诞生以来指令数量的增长。 <strong>x86</strong> 在 <strong>1978</strong> 年诞生时有 <strong>80</strong> 条指令，到 <strong>2015</strong> 年增长了 <strong>16</strong> 倍，
到了 <strong>1338</strong> 条指令，并且仍在增长。令人惊讶的是这张图的数据仍显保守。 <strong>2015</strong> 年在英特尔的博客上有着
<strong>3600</strong> 条指令的统计结果 <strong>[Rodgers and Uhlig 2017]</strong> ，这意味着 <strong>x86</strong> 指令的增长速率提高到了（在 <strong>1978</strong> 年到
<strong>2015</strong> 年之内）每四天增长一条。我们是用汇编语言指令计算的，他们想必算入了机器语言指令。正如第八
章所解释的那样，这个增长的很大一部分是因为 <strong>x86 ISA</strong> 依赖于 <strong>SIMD</strong> 指令来实现数据级并行。</p>
<pre><code>图 1.3 ： x86- 32 ASCII Adjust after Addition （aaa）指令的描述。它以二进制编码十进制数（ BCD ）形式
进行计算机运算，这种方式已经被扔进信息技术历史的垃圾堆里。 x86 还有三个相似的指令，分别执行减
法操作（aas），乘法操作（aam），和除法操作（aad）。由于他们都是单字节指令，它们加起来占用了宝
贵的操作码空间的 1.6% （ 4 /256 ）。
</code></pre>
<h3 id="12-模块化与增量型isa"><a class="header" href="#12-模块化与增量型isa">1.2 模块化与增量型ISA</a></h3>
<pre><code>英特尔曾将其未来押在高端微处理器之上，但那时还需要很多年时间。为了对抗Zilog，英特尔开发了
一款过渡产品，并给它起名为 8086 。它本应该是短命的，没有任何继任者，但事情并非如此。高端处
理器姗姗来迟，等它最终出现时，它的性能并不如人意。因此， 8086 架构延续了下去——它变成 32 位
处理器，最终演变为了 64 位处理器。它的名称不断变化（80186,80286，i386，i486，Pentium），但基
础指令集保持不变。
——Stephen P. Morse, 8086 的架构师[Morse 2017]
</code></pre>
<h4 id="计算机体系结构的传统方法是增量isa新处理器不仅必须实现新的isa扩展还必须"><a class="header" href="#计算机体系结构的传统方法是增量isa新处理器不仅必须实现新的isa扩展还必须">计算机体系结构的传统方法是增量ISA，新处理器不仅必须实现新的ISA扩展，还必须</a></h4>
<h4 id="实现过去的所有扩展目的是为了保持向后的二进制兼容性这样几十年前程序的二进制"><a class="header" href="#实现过去的所有扩展目的是为了保持向后的二进制兼容性这样几十年前程序的二进制">实现过去的所有扩展。目的是为了保持向后的二进制兼容性，这样几十年前程序的二进制</a></h4>
<h4 id="版本仍然可以在最新的处理器上正确运行这一要求与来自于同时发布新指令和新处理器"><a class="header" href="#版本仍然可以在最新的处理器上正确运行这一要求与来自于同时发布新指令和新处理器">版本仍然可以在最新的处理器上正确运行。这一要求与来自于同时发布新指令和新处理器</a></h4>
<h4 id="的营销上的诱惑共同导致了isa的体量随时间大幅增长例如图12显示了当今主导isa"><a class="header" href="#的营销上的诱惑共同导致了isa的体量随时间大幅增长例如图12显示了当今主导isa">的营销上的诱惑共同导致了ISA的体量随时间大幅增长。例如，图1.2显示了当今主导ISA</a></h4>
<pre><code>80 x86的指令数量增长过程。这个指令集架构的历史可以追溯到 1978 年，在它的漫长生涯
中，它平均每个月增加了大约三条指令。
这个传统意味着x86- 32 （我们用它表示 32 位地址版本的x86）的每个实现必须实现过去
的扩展中的错误设计，即便它们不再有意义。例如，图1.3描述了x86的ASCII Adjust after
Addition（aaa）指令，该指令早已失效。
作为一个类比，假设一家餐馆只提供固定价格的餐点，最初只是一顿包含汉堡和奶昔
的小餐。随着时间的推移，它会加入薯条，然后是冰淇淋圣代，然后是沙拉，馅饼，葡萄
酒，素食意大利面，牛排，啤酒，无穷无尽，直到它成为一顿大餐。食客可以在那家餐厅
找到他们过去吃过的东西，尽管总的来说这样做可能没什么意义。这样做的坏处是，用餐
者为每次晚餐支付的宴会费用不断增加。
RISC-V的不同寻常之处，除了在于它是最近诞生的和开源的以外，还在于：和几乎所
有以往的ISA不同，它是模块化的。它的核心是一个名为 RV32I 的基础ISA，运行一个完整
的软件栈。RV32I是固定的，永远不会改变。这为编译器编写者，操作系统开发人员和汇
编语言程序员提供了稳定的目标。模块化来源于可选的标准扩展，根据应用程序的需要，
硬件可以包含或不包含这些扩展。这种模块化特性使得RISC-V具有了袖珍化、低能耗的特
点，而这对于嵌入式应用可能至关重要。RISC-V编译器得知当前硬件包含哪些扩展后，便
可以生成当前硬件条件下的最佳代码。惯例是把代表扩展的字母附加到指令集名称之后作
为指示。例如，RV32IMFD将乘法（RV32M），单精度浮点（RV32F）和双精度浮点
（RV32D）的扩展添加到了基础指令集（RV32I）中。
继续用我们刚才的类比来说，RISC-V提供的是菜单，而不是一顿应有尽有的自助餐。
主厨只需要烹饪顾客需要的东西（而不是每次都做出一顿盛宴），顾客只需要按他们的订单
付费。RISC-V无需仅仅为了市场吸引力而添加指令。RISC-V基金会会决定什么时候在菜单
里添加新的选项，而他们只会出于技术原因这样做，而且要在由软硬件专家组成的委员会
进行专门的公开讨论以后才会添加。即使那些新选择出现在了菜单上，它们仍是可选的，
不会像在增量ISA中那样成为未来所有实现的必要组成部分。
</code></pre>
<h3 id="13-isa-设计-101"><a class="header" href="#13-isa-设计-101">1.3 ISA 设计 101</a></h3>
<h4 id="在介绍risc-v这个isa之前了解计算机架构师在设计isa时的基本原则和必须做"><a class="header" href="#在介绍risc-v这个isa之前了解计算机架构师在设计isa时的基本原则和必须做">在介绍RISC-V这个ISA之前，了解计算机架构师在设计ISA时的基本原则和必须做</a></h4>
<h4 id="出的权衡是有用的如下的列表列出了七种衡量标准页边放置了对应的七个图标以突"><a class="header" href="#出的权衡是有用的如下的列表列出了七种衡量标准页边放置了对应的七个图标以突">出的权衡是有用的。如下的列表列出了七种衡量标准。页边放置了对应的七个图标，以突</a></h4>
<h4 id="出显示risc-v在随后章节中应对它们的实例印刷版的封底有所有图标的图例"><a class="header" href="#出显示risc-v在随后章节中应对它们的实例印刷版的封底有所有图标的图例">出显示RISC-V在随后章节中应对它们的实例。（印刷版的封底有所有图标的图例。）</a></h4>
<h4 id="-成本美元硬币"><a class="header" href="#-成本美元硬币">⚫ 成本（美元硬币）</a></h4>
<h4 id="-简洁性轮子"><a class="header" href="#-简洁性轮子">⚫ 简洁性（轮子）</a></h4>
<h4 id="-性能速度计"><a class="header" href="#-性能速度计">⚫ 性能（速度计）</a></h4>
<h4 id="-架构和具体实现的分离分开的两个半圆"><a class="header" href="#-架构和具体实现的分离分开的两个半圆">⚫ 架构和具体实现的分离（分开的两个半圆）</a></h4>
<h4 id="-提升空间手风琴"><a class="header" href="#-提升空间手风琴">⚫ 提升空间（手风琴）</a></h4>
<h4 id="-程序大小相对的压迫着一条线的两个箭头"><a class="header" href="#-程序大小相对的压迫着一条线的两个箭头">⚫ 程序大小（相对的压迫着一条线的两个箭头）</a></h4>
<h4 id="-易于编程编译链接儿童积木像abc一样简单"><a class="header" href="#-易于编程编译链接儿童积木像abc一样简单">⚫ 易于编程/编译/链接（儿童积木“像ABC一样简单”）</a></h4>
<h4 id="为了解释我们的意思在这一节中我们会展示一些以往isa所作出的选择它们现在"><a class="header" href="#为了解释我们的意思在这一节中我们会展示一些以往isa所作出的选择它们现在">为了解释我们的意思，在这一节中我们会展示一些以往ISA所作出的选择。它们现在</a></h4>
<p>如果软件使用来自可
选扩展的省略的RISC-
V指令，则硬件会在软
件中捕获并执行所需
的功能，作为标准库的
一部分。</p>
<h4 id="看起来是不明智的而risc-v通常会做出更好的决定"><a class="header" href="#看起来是不明智的而risc-v通常会做出更好的决定">看起来是不明智的，而RISC-V通常会做出更好的决定。</a></h4>
<h4 id="成本-处理器通过集成电路实现通常称为芯片或晶粒它们叫做晶粒是因为它们由一些"><a class="header" href="#成本-处理器通过集成电路实现通常称为芯片或晶粒它们叫做晶粒是因为它们由一些">成本 处理器通过集成电路实现，通常称为芯片或晶粒。它们叫做晶粒是因为，它们由一些</a></h4>
<h4 id="单个的圆形晶片被切割成许多单独的片得到图14显示了risc-v处理器的晶圆成本对"><a class="header" href="#单个的圆形晶片被切割成许多单独的片得到图14显示了risc-v处理器的晶圆成本对">单个的圆形晶片被切割成许多单独的片得到。图1.4显示了RISC-V处理器的晶圆。成本对</a></h4>
<h4 id="晶粒面积十分敏感"><a class="header" href="#晶粒面积十分敏感">晶粒面积十分敏感：</a></h4>
<pre><code>cost ≈ f(die area^2 )
</code></pre>
<p>显然，晶粒越小，每个晶圆上能切割出来的晶粒越多。晶粒的大部分成本来自于处理过
的晶圆本身。不太直观的是，晶粒越小，产率（生产出的可用晶粒所占的比例）越高。原因
在于目前的硅生产工艺会在晶圆上留下一些散布的小瑕疵。因此晶粒越小，有缺陷部分所占
比重会越低。</p>
<p>图 <strong>1.4</strong> ：由 <strong>SiFive</strong> 设计的直径为 <strong>8</strong> 英寸的 <strong>RISC-V</strong> 晶圆。 它有两种类型的 <strong>RISC-V</strong> 芯片，使用较旧的较大加工
线。 <strong>FE310</strong> 芯片为 <strong>2.65mm×2.72mm</strong> ， <strong>SiFive</strong> 测试芯片为 <strong>2.89mm×2.72mm</strong> 。 一片晶圆上有 <strong>1846</strong> 片 <strong>FE310</strong> 和
<strong>1866</strong> 片 <strong>SiFive</strong> 测试芯片，总共 <strong>3712</strong> 个芯片。</p>
<p>架构师希望保持ISA的简洁性，从而缩小实现ISA的处理器的尺寸。我们将在随后的
章节看到，RISC-V ISA比ARM- 32 ISA简洁得多。就简洁性造成的影响举例，我们把使用
相同大小缓存（16KiB）的 RISC-V Rocket处理器和采用相同技术（TSMC40GPLUS）的 ARM-
32 Cortex A5处理器进行比较。RISC-V晶粒的大小是0.27mm^2 ，而ARM- 32 晶粒的大小是
0.53mm^2 。由于面积大一倍，ARM- 32 Cortex A5的晶粒成本是RISC-V Rocket的约 4 （ 22 ）
倍。即使晶粒的大小只缩小10%，成本也将以1.2（1.1^2 ）倍的比例缩小。</p>
<p>简洁性 鉴于成本对于复杂度的敏感性，架构师需要一个简单的ISA来缩小芯片面积。ISA
的简洁性还能缩短芯片的设计和验证时间，而它们可能构成了芯片开发的大部分成本。这些
成本必须算到芯片的成本当中。这个开销取决于发货芯片的数量。简洁性还能降低文档成本，</p>
<pre><code>高端处理器可以通过
将简单的指令组合在
一起来提升性能，而不
会因更大，更复杂的
ISA给所有低端实现带
来负担。这种技术称为
宏观融合，因为它将
“宏”指令融合在一
起。
</code></pre>
<h4 id="让客户更容易了解如何使用这个isa"><a class="header" href="#让客户更容易了解如何使用这个isa">让客户更容易了解如何使用这个ISA。</a></h4>
<h4 id="以下是arm--32-的isa复杂性的一个明显示例"><a class="header" href="#以下是arm--32-的isa复杂性的一个明显示例">以下是ARM- 32 的ISA复杂性的一个明显示例：</a></h4>
<pre><code>ldmiaeq SP!, {R4-R7, PC}
</code></pre>
<pre><code>该指令代表LoaD Multiple, Increment-Address, on EQual。它执行 5 次数据加载并写入 6
个寄存器，但仅当EQ条件码置位时才执行。此外，它将结果写入PC，因此它也执行条件
分支。真不少！
具有讽刺意味的是，即便需要实现的功能相同，简单指令也通常比复杂指令更容易被用
到。例如，x86- 32 有一个enter指令，该指令本应该是在进入一个创建一个栈帧的过程中执
行的第一条指令（见第三章）。大多数编译器用两条简单的x86- 32 指令来代替它：
push ebp # 将帧指针压入栈
mov ebp, esp # 把栈指针复制到帧指针
</code></pre>
<pre><code>性能 除非是那些用于嵌入式应用的微型芯片，处理器的性能和成本通常都能成为架构师的
关注对象。性能可以分解为如下三个因素：
푖푛푠푡푟푢푐푡푖표푛푠
푝푟표푔푟푎푚 ×
</code></pre>
<pre><code>푎푣푒푟푎푔푒 푐푙표푐푘 푐푦푐푙푒푠
푖푛푠푡푟푢푐푡푖표푛 ×
</code></pre>
<pre><code>푡푖푚푒
푐푙표푐푘 푐푦푐푙푒=
</code></pre>
<pre><code>푡푖푚푒
푝푟표푔푟푎푚^
即使一个简单的ISA可能在每个程序执行的指令数方面多于复杂的ISA，但它可以通过
更快的时钟频率或更低的平均单条指令周期数（CPI）来弥补。
例如，运行CoreMark测试程序[Gal-On, Levy 2012]（ 100000 次迭代）后，得到ARM- 32
Cortex-A9的性能为：
32. 27 퐵 푖푛푠푡푟푢푐푡푖표푛푠
푝푟표푔푟푎푚 ×
</code></pre>
<pre><code>0. 79 푐푙표푐푘 푐푦푐푙푒푠
푖푛푠푡푟푢푐푡푖표푛 ×
</code></pre>
<pre><code>0. 71 푛푠
푐푙표푐푘 푐푦푐푙푒=
</code></pre>
<pre><code>18. 15 푠푒푐푠
푝푟표푔푟푎푚^
对应地，RISC-V的BOOM实现的性能为：
29. 51 퐵 푖푛푠푡푟푢푐푡푖표푛푠
푝푟표푔푟푎푚 ×
</code></pre>
<pre><code>0. 72 푐푙표푐푘 푐푦푐푙푒푠
푖푛푠푡푟푢푐푡푖표푛 ×
</code></pre>
<pre><code>0. 67 푛푠
푐푙표푐푘 푐푦푐푙푒=
</code></pre>
<pre><code>14. 26 푠푒푐푠
푝푟표푔푟푎푚^
在这个例子中，ARM处理器执行的指令并不比RISC-V处理器少。正如我们将要看到
的，简单的指令也是最常用到的指令，因此ISA的简洁性是最为重要的指标。对于这个程
序，RISC-V处理器在这三个因素中的每一个都获得了近10%的优势，它们加起来导致了近
30%的性能优势。如果更简洁的ISA也能催生出更小的芯片，那么其性价比将非常出色。
</code></pre>
<pre><code>架构和具体实现的分离 架构和实现之间最初的分离可以追溯到 20 世纪 60 年代，具体表现
为：机器语言程序员了解架构后能写出正确的程序，却不一定能保证性能。对于架构师来说，
为了在性能和成本上对某一特定时间的某种实现进行优化，而在ISA中包含某些指令，有时
候是一件有诱惑性的事情。但这样做会给其他实现或者今后的实现带来负担。
延迟分支是MIPS- 32 ISA的一个令人遗憾的例子。条件分支导致流水线执行出现问题，
因为处理器希望下一条要执行的指令总是已经在流水线上，但它不能确定它要的到底是顺序
执行的下一条（如果分支未执行），还是分支目标地址的那一条（如果执行了分支）。对于它
们的第一个五级流水的微处理器，这种优柔寡断可能导致流水线一个时钟周期的阻塞。
MIPS- 32 通过把分支操作重新定义在分支指令的下一条指令执行完之后发生，因此分支指令
的下一条指令永远会被执行。程序员或编译器编写者要做的是把一些有用的指令放入延迟槽。
唉，这个“解决方案”对接下来有着更多流水级（于是在计算出分支结果之前取了更多
的指令）的MIPS- 32 处理器并无益处，反而让MIPS- 32 程序员，编译器编写者，以及处理
器设计者（因为增量ISA需要向后兼容，见1.2节）的生活变得更加艰难。此外，它让MIPS-
</code></pre>
<p>简单的处理器对嵌入
式应用程序有益，因为
它更容易预测执行时
间。微控制器的汇编语
言程序员通常希望保
持精确的时序，因此他
们会保持代码执行所
需的时钟周期数可预
测并可以手动数出来。</p>
<pre><code>最后一个因素是时钟
频率的倒数，因此 1
GHz时钟频率意味着每
个时钟周期的时间为 1
ns（ 1 / 109 ）。
</code></pre>
<pre><code>平均时钟周期数可以
小于 1 ，因为A9和BOOM
[Celio et al.2015]是
所谓的超标量处理器，
每个时钟周期执行多
个指令。
</code></pre>
<pre><code>今天的流水线处理器
使用硬件预测器预测
分支结果，这种方法的
准确度可以超过 90 ％，
并且适用于任何大小
的流水线。他们只需要
一种机制来刷新和重
启流水线。
</code></pre>
<h4 id="32-的代码变得更加难懂参见第-29-页图210"><a class="header" href="#32-的代码变得更加难懂参见第-29-页图210">32 的代码变得更加难懂（参见第 29 页图2.10）。</a></h4>
<h4 id="虽然架构师不该为了有助于某个时间点的某一个特定实现而特意加入某些功能但他们"><a class="header" href="#虽然架构师不该为了有助于某个时间点的某一个特定实现而特意加入某些功能但他们">虽然架构师不该为了有助于某个时间点的某一个特定实现而特意加入某些功能，但他们</a></h4>
<h4 id="也不应该放入阻碍某些实现的功能例如如上一页所述arm--32-和其他一些isa具有"><a class="header" href="#也不应该放入阻碍某些实现的功能例如如上一页所述arm--32-和其他一些isa具有">也不应该放入阻碍某些实现的功能。例如，如上一页所述，ARM- 32 和其他一些ISA具有</a></h4>
<p>Load Multiple指令。这些指令可以提高单发射流水线设计的性能，但会降低多发射流水线的
效率。原因在于这种直截了当的实现排除了与其他指令并行地调度Load Multiple的各个负
载的可能，从而降低了这些处理器的指令吞吐量。</p>
<p>提升空间 随着摩尔定律（Moore’s law）的终结，对性价比进行重大改进的唯一途径是为特
定领域（例如深度学习，增强现实，组合优化，图形等）添加自定义指令。这意味着如今的
ISA必须保留操作码空间以供未来的提升。
在 20 世纪 70 年代和 80 年代，当摩尔定律如日中天的时候，很少有人考虑为未来的提
升节省操作码空间。相反，架构师们重视长地址和立即数字段以减少每个程序执行的指令数
（这是前一页上有关性能的方程式中的第一个因素）。
一个能说明缺少操作码空间的弊端的例子是，ARM- 32 的架构师后来试图通过向以前统
一的 32 位ISA中添加 16 位指令来缩减代码长度，但根本就没有空间了。因此，唯一的解决
方案是先用 16 位指令来创建一个新的ISA（Thumb），然后同时用 16 位指令和 32 位指令来
组成另外一个ISA（Thumb- 2 ），并用一个模式位在两种长度的指令间切换。为了切换模式，
程序员或编译器会跳转到一个最低有效位为 1 的字节地址。这种方法有效的前提是，在正常
的 16 位和 32 位指令中，该位应该是 0 。</p>
<pre><code>图 1.5 ： RV32G ， ARM- 32 ， x86- 32 ， RV32C 和 Thumb- 2 程序的相对大小。最后两个 ISA 是以短代码长度为
目标的。 这些程序是使用 GCC 编译器的 SPEC CPU2006 基准测试。与 RV32C 相比， Thumb- 2 的代码短小
的优势是由于在进入程序时 Load and Store Multiple 的节省。 RV32C 没有包含它们，以保持与 RV32G 指令
的一对一映射， RV32G 省略了 Load and Store Multiple 以降低高端处理器的实现复杂性（见下文）。第七
章介绍了 RV32C 。 RV32G 表示 RISC-V 扩展（ RV32M ， RV32F ， RV32D 和 RV32A ）的流行组合，正确称
为 RV32IMAFD 。 [Waterman 2016]
</code></pre>
<p>程序大小 程序越小，存储它所需的芯片面积就越小(这对于嵌入式设备来说可能是一个巨大
的成本)。实际上，这个问题促使ARM架构师在Thumb和Thumb- 2 ISA中追加了一些更短
的指令。更小的程序还能减少指令缓存的未命中问题，从而节省了功耗（因为片外DRAM
访问比片上SRAM访问耗能更多），也提高了性能。短的代码长度是ISA架构师的目标之
一。</p>
<pre><code>上面提到的ARM- 32 指
令ldmiaeq甚至更复
杂，因为当它分支时它
也可以将ARM- 32 从
Thumb/Thumb- 2 两种模
式中切换。
</code></pre>
<pre><code>x86- 32 ISA的指令可以短至 1 字节，也可以长达 15 字节。你可能会觉得x86的这种可
变字节长度的指令写成的程序一定会比用一些ISA（比如ARM- 32 ，RISC-V）中 32 位定长
指令写的要更短。逻辑上，可变字节长度指令的程序也应该小于仅由 16 位和 32 位定长指令
组成的ISA（比如Thumb- 2 和使用RV32C扩展的RISC-V，参见第七章）。图1.5显示，当
所有指令都是 32 位长时，ARM- 32 和RISC-V代码比x86- 32 长6%到9%，而令人惊讶的是，
x86- 32 代码比同时提供 16 位和 32 位指令的压缩版本（Thumb- 2 和RV32C）大26%。
虽然使用新的可变字节长度指令的新ISA可能会导致比RV32C和Thumb- 2 更短的代
码，但 20 世纪 70 年代设计第一个x86的架构师并不关心这个问题。此外，考虑到增量ISA
（第1.2节）对于向后二进制兼容性的要求，数百条新的x86- 32 指令比预期要长。它们有着
一到两个字节长前缀的负担，这迫使它们使用原始x86的有限的空余操作码空间。
</code></pre>
<pre><code>易于编程 / 编译 / 链接 由于寄存器中的数据访问起来要比存储器中的快得多，编译器在寄存
器分配方面一定要做得很好。这件事在有许多寄存器的时候变得更加容易。鉴于这一点，
ARM- 32 有 16 个寄存器，而x86- 32 只有 8 个。大多数现代ISA（包括RISC-V）都有 32 个
整型寄存器。毫无疑问，有了更多的寄存器，编译器和汇编程序员的工作会更加轻松。
编译器和汇编语言程序员的另一个问题是弄清楚一个代码序列的执行速度。我们可以看
到，一般每条RISC-V指令最多用一个时钟周期执行（忽略缓存未命中）。但正如我们之前
看到的，ARM- 32 和x86- 32 都有需要很多个时钟周期执行（即使所有缓存都命中）的指令。
此外，与ARM- 32 和RISC-V不同，x86- 32 的算术指令操作数可以在存储器中，而不必都在
寄存器里。复杂的指令和位于存储器中的操作数使得处理器的设计人员难以保证性能的可预
测性。
ISA支持位置无关代码（PIC）非常有用，因为这样它就支持动态链接（参见第3.5节），
原因在于在不同程序中共享库代码可以驻留在不同地址。PC相关的分支和数据寻址是PIC
的福音。虽然几乎所有的ISA都提供与PC相关的分支，但x86- 32 和MIPS- 32 省略了与PC
相关的数据寻址。
</code></pre>
<h3 id="14-全书的总览"><a class="header" href="#14-全书的总览">1.4 全书的总览</a></h3>
<h4 id="本书假设您在risc-v之前已经了解过其他指令集如果没有请查看我们基于"><a class="header" href="#本书假设您在risc-v之前已经了解过其他指令集如果没有请查看我们基于">本书假设您在RISC-V之前已经了解过其他指令集。如果没有，请查看我们基于</a></h4>
<pre><code>RISC-V的相关入门架构书[Patterson和Hennessy 2017]。
第二章介绍了RV32I，它是RISC-V固定不变的基础整数指令集，是RISC-V的核心内
容。第三章解释了第二章中没有介绍的其余RISC-V汇编语言内容，包括调用约定和一些
</code></pre>
<pre><code>补充说明：ARM- 32 ，MIPS- 32 和x 86 - 32
这是一个可选部分，如果对某个主题感兴趣的话，读者可以深入研究它们，但它们对于理解
本书的其余部分并不必要。例如，我们对于ISA的称呼不是官方名称。 32 位地址ARM ISA
有许多版本，第一个诞生于 1986 年，最新版本在 2005 年出现，称为ARMv7。ARM- 32 通
常是指ARMv7 ISA。MIPS也有许多 32 位版本，但我们指的是原版，称为MIPS I（“MIPS32”
是一个更新的，不同于我们称之为MIPS- 32 的ISA）。英特尔的第一个 16 位地址架构是 1978
年的 8086 ，其中80386 ISA在 1985 年扩展到 32 位地址。我们的x86- 32 表示法通常是指IA-
32 ，它的x86 ISA的 32 位地址版本。鉴于这些ISA的数不清的变体的存在，我们发现我们
的非标准术语反而最不容易混淆。
</code></pre>
<p>例如一个 15 字节的
x86- 32 指令是lock
add dword ptr ds：
[esi+ecx*4+0x1234
5678]，0xefcdab89。
它汇编成（十六进制）：
67 66 f0 3e 81 84 8e
78 56 34 12 89 ab cd
ef。 最后 8 个字节是 2
个地址，前 7 个字节指
定原子的存储器操作，
加操作， 32 位数据，数
据段寄存器， 2 个地址
寄存器和缩放索引寻
址模式。 1 字节指令的
例子是汇编成 40 的指
令inc eax。</p>
<h4 id="用于链接的巧妙技巧汇编语言包括所有符合规则的risc-v指令和一些risc-v指令集外"><a class="header" href="#用于链接的巧妙技巧汇编语言包括所有符合规则的risc-v指令和一些risc-v指令集外">用于链接的巧妙技巧。汇编语言包括所有符合规则的RISC-V指令和一些RISC-V指令集外</a></h4>
<h4 id="的有用指令这些伪指令是实际指令的巧妙变体它们简化了编写汇编语言程序的过程"><a class="header" href="#的有用指令这些伪指令是实际指令的巧妙变体它们简化了编写汇编语言程序的过程">的有用指令。这些伪指令是实际指令的巧妙变体，它们简化了编写汇编语言程序的过程，</a></h4>
<h4 id="同时避免了使isa复杂化"><a class="header" href="#同时避免了使isa复杂化">同时避免了使ISA复杂化。</a></h4>
<h4 id="接下来的三章阐述了risc-v的标准扩展当它们添加到riv32i中的时候我们统称"><a class="header" href="#接下来的三章阐述了risc-v的标准扩展当它们添加到riv32i中的时候我们统称">接下来的三章阐述了RISC-V的标准扩展。当它们添加到RIV32I中的时候，我们统称</a></h4>
<h4 id="rv32gg代表一般"><a class="header" href="#rv32gg代表一般">RV32G（G代表一般）：</a></h4>
<h4 id="-第四章乘法和除法rv32m"><a class="header" href="#-第四章乘法和除法rv32m">⚫ 第四章：乘法和除法（RV32M）</a></h4>
<h4 id="-第五章浮点操作rv32f和rv32d"><a class="header" href="#-第五章浮点操作rv32f和rv32d">⚫ 第五章：浮点操作（RV32F和RV32D）</a></h4>
<h4 id="-第六章原子操作rv32a"><a class="header" href="#-第六章原子操作rv32a">⚫ 第六章：原子操作（RV32A）</a></h4>
<h4 id="第-3-页和第-4-页的risc-v参考卡是本书中所有risc-v指令rv32grv64g和"><a class="header" href="#第-3-页和第-4-页的risc-v参考卡是本书中所有risc-v指令rv32grv64g和">第 3 页和第 4 页的RISC-V“参考卡”是本书中所有RISC-V指令（RV32G，RV64G和</a></h4>
<h4 id="rv32--64v的摘要"><a class="header" href="#rv32--64v的摘要">RV32 / 64V）的摘要。</a></h4>
<h4 id="第七章介绍了可选的压缩扩展rv32c它是risc-v优雅性的一个绝佳例子通过把"><a class="header" href="#第七章介绍了可选的压缩扩展rv32c它是risc-v优雅性的一个绝佳例子通过把">第七章介绍了可选的压缩扩展RV32C，它是RISC-V优雅性的一个绝佳例子。通过把</a></h4>
<h4 id="16-位指令限制为现有-32-位rv32g指令的短版本它们几乎是没有代价的汇编程序可以"><a class="header" href="#16-位指令限制为现有-32-位rv32g指令的短版本它们几乎是没有代价的汇编程序可以">16 位指令限制为现有 32 位RV32G指令的短版本，它们几乎是没有代价的。汇编程序可以</a></h4>
<h4 id="选择指令大小这使得汇编语言程序员和编译器忘记rv32c将-16-位rv32c指令转换成"><a class="header" href="#选择指令大小这使得汇编语言程序员和编译器忘记rv32c将-16-位rv32c指令转换成">选择指令大小，这使得汇编语言程序员和编译器忘记RV32C。将 16 位RV32C指令转换成</a></h4>
<h4 id="32-位rv32g指令的硬件解码器只需要-400-个门这即使在最简单的risc-v实现中也只占"><a class="header" href="#32-位rv32g指令的硬件解码器只需要-400-个门这即使在最简单的risc-v实现中也只占">32 位RV32G指令的硬件解码器只需要 400 个门，这即使在最简单的RISC-V实现中也只占</a></h4>
<h4 id="百分之几"><a class="header" href="#百分之几">百分之几。</a></h4>
<h4 id="第八章介绍了向量扩展rv32v当与众多强大的单指令多数据-simd-指令arm-"><a class="header" href="#第八章介绍了向量扩展rv32v当与众多强大的单指令多数据-simd-指令arm-">第八章介绍了向量扩展RV32V。当与众多强大的单指令多数据（ SIMD ）指令（ARM-</a></h4>
<p>32 ，MIPS- 32 ，x86- 32 ）相比时，向量指令成为了ISA优雅性的另一个例证。实际上，图
1.2中添加到x86- 32 的数百条指令都是SIMD，还有数百条指令即将问世。RV32V甚至比
大多数向量ISA更简单，因为它通过向量寄存器指定数据类型和长度，而不是将这两者嵌
入到操作码中。RV32V也许是大家从传统的基于SIMD的ISA转到RISC-V的最为可能的
原因。
第九章展示了RV64G，它是RISC-V的 64 位地址版本。正如该章节所说的那样，
RISC-V的架构师只需要拓宽寄存器，并加入一些字、双字或长版的RV32G指令，就可以
把地址从 32 位扩展为 64 位。
第十章介绍了系统指令，说明了RISC-V如何处理分页以及机器、用户和监管者权限
模式。
最后一章简要介绍了RISC-V基金会目前正在考虑增加的其它扩展。
接下来是本书最大的一个部分，附录A。它是按字母表顺序排列的指令集摘要。它定
义了完整的RISC-V ISA以及上面提到的所有扩展，还有大概 50 页的全部伪指令。这是
RISC-V简洁性的证明。
这本书的最后一部分是索引。</p>
<h3 id="15-结束语"><a class="header" href="#15-结束语">1.5 结束语</a></h3>
<pre><code>用形式逻辑的方法可以很容易看出，存在某种[指令集]在理论上足以控制和执行任意顺序的操作......
从当前的观点出发，选择一个[指令集]时考虑得更多更实际的问题是：[指令集]要求的设备简单性，
在实际重要的问题中有明确应用和解决该类问题的速度。
——冯·诺伊曼（von Neumann）等， 1947
</code></pre>
<p>RISC-V是一个最新的，清晰的，简约的，开源的ISA，它以过去ISA所犯过的错误为
鉴。RISC-V架构师的目标是让它在从最小的到最快的所有计算设备上都能有效工作。遵循
冯诺依曼 70 年前的建议，这个ISA强调简洁性来保证它的低成本，同时有着大量的寄存
器和透明的指令执行速度，从而帮助编译器和汇编语言程序员将实际的重要问题转换为适</p>
<pre><code>参考卡也被称为绿色
卡片，这来源于 20 世纪
60 年代的ISA的单页纸
板摘要的背景颜色的
阴影。为了易读性，我
们将背景保持白色，而
不是延续历史而使其
为绿色。
</code></pre>
<pre><code>冯·诺伊曼先前版本的
精心编写的报告非常
有影响力，以至于这种
计 算 机 通 常 被 称 为
冯·诺伊曼架构，尽管
这份报告是基于其他
人的工作。它是在第一
台存储程序计算机开
始运行的三年前编写
的！
</code></pre>
<h4 id="当的高效代码"><a class="header" href="#当的高效代码">当的高效代码。</a></h4>
<pre><code>图 1.6 ： ISA 手册的页数和字数来自 [Waterman and Asanovi'c 2017a] ， [Waterman and Asanovi'c 2017b] ，
[Intel Corporation 2016] ， [ARM Ltd. 2014] 。读完需要的时间按每分钟读 200 个单词，每周读 40 小时计
算。 基于 [Baumann 2017] 的图 1 的一部分。
</code></pre>
<p>复杂度的一个标准是文档的大小。图1.6显示了以页数和单词数衡量的RISC-V、
ARM- 32 和x86- 32 指令集手册的大小。如果你把读手册作为全职工作，每天 8 小时，每周
5 天，那么需要半个月读完ARM- 32 手册，需要整整一个月读完x86- 32 手册。有这样的复
杂程度，大概没有一个人能完全理解ARM- 32 或x86- 32 。用这种常识来度量，RISC-V的</p>
<p>复杂度只有ARM- 32 的 121 ,x86- 32 的 110 到 301 。实际上，包含所有扩展的RISC-V ISA摘要只有</p>
<p>两页（参见参考卡）。
这个袖珍的，开源的ISA于 2011 年推出，现在由一个基金会提供支持。该基金会通过
长期讨论后严格依据技术理由添加可选扩展的方式来改进它。开源性让RISC-V的免费
的、共享的实现成为可能，从而降低了成本，也减少了将不为人知的邪恶秘密隐藏在处理
器之中的可能性。
然而，只有硬件不能组成一个系统。软件开发成本可能使硬件开发成本相形见绌。因
此虽然稳定的硬件很重要，但稳定的软件更甚于此。这些软件需要包括操作系统，引导加
载程序，参考软件和大众化的软件工具。基金会保证整个ISA的稳定性，而固定不变的基
础指令集意味着核心的RV32I作为软件栈的目标永远不会改变。通过它的普适性和开源
性，RISC-V可以挑战主流专有ISA的主导地位。
优雅是一个很少应用于ISA的词，但在阅读本书后，你可能会同意我们把它用于
RISC-V。我们将用页边的蒙娜丽莎图标来凸显我们认为体现出优雅性的特征。</p>
<h3 id="16-扩展阅读"><a class="header" href="#16-扩展阅读">1.6 扩展阅读</a></h3>
<p>ARM Ltd. ARM Architecture Reference Manual: ARMv7-A and ARMv7-R Edition, 2014.
URL <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0406c/.">http://infocenter.arm.com/help/topic/com.arm.doc.ddi0406c/.</a></p>
<p>A. Baumann. Hardware is the new software. In Proceedings of the 16th Workshop on Hot
Topics in Operating Systems, pages 132–137. ACM, 2017.</p>
<p>C. Celio, D. Patterson, and K. Asanovic. The Berkeley Out-of-Order Machine (BOOM): an
industry-competitive, synthesizable, parameterized RISC-V processor. Tech. Rep. UCB/EECS-
2015 <em>–</em> 167, EECS Department, University of California, Berkeley, 2015.</p>
<p>S. Gal-On and M. Levy. Exploring CoreMark - a benchmark maximizing simplicity and
efficacy. The Embedded Microprocessor Benchmark Consortium, 2012.</p>
<p>Intel Corporation. Intel 64 and IA-32 Architectures Software <em>Developer’s Manual, Volume</em>
2: Instruction Set Reference. September 2016.</p>
<p>S. P. Morse. The Intel 8086 chip and the future of microprocessor design. Computer, 50(4): 8–9,</p>
<ol start="2017">
<li></li>
</ol>
<p>D. A. Patterson and J. L. Hennessy. Computer Organization and Design RISC-V Edition: The
Hardware Software Interface. Morgan Kaufmann, 2017.</p>
<p>S. Rodgers and R. Uhlig. X86: Approaching 40 and still going strong, 2017.</p>
<p>J. L. von Neumann, A.W. Burks, and H. H. Goldstine. Preliminary discussion of the logical design
of an electronic computing instrument. Report to the U.S. Army Ordnance Department, 1947.</p>
<p>A. Waterman. Design of the RISC-V Instruction Set Architecture. PhD thesis, EECS Department,
University of California, Berkeley, Jan 2016. URL
<a href="http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-">http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-</a> 2016 - 1.html.</p>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual Volume II:
Privileged Architecture Version 1.10. May 2017a. URL https://riscv.org/specifications/privileged-
isa/.</p>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I: User-
Level ISA, Version 2.2. May 2017b. URL https://riscv.org/specifications/.</p>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<h2 id="第二章-rv32irisc-v基础整数指令集"><a class="header" href="#第二章-rv32irisc-v基础整数指令集">第二章 RV32I：RISC-V基础整数指令集</a></h2>
<pre><code>...提升计算性能并且让用户能切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不
到的特性将不会被实现在硬件上...
——Frances Elizabeth “Fran” Allen, 1981
</code></pre>
<h3 id="21-导言"><a class="header" href="#21-导言">2.1 导言</a></h3>
<h4 id="图21是rv32i基础指令集的一页图形表示对于每幅图将有下划线的字母从左到"><a class="header" href="#图21是rv32i基础指令集的一页图形表示对于每幅图将有下划线的字母从左到">图2.1是RV32I基础指令集的一页图形表示。对于每幅图，将有下划线的字母从左到</a></h4>
<h4 id="右连接起来即可组成完整的rv32i指令集对于每一个图集合标志内列举了指令的"><a class="header" href="#右连接起来即可组成完整的rv32i指令集对于每一个图集合标志内列举了指令的">右连接起来，即可组成完整的RV32I指令集。对于每一个图，集合标志{}内列举了指令的</a></h4>
<h4 id="所有变体变体用加下划线的字母或下划线字符_表示特别的下划线字符_表示对于此"><a class="header" href="#所有变体变体用加下划线的字母或下划线字符_表示特别的下划线字符_表示对于此">所有变体，变体用加下划线的字母或下划线字符_表示。特别的，下划线字符_表示对于此</a></h4>
<pre><code>指令变体不需用字符表示。例如，下图表示了这四个RV32I指令：slt，slti，sltu，sltiu:
</code></pre>
<h4 id="我们使用这些图下面几章的第一个图旨在对本章的指令给出一个进行快速深入的"><a class="header" href="#我们使用这些图下面几章的第一个图旨在对本章的指令给出一个进行快速深入的">我们使用这些图（下面几章的第一个图），旨在对本章的指令给出一个进行快速、深入的</a></h4>
<h4 id="概述"><a class="header" href="#概述">概述。</a></h4>
<h3 id="22-rv32i指令格式"><a class="header" href="#22-rv32i指令格式">2.2 RV32I指令格式</a></h3>
<h4 id="图22显示了六种基本指令格式分别是用于寄存器-寄存器操作的r类型指令用"><a class="header" href="#图22显示了六种基本指令格式分别是用于寄存器-寄存器操作的r类型指令用">图2.2显示了六种基本指令格式，分别是：用于寄存器-寄存器操作的R类型指令，用</a></h4>
<pre><code>于短立即数和访存load操作的I型指令，用于访存store操作的S型指令，用于条件跳转操
作的B类型指令，用于长立即数的U型指令和用于无条件跳转的J型指令。图 2 .3使用图
2.2的指令格式列出了图 2 .1中出现的所有RV32I指令的操作码。
即使是指令格式也能从一些方面说明RISC-V 更简洁的ISA设计能提高提高性能功耗
比。首先，指令只有六种格式，并且所有的指令都是 32 位长，这简化了指令解码。ARM-
32 ，还有更典型的x86- 32 都有许多不同的指令格式，使得解码部件在低端实现中偏昂贵，
在中高端处理器设计中容易带来性能挑战。第二，RISC-V指令提供三个寄存器操作数，而
不是像x 86 - 32 一样，让源操作数和目的操作数共享一个字段。当一个操作天然就需要有三
个不同的操作数，但是ISA只提供了两个操作数时，编译器或者汇编程序程序员就需要多
使用一条move（搬运）指令，来保存目的寄存器的值。第三，在RISC-V中对于所有指
令，要读写的寄存器的标识符总是在同一位置，意味着在解码指令之前，就可以先开始访
问寄存器。在许多其他的ISA中，某些指令字段在部分指令中被重用作为源目的地，在其
他指令中又被作为目的操作数（例如，ARM- 32 和MIPS- 32 ）。因此，为了取出正确的指
令字段，我们需要时序本就可能紧张的解码路径上添加额外的解码逻辑，使得解码路径的
时序更为紧张。第四，这些格式的立即数字段总是符号扩展，符号位总是在指令中最高
位。这意味着可能成为关键路径的立即数符号扩展，可以在指令解码之前进行。
</code></pre>
<pre><code>( 1932 - )被授予图灵
奖主要是因为她在
优化编译器方面的
工作。图灵奖是计
算机科学的最高奖
项。
</code></pre>
<p>立即数的符号扩展甚至
有助于逻辑指令。例如，
x＆0xfffffff0在RISC-V
中只需要一条andi指
令，但在MIPS- 32 中需
要两条指令（addiu用
于加载常量，然后是
and），因为MIPS零扩
展逻辑立即数。ARM- 32
需要添加一个额外的指
令bic，它执行rx＆
immediate以补偿零扩
展的立即数.</p>
<p>图 <strong>2.1</strong> ： <strong>RV32I</strong> 指令图示。把带下划线的字母从左到右连接就组成了 <strong>RV32I</strong> 指令。花括号 <strong>{}</strong> 表示集合中垂
直方向上的每个项目都是指令的不同变体。集合中的下划线 <strong>_</strong> 意味着不包含这个字母的也是一个指令名
称。例如，左上角附近的符号表示以下六个指令：and，or，xor，andi，ori，xori。</p>
<pre><code>图 2.2 ： RISC-V 指令格式。我们用生成的立即数值中的位置（而不是通常的指令立即数域中的位置）
(imm[ x ]) 标记每个立即数子域。第十章解释了控制状态寄存器指令使用 I 型格式的稍微不同的做法。（本
图基于 Waterman 和 Asanovi'c 2017 的图 2.2 ）。
</code></pre>
<p>31 25 24 20 19 15 14^ 12 11 7 6 0
imm[31:12] rd 0110111 U lui
imm[31:12] rd 0010111 U auipc
imm[20|10:1|11|19:12] rd 1101111 J jal
imm[11:0] rs1 000 rd 1100111 I jalr
imm[12|10:5] rs2 rs1 000 imm[4:1|11] 1100011 B beq
imm[12|10:5] rs2 rs1 001 imm[4:1|11] 1100011 B bne
imm[12|10:5] rs2 rs1 100 imm[4:1|11] 1100011 B blt
imm[12|10:5] rs2 rs1 101 imm[4:1|11] 1100011 B bge
imm[12|10:5] rs2 rs1 110 imm[4:1|11] 1100011 B bltu
imm[12|10:5] rs2 rs1 111 imm[4:1|11] 1100011 B bgeu
imm[11:0] rs1 000 rd 0000011 I lb
imm[11:0] rs1 001 rd 0000011 I lh
imm[11:0] rs1 010 rd 0000011 I lw
imm[11:0] rs1 100 rd 0000011 I lbu
imm[11:0] rs1 101 rd 0000011 I lhu
imm[11:5] rs2 rs1 000 imm[4:0] 0100011 S sb
imm[11:5] rs2 rs1 001 imm[4:0] 0100011 S sh
imm[11:5] rs2 rs1 010 imm[4:0] 0100011 S sw
imm[11:0] rs1 000 rd 0010011 I addi
imm[11:0] rs1 010 rd 0010011 I slti
imm[11:0] rs1 011 rd 0010011 I sltiu
imm[11:0] rs1 100 rd 0010011 I xori
imm[11:0] rs1 110 rd 0010011 I ori
imm[11:0] rs1 111 rd 0010011 I andi
0000000 shamt rs1 001 rd 0010011 I slli
0000000 shamt rs1 101 rd 0010011 I srli
0100000 shamt rs1 101 rd 0010011 I srai
0000000 rs2 rs1 000 rd 0110011 R add
0100000 rs2 rs1 000 rd 0110011 R sub
0000000 rs2 rs1 001 rd 0110011 R sll
0000000 rs2 rs1 010 rd 0110011 R slt
0000000 rs2 rs1 011 rd 0110011 Rsltu
0000000 rs2 rs1 100 rd 0110011 R xor
0000000 rs2 rs1 101 rd 0110011 R srl
0100000 rs2 rs1 101 rd 0110011 R sra
0000000 rs2 rs1 110 rd 0110011 R or
0000000 rs2 rs1 111 rd 0110011 R and
0000 pred succ 00000 000 00000 0001111 I fence
0000 0000 0000 00000 001 00000 0001111 I fence.i
000000000000 00000 00 00000 1110011 I ecall
000000000000 00000 000 00000 1110011 I ebreak
csr rs1 001 rd 1110011 I csrrw
csr rs1 010 rd 1110011 I csrrs
csr rs1 011 rd 1110011 I csrrc
csr zimm 101 rd 1110011 I csrrwi
csr zimm 110 rd 1110011 I cssrrsi
csr zimm 111 rd 1110011 I csrrci
图 <strong>2.3</strong> ： <strong>RV32I</strong> 带有指令布局，操作码，格式类型和名称的操作码映射。（此图基于 <strong>[Waterman and
Asanovi'c 2017]</strong> 的表 <strong>19.2</strong> 。）</p>
<h4 id="为了帮助程序员所有位全部是-0-是非法的rv32i指令因此-试图跳转到被清零的"><a class="header" href="#为了帮助程序员所有位全部是-0-是非法的rv32i指令因此-试图跳转到被清零的">为了帮助程序员，所有位全部是 0 是非法的RV32I指令。因此, 试图跳转到被清零的</a></h4>
<h4 id="内存区域的错误跳转将会立即触发异常这可以帮助调试类似地所有位全部是-1-的指"><a class="header" href="#内存区域的错误跳转将会立即触发异常这可以帮助调试类似地所有位全部是-1-的指">内存区域的错误跳转将会立即触发异常，这可以帮助调试。类似地，所有位全部是 1 的指</a></h4>
<h4 id="令也是非法指令它将捕获其他常见的错误诸如未编程的非易失性内存设备断开连接"><a class="header" href="#令也是非法指令它将捕获其他常见的错误诸如未编程的非易失性内存设备断开连接">令也是非法指令，它将捕获其他常见的错误，诸如未编程的非易失性内存设备、断开连接</a></h4>
<h4 id="的内存总线或者坏掉的内存芯片"><a class="header" href="#的内存总线或者坏掉的内存芯片">的内存总线或者坏掉的内存芯片。</a></h4>
<h4 id="为了给isa扩展留出足够的空间最基础的rv32i指令集只使用了-32-位指令字中的"><a class="header" href="#为了给isa扩展留出足够的空间最基础的rv32i指令集只使用了-32-位指令字中的">为了给ISA扩展留出足够的空间，最基础的RV32I指令集只使用了 32 位指令字中的</a></h4>
<h4 id="编码空间的不到八分之一架构师们也仔细挑选了rv32i操作码使拥有共同数据通路的"><a class="header" href="#编码空间的不到八分之一架构师们也仔细挑选了rv32i操作码使拥有共同数据通路的">编码空间的不到八分之一。架构师们也仔细挑选了RV32I操作码，使拥有共同数据通路的</a></h4>
<h4 id="指令的操作码位有尽可能多的位的值是一样的这简化了控制逻辑最后当我们看到b"><a class="header" href="#指令的操作码位有尽可能多的位的值是一样的这简化了控制逻辑最后当我们看到b">指令的操作码位有尽可能多的位的值是一样的，这简化了控制逻辑。最后,当我们看到，B</a></h4>
<h4 id="和j格式的分支和跳转地址必须向左移动-1-位以将地址乘以-2-从而给予分支和跳转指令"><a class="header" href="#和j格式的分支和跳转地址必须向左移动-1-位以将地址乘以-2-从而给予分支和跳转指令">和J格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2 ，从而给予分支和跳转指令</a></h4>
<h4 id="更大的跳转范围risc-v将立即数中的位从自然排布进行了一些移位轮换将指令信号的"><a class="header" href="#更大的跳转范围risc-v将立即数中的位从自然排布进行了一些移位轮换将指令信号的">更大的跳转范围。RISC-V将立即数中的位从自然排布进行了一些移位轮换，将指令信号的</a></h4>
<h4 id="扇出和立即数多路复用的成本降低了近两倍这也简化了低端实现中的数据通路逻辑"><a class="header" href="#扇出和立即数多路复用的成本降低了近两倍这也简化了低端实现中的数据通路逻辑">扇出和立即数多路复用的成本降低了近两倍，这也简化了低端实现中的数据通路逻辑。</a></h4>
<h4 id="有什么不同之处在这一章和后面的章节的结束部分我们将描述risc-v与其他指"><a class="header" href="#有什么不同之处在这一章和后面的章节的结束部分我们将描述risc-v与其他指">有什么不同之处？在这一章和后面的章节的结束部分，我们将描述RISC-V与其他指</a></h4>
<h4 id="令集的不同之处这种对比通常是描述相比于其他指令集risc-v少了什么省略什么特"><a class="header" href="#令集的不同之处这种对比通常是描述相比于其他指令集risc-v少了什么省略什么特">令集的不同之处。这种对比通常是描述相比于其他指令集，RISC-V少了什么。省略什么特</a></h4>
<h4 id="性和包括什么特性一样都能体现架构师的精心设计"><a class="header" href="#性和包括什么特性一样都能体现架构师的精心设计">性和包括什么特性一样，都能体现架构师的精心设计。</a></h4>
<h4 id="arm--32-指令集-12-位的立即字段不仅仅是一个常量而是一个函数的输入此函数"><a class="header" href="#arm--32-指令集-12-位的立即字段不仅仅是一个常量而是一个函数的输入此函数">ARM- 32 指令集 12 位的立即字段不仅仅是一个常量，而是一个函数的输入，此函数</a></h4>
<h4 id="根据-12-位立即数的输入来产生一个常量-8-位被零扩展到全宽度然后被循环右移右移"><a class="header" href="#根据-12-位立即数的输入来产生一个常量-8-位被零扩展到全宽度然后被循环右移右移">根据 12 位立即数的输入来产生一个常量： 8 位被零扩展到全宽度，然后被循环右移。右移</a></h4>
<h4 id="的位数是-12-位立即数中剩余-4-位的值乘-2-设计者希望在-12-位中编码更多有用的常数来"><a class="header" href="#的位数是-12-位立即数中剩余-4-位的值乘-2-设计者希望在-12-位中编码更多有用的常数来">的位数是 12 位立即数中剩余 4 位的值乘 2 。设计者希望在 12 位中编码更多有用的常数来</a></h4>
<h4 id="减少执行指令的数量在大多数指令格式中arm--32-也将十分宝贵的四位编码空间拿出"><a class="header" href="#减少执行指令的数量在大多数指令格式中arm--32-也将十分宝贵的四位编码空间拿出">减少执行指令的数量。在大多数指令格式中，ARM- 32 也将十分宝贵的四位编码空间拿出</a></h4>
<h4 id="来专门用于条件执行这些条件执行指令不仅使用频率低而且增加了乱序处理器的复杂"><a class="header" href="#来专门用于条件执行这些条件执行指令不仅使用频率低而且增加了乱序处理器的复杂">来专门用于条件执行。这些条件执行指令不仅使用频率低而且增加了乱序处理器的复杂</a></h4>
<h4 id="性"><a class="header" href="#性">性。</a></h4>
<h3 id="23-rv32i寄存器"><a class="header" href="#23-rv32i寄存器">2.3 RV32I寄存器</a></h3>
<h4 id="图-4-列出了rv32i寄存器以及由risc-v-应用程序二进制接口abi所定义的寄存"><a class="header" href="#图-4-列出了rv32i寄存器以及由risc-v-应用程序二进制接口abi所定义的寄存">图 4 列出了RV32I寄存器以及由RISC-V 应用程序二进制接口（ABI）所定义的寄存</a></h4>
<h4 id="器名称在我们的示例代码中我们将使用abi名称使它们更容易阅读为了满足汇编"><a class="header" href="#器名称在我们的示例代码中我们将使用abi名称使它们更容易阅读为了满足汇编">器名称。在我们的示例代码中，我们将使用ABI名称，使它们更容易阅读。为了满足汇编</a></h4>
<p>语言程序员和编译器编写者，RV32I有 31 寄存器加上一个值恒为 0 的x0寄存器。与之相
比，ARM- 32 只有 16 个寄存器，x86- 32 甚至只有 8 个寄存器。
有什么不同之处？为常量 0 单独分配一个寄存器是RISC-V ISA能如此简单的一个很
大的因素。第 3 章的第 36 页的图 3 给出了许多ARM- 32 和x86- 32 的原生指令操作，这两
个指令集中没有零寄存器。我们可以用RV32I指令完成功能相同的操作，只需使用零寄存
器作为操作数。</p>
<pre><code>补充说明：乱序执行处理器
这是一种高速的、流水化的处理器。它们一有机会就执行指令，而不是在按照程序顺序。这
种处理器的一个关键特性是寄存器重命名，把程序中的寄存器名称映射到大量的内部物理
寄存器。条件执行的问题是不管条件是否成立，都必须给这些指令中的寄存器分配相应的物
理寄存器。但内部物理寄存器的可用性是影响乱序处理器的关键性能资源。
</code></pre>
<pre><code>补充说明：B类型和J类型指令
如下所述，分支指令（B类型）的立即数字段在S类型的基础上旋转了 1 位。跳转指令（J
类型）的直接字段在U类型的基础上旋转了 12 位。因此,RISC-V实际上只有四种基本格式，
但我们可以保守地认为它有六种格式。
</code></pre>
<pre><code>RISC-V实现对可选扩
展使用相同的操作码，
例如RV32M，RV32F
等。针对特定处理器的
非标准扩展只能使用
RISC-V中的保留操作
码空间。
</code></pre>
<h4 id="程序计数器pc是arm--32-的-16-个寄存器之一这意味着任何改变寄存器的指令"><a class="header" href="#程序计数器pc是arm--32-的-16-个寄存器之一这意味着任何改变寄存器的指令">程序计数器（PC）是ARM- 32 的 16 个寄存器之一，这意味着任何改变寄存器的指令</a></h4>
<h4 id="都有可能导致分支跳转pc作为一个寄存器使硬件分支预测变得复杂因为在典型的isa"><a class="header" href="#都有可能导致分支跳转pc作为一个寄存器使硬件分支预测变得复杂因为在典型的isa">都有可能导致分支跳转。PC作为一个寄存器使硬件分支预测变得复杂，因为在典型的ISA</a></h4>
<h4 id="中仅10-20的指令为分支指令而在arm--32-中任何指令都有可能是分支指令而"><a class="header" href="#中仅10-20的指令为分支指令而在arm--32-中任何指令都有可能是分支指令而">中，仅10%-20%的指令为分支指令，而在ARM- 32 中，任何指令都有可能是分支指令。而</a></h4>
<h4 id="分支预测的准确性对于良好的流水线性能至关重要另外将pc作为一个寄存器也意味着"><a class="header" href="#分支预测的准确性对于良好的流水线性能至关重要另外将pc作为一个寄存器也意味着">分支预测的准确性对于良好的流水线性能至关重要。另外将PC作为一个寄存器也意味着</a></h4>
<h4 id="可用的通用寄存器少了一个"><a class="header" href="#可用的通用寄存器少了一个">可用的通用寄存器少了一个。</a></h4>
<h3 id="24-rv32i整数计算"><a class="header" href="#24-rv32i整数计算">2.4 RV32I整数计算</a></h3>
<h4 id="附录a给出了所有risc-v指令的细节信息包括格式和操作码在本节以及接下来"><a class="header" href="#附录a给出了所有risc-v指令的细节信息包括格式和操作码在本节以及接下来">附录A给出了所有RISC-V指令的细节信息，包括格式和操作码。在本节以及接下来</a></h4>
<h4 id="的章节的类似小节中我们将给出isa的一些概述这能够让有基础的汇编语言程序员了"><a class="header" href="#的章节的类似小节中我们将给出isa的一些概述这能够让有基础的汇编语言程序员了">的章节的类似小节中，我们将给出ISA的一些概述。这能够让有基础的汇编语言程序员了</a></h4>
<h4 id="解risc-v同时也顺便说明risc-v的特性如何满足第一章中阐述的七个isa指标"><a class="header" href="#解risc-v同时也顺便说明risc-v的特性如何满足第一章中阐述的七个isa指标">解RISC-V，同时也顺便说明RISC-V的特性如何满足第一章中阐述的七个ISA指标。</a></h4>
<pre><code>简单的算术指令（add, sub）、逻辑指令（and, or, xor），以及图2.1中的移位指令
（sll, srl, sra）和其他ISA差不多。他们从寄存器读取两个 32 位的值，并将 32 位结果写
入目标寄存器。RV32I还提供了这些指令的立即数版本。和ARM- 32 不同，立即数总是进
行符号扩展，这样子如果需要，我们可以用立即数表示负数，正因为如此，我们并不需要
一个立即数版本的sub。
程序可以根据比较结果生成布尔值。为应对这种使用场景下，RV32I提供一个当小于
时置位的指令。如果第一个操作数小于第二个操作数，它将目标寄存器设置为 1 ，否则为
0 。不出所料，对这个指令，有一个有符号版本（slt）和无符号版本（sltu），分别用于处
理有符号和无符号整数比较。相应的，上述两条指令也有立即数版本的（slti，sltiu）。正
如我们将要看到的，虽然RV32I分支指令可以检查两个寄存器之间的所有关系，但一些条
件表达式涉及多对寄存器之间的关系。对于这些表达式，编译器或汇编语言程序员可以将
slt以及与或异或等逻辑指令组合使用来解决更复杂的条件表达式。
图2.1剩下的两条整数计算指令主要用于构造大的常量数值和链接。加载立即数到高
位（lui）将 20 位常量加载到寄存器的高 20 位。接着便可以使用标准的立即指令来创建 32
位常量。这样子，仅使用 2 条 32 位RV32I指令，便可构造一个 32 位常量。向PC高位加
上立即数（auipc）让我们仅用两条指令，便可以基于当前PC以任意偏移量转移控制流或
者访问数据。将auipc中的 20 位立即数与jalr（参见下面）中 12 位立即数的组合，我们
可以将执行流转移到任何 32 位PC相对地址。而auipc加上普通加载或存储指令中的 12
位立即数偏移量，使我们可以访问任何 32 位PC相对地址的数据。
</code></pre>
<pre><code>有什么不同之处？首先，RISC-V中没有字节或半字宽度的整数计算操作。操作始终
是以完整的寄存器宽度。内存访问需要的能量比算术运算高几个数量级。因此低宽度的数
据访问可以节省大量的能量，但低宽度的运算不会。ARM- 32 具有一个不寻常的功能，对
于大多数算术逻辑运算中的一个操作数，你可以选择对它进行移位。尽管这些指令的使用
频率很低，但它使数据路径和数据通路更加复杂。与此相对的是，RV32I提供了单独的移
位指令。
RV32I也不包含乘法和除法，它们包含在可选的RV32M扩展中（参见第 4 章）。与
ARM- 32 和x86- 32 不同，即使处理器没有添加乘除法扩展，完整的RISC-V软件栈也可以
运行，这可以缩小嵌入式芯片的面积。MIPS- 32 汇编程序可能用一系列移位以及加法指令
来替换乘法，以提高性能，这可能会使程序员看到处理器执行了汇编程序中没有的指令，
进而造成混淆。RV32I可以忽略了这些特性：循环移位指令和整数算术溢出检测，这两个
特性都可以用若干条RV32I指令来实现（参见第2.6节）。
</code></pre>
<p>目前除最便宜的处理
器以外的所有处理器
都使用流水线来获得
良好的性能。与工业装
配线一样，它们通过一
次执行多条指令来获
得更高的吞吐量。为了
实现这一目标，处理器
可以预测分支结果，这
个操作的准确度可以
超过 90 ％。若进行了
错误预测，指令会重新
执行。早期的微处理器
有一个 5 级流水线，这
意味着 5 条指令并行
执行。最近的处理器有
10 多个流水级。</p>
<p>图 <strong>2.4</strong> ： <strong>RV32I</strong> 的寄存器。第 <strong>3</strong> 章解释了 <strong>RISC-V</strong> 调用约定，各种指针（ <strong>sp</strong> ， <strong>gp</strong> ， <strong>tp</strong> ， <strong>fp</strong> ），保存寄存器
（ <strong>s0-s11</strong> ）和临时寄存器（ <strong>t0-t6</strong> ）背后的基本原理（基于 <strong>[Waterman and Asanovi'c 2017]</strong> 的图 <strong>2.1</strong> 和表
<strong>20.1</strong> ）。</p>
<h3 id="25-rv32i的load和store"><a class="header" href="#25-rv32i的load和store">2.5 RV32I的Load和Store</a></h3>
<p>除了提供 32 位字（lw，sw）的加载和存储外，图2.1中说明，RV32I 支持加载有符
号和无符号字节和半字（lb，lbu，lh，lhu）和存储字节和半字（sb，sh）。有符号字节
和半字符号扩展为 32 位再写入目的寄存器。即使是自然数据类型更窄，低位宽数据也是被
扩展后再处理，这使得后续的整数计算指令能正确处理所有的 32 位。在文本和无符号整数
中常用的无符号字节和半字，在写入目标寄存器之前都被无符号扩展到 32 位。
加载和存储的支持的唯一寻址模式是符号扩展 12 位立即数到基地址寄存器，这在
x86- 32 中被称为位偏移寻址模式[Irvine 2014]。
有什么不同之处？RV32I省略了ARM- 32 和x86- 32 的复杂寻址模式。另外，ARM- 32
提供的寻址模式并非适用于所有数据类型，但RV32I 寻址不会歧视任何数据类型。RISC-
V可以模仿某些x86寻址模式。例如，将立即数字段设置为 0 即与x86中的寄存器间接寻
址效果相同。与x86- 32 不同，RISC-V没有特殊的堆栈指令。将 31 个寄存器中的某一个作
为堆栈指针（见图2.4），标准寻址模式使用起来和压栈（push）和出栈（pop）类似，并
且不增加ISA的复杂性。与MIPS- 32 不同，RISC-V不支持延迟加载（delayed load）。与
延迟分支的设计相似，为了更好的适应五级流水线，MIPS- 32 重新定义了load指令的语
义，load上来的数据在load指令两个指令后才可用。但是对于后来出现的更长的流水线，
延迟加载带来的收益逐渐消失，因此RISC-V不支持延迟加载。
虽然ARM- 32 和MIPS- 32 要求存储在内存中的数据，要按照数据的自然大小进行边界
对齐，但是RISC-V没有这个要求。移植旧的代码有时需要未对齐的访问。对于不对齐访
问，一种选择是在基础ISA中禁止不对齐访问，然后提供一些单独的指令用于不对齐访
问，例如MIPS- 32 中的Load Word Left和Load Word Right。然而，这会使寄存器访问变得
复杂，因为lwl 并且lwr需要对寄存器进行部分写，而不是简单地对寄存器进行完整的</p>
<pre><code>补充说明：“位操作”指令
RISC-V基金会正在考虑把rotate之类的位操作指令作为可选指令扩展RV32B的一部分（见
第 11 章）。
</code></pre>
<pre><code>补充说明：利用 xor 指令进行的花式操作
您可以在不使用中间寄存器的情况下交换两个值！此代码交换x1和x2的值。我们将证明
留给读者。提示：异或操作是交换的 (푎⊕푏=푏⊕푎)，结合的 ((푎⊕푏)⊕푐=푎⊕(푏⊕
푐))，是它自己的逆操作 (푎⊕푎= 0 )，并且有一个单位元(푎⊕ 0 =푎)。
</code></pre>
<pre><code>xor x1,x1,x2 # x1’ == x1^x2, x2’ == x2
xor x2,x1,x2 # x1’ == x1^x2, x2’ == x1’^x2 == x1^x2^x2 == x1
xor x1,x1,x2 # x1” == x1’^x2’ == x1^x2^x1 == x1^x1^x2 == x2, x2’ == x1
</code></pre>
<pre><code>不论这个操作多么奇妙，RISC-V充足的寄存器使得编译器通常可以找到一个临时寄存器，
因此很少使用这个异或的交换操作。
</code></pre>
<h4 id="写支持不对齐访问的另一种方法就是让普通的加载和存储指令支持不对齐访问这简"><a class="header" href="#写支持不对齐访问的另一种方法就是让普通的加载和存储指令支持不对齐访问这简">写。支持不对齐访问的，另一种方法就是让普通的加载和存储指令支持不对齐访问，这简</a></h4>
<h4 id="化了整体设计"><a class="header" href="#化了整体设计">化了整体设计。</a></h4>
<h3 id="26-rv32i条件分支"><a class="header" href="#26-rv32i条件分支">2.6 RV32I条件分支</a></h3>
<h4 id="rv32i可以比较两个寄存器并根据比较结果上进行分支跳转比较可以是相等"><a class="header" href="#rv32i可以比较两个寄存器并根据比较结果上进行分支跳转比较可以是相等">RV32I可以比较两个寄存器并根据比较结果上进行分支跳转。比较可以是：相等</a></h4>
<p>（beq），不相等 （bne），大于等于（bge），或小于（blt）。最后两种比较有符号比
较，RV32I也提供相应的无符号版本比较的：bgeu和bltu。剩下的两个比较关系（大于和
小于等于）可以通过简单地交换两个操作数，即可完成比较。因为x &lt; y表示y &gt; x且x ≥ y
表示y ≤ x。
由于RISC-V指令长度必须是两个字节的倍数——关于可选的双字节指令 ，请参考第
七章——分支指令的寻址方式是 12 位的立即数乘以 2 ，符号扩展它，然后将得到值加到
PC上作为分支的跳转地址。PC相对寻址可用于位置无关的代码，简化了链接器和加载器
的工作（第 3 章）。</p>
<p>有什么不同之处？如上所述，RISC-V去掉了MIPS- 32 ，Oracle SPARC等指令集中被
广为诟病的延迟分支特性等。对于条件分支，它还没有像ARM- 32 和x86- 32 那样使用条件
码。条件码的存在使得大多数指令都需要隐式设置一些额外状态，这使乱序执行的依赖计
算复杂化。最后，它省略了x86- 32 中的循环指令：loop，loope，loopz，loopne，
loopnz。</p>
<pre><code>补充说明：字节序问题
RISC-V选择了小尾端字节序，因为它在商业上占主导地位：所有x86- 32 系统，Apple iOS，
谷歌Android操作系统和微软Windows for ARM都是低字节优先序。由于字节顺序仅在同
时以按字访问和按字节访问同一份数据时才会有影响，字节序只会影响很少一部分的程序
员。
</code></pre>
<pre><code>补充说明：不使用条件码实现大位宽数据的加法
在RV32I中是通过sltu计算进位来实现的：
</code></pre>
<pre><code>add a0,a2,a4 # 加低 32 位: a0 = a2 + a4
sltu a2,a0,a2 # 若 (a2+a4) &lt; a2那么a2’ = 1, 否则a2’ = 0
add a5,a3,a5 # 加高 32 位: a5 = a3 + a5
add a1,a2,a5 # 加上低 32 位的进位
</code></pre>
<pre><code>补充说明：获取PC
当前的PC可以通过将auipc的U立即数字段设置为 0 来获得。对于x86- 32 ，要想读取PC，
你需要先进行函数调用，（这样子可以将PC推入堆栈）;然后被调用的函数可以从堆栈中读
取刚被压栈的PC，最后将PC值返回给调用者（需要再弹出堆栈）。因此，或许当前的PC
至少需要 1 个store， 2 个load和 2 个跳转！
</code></pre>
<pre><code>bltu允许使用单个
指令检查有符号数
组的边界，因为任何
负索引都将比任何
非负边界更大！
</code></pre>
<h3 id="27-rv32i无条件跳转"><a class="header" href="#27-rv32i无条件跳转">2.7 RV32I无条件跳转</a></h3>
<pre><code>图2.1中的跳转并链接指令（jal）具有双重功能。若将下一条指令PC + 4的地址保存
到目标寄存器中，通常是返回地址寄存器ra（见图2.4），便可以用它来实现过程调用。
如果使用零寄存器（x0）替换ra作为目标寄存器，则可以实现无条件跳转，因为x0不能
更改。像分支一样，jal将其 20 位分支地址乘以 2 ，进行符号扩展后再添加到PC上，便得
到了跳转地址。
跳转和链接指令的寄存器版本（jalr）同样是多用途的。它可以调用地址是动态计算
出来的函数，或者也可以实现调用返回（只需ra作为源寄存器，零寄存器（x0）作为目的
寄存器）。Switch和case语句的地址跳转，也可以使用jalr指令，目的寄存器设为x 0 。
</code></pre>
<pre><code>有什么不同之处？RV32I避开了错综复杂的程序调用指令，例如x86- 32 的进入和离开
指令，或Intel Itanium，Oracle SPARC和Cadence Tensilica中的寄存器窗口。
</code></pre>
<h3 id="28-rv32i杂项"><a class="header" href="#28-rv32i杂项">2.8 RV32I杂项</a></h3>
<pre><code>图 2 .1中的控制状态寄存器指令 (csrrc、csrrs、csrrw、csrrci、csrrsi、csrrwi)，
使我们可以轻松地访问一些程序性能计数器。对于这些 64 位计数器, 我们一次可以读取 32
位。这些计数器包括了系统时间, 时钟周期以及执行的指令数目。
在RISC-V指令集中，ecall指令用于向运行时环境发出请求，例如系统调用。调试器
使用ebreak指令将控制转移到调试环境。
fence指令对外部可见的访存请求，如设备I / O和内存访问等进行串行化。外部可见
指对处理器的其他核心、线程，外部设备或协处理器可见。fence.i指令同步指令和数据
流。在执行fence.i指令之前，对于同一个硬件线程，RISC-V不保证用存储指令写到内存
指令区的数据可以被取指令取到。
第 10 章介绍RISC-V系统指令。
</code></pre>
<pre><code>补充说明：软件检查溢出
大部分（但不是所有）程序都忽略整数算术溢出，因此RISC-V依赖于软件溢出检查。检查
无符号加法的溢出只需要在指令后添加一个额外的分支指令：addu t0，t1，t2; bltu t0，
t1，overflow。
对于带符号的加法，如果已知一个操作数的符号，则溢出检查只需要在加法后添加一条分支
指令：addi t0，t1，+ imm; blt t0，t1，overflow。
这覆盖了常见的加立即数的情况。对于一般的带符号加法，我们需要在加法指令后添加三个
附加指令，当且仅当一个操作数为负数时，结果才能小于另一个操作数，否则就是溢出。
</code></pre>
<pre><code>add t0, t1, t2
slti t3, t2, 0 # t3 = (t2&lt;0)
slt t4, t0, t1 # t4 = (t1+t2&lt;t1)
bne t3, t4, overflow # 若 (t2&lt;0) &amp;&amp; (t1+t2&gt;=t1)
# || (t2&gt;=0) &amp;&amp; (t1+t2&lt;t1)则为溢出
</code></pre>
<p>寄存器窗口通过使
用多于 32 个寄存器
来加速函数调用。新
函数将在调用时获
得 32 个寄存器的新
集合或窗口。为了传
递参数，窗口重叠，
这意味着一些寄存
器位于两个相邻的
窗口中。</p>
<p>图 <strong>2.5: C</strong> 语言版的插入排序。虽然看起来简单 <strong>,</strong> 插入排序比复杂的排序算法有许多优势 <strong>:</strong> 对于小数据集来
说 <strong>,</strong> 它是内存使用效率高、速度快，同时还有适应性强、稳定、能在线处理的特点。 <strong>gcc</strong> 编译器生成了以
下四个数字的代码。我们设置优化标志以减少代码大小，因为这产生了最容易理解的代码。</p>
<pre><code>图 2.6: 插入排序在不同指令集下生成的指令数目以及指令大小。第 7 章会介绍 ARM Thumb-2,
microMIPS 以及 RV32C 指令集。
</code></pre>
<p>有什么不同之处？RISC-V使用内存映射I / O而不是像x 86 - 32 一样，使用in，ins，
insb，insw和out，out，outsb等指令来进行I/O。为支持字符串处理，RISC-V实现了
字节存取，而不是像x86- 32 那样实现了 rep，movs，coms，scas，lods等 16 条特殊的
字符串处理指令。</p>
<h3 id="29-使用插入排序比较rv32iarm--32-mips--32-和x86--32-指令集"><a class="header" href="#29-使用插入排序比较rv32iarm--32-mips--32-和x86--32-指令集">2.9 使用插入排序比较RV32I，ARM- 32 ，MIPS- 32 和x86- 32 指令集</a></h3>
<p>我们已经介绍了RISC-V基本指令集，并说明了与ARM- 32 ，MIPS- 32 和x86- 32 相
比，它做了哪些取舍。我们现在通过真实程序来进行一场直接的较量。图2.5显示了我们
的基准测试——用C实现的插入排序。图2.6是一个表，它总结了在编译到不同ISA后，
插入排序的指令数和字节数。
图2.8至2.11显示了插入排序编译生成的RV32I，ARM- 32 ，MIPS- 32 和x86- 32 的汇
编代码。尽管强调简单性，RISC-V版本使用相同数目或更少的指令， 并且不同架构的代
码大小非常接近。在此示例中，RISC-V的比较、执行分支指令和ARM- 32 和x86- 32 中花
式繁多的寻址模式以及入栈出栈指令一样，能够节省大量指令。</p>
<h3 id="210-结束语"><a class="header" href="#210-结束语">2.10 结束语</a></h3>
<pre><code>那些不记得过去的人，注定要重复过去。——George Santayana, 1905
</code></pre>
<pre><code>在本章和后续章节
中，我们将代码示例
移到章节文本结尾
之后，以便保持内容
的流畅。
</code></pre>
<h4 id="图27使用第-1-章中的七个isa设计指标来组织前面提到的一些过去的指令集中学习"><a class="header" href="#图27使用第-1-章中的七个isa设计指标来组织前面提到的一些过去的指令集中学习">图2.7使用第 1 章中的七个ISA设计指标来组织前面提到的一些过去的指令集中学习</a></h4>
<h4 id="到的经验教训并说明了这些经验教训对rv32i设计的积极影响我们并不是说risc-v"><a class="header" href="#到的经验教训并说明了这些经验教训对rv32i设计的积极影响我们并不是说risc-v">到的经验教训，并说明了这些经验教训对RV32I设计的积极影响。我们并不是说RISC-V</a></h4>
<pre><code>是第一个拥有这些积极结果的ISA。事实上，RV32I从RISC-I，它的曾祖父母[Patterson
2017]那里，继承了如下这些特性：
⚫ 32 位字节可寻址的地址空间
⚫ 所有指令均为 32 位长
⚫ 31 个寄存器，全部 32 位宽，寄存器 0 硬连线为零
⚫ 所有操作都在寄存器之间（没有寄存器到内存的操作）
⚫ 加载/存储字加上有符号和无符号加载/存储字节和半字
⚫ 所有算术，逻辑和移位指令都有立即数版本的指令
⚫ 立即数总是符号扩展
⚫ 仅提供一种数据寻址模式（寄存器+立即数）和PC相对分支
⚫ 无乘法或除法指令
⚫ 一个指令，用于将大立即数加载到寄存器的高位，这样加载 32 位常量到寄存器只
需要两条指令
</code></pre>
<pre><code>RISC-V的出现比过去的ISA晚了四分之一到三分之一个世纪后开始，这使它的设计
者得以实践Santayana的建议，即借用之前指令集中好的设计，但不重复它们不好的瑕疵 -
包括RISC-I指令集中的瑕疵。另外RISC-V基金会将通过可选的指令集扩展的方式缓慢扩
展着指令集，以避免出现困扰过去的成功指令集的疯狂的增量发展。
</code></pre>
<h3 id="211-扩展阅读"><a class="header" href="#211-扩展阅读">2.11 扩展阅读</a></h3>
<pre><code>Lindy effect, 2017. URL https://en.wikipedia.org/wiki/Lindy_effect.
T. Chen and D. A. Patterson. RISC-V genealogy. Technical Report UCB/EECS- 2016 - 6, EECS
Department, University of California, Berkeley, Jan 2016. URL
http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS- 2016 - 6.html.
W. Hohl and C. Hinds. ARM Assembly Language: Fundamentals and Techniques. CRC
Press, 2016.
K. R. Irvine. Assembly language for x86 processors. Prentice Hall, 2014.
</code></pre>
<pre><code>补充说明：RV32I是否与众不同？
早期的微处理器有单独的浮点运算芯片，所以那些浮点运算指令是可选的。摩尔定律使得我
们很快就将所有功能（包括浮点运算）都实现了在同一块芯片上，而且模块化在指令集中逐
渐消失。在更简单的处理器中只实现完整的指令集的子集，并利用软件异常来模拟未实现的
指令，如同数十年前的在IBM 360的 44 型号和Digital Equipment microVAX。RV32I的不同
之处在于完整的软件堆栈只需要RV32I中的基本指令，因此，对于RV32G中未实现的指
令，RV32I处理器无需通过软件异常来进行模拟。在这方面，最接近RISC-V的ISA可能是
Tensilica Xtensa，它是专为嵌入式应用设计的。它的指令集包含有 80 条基础指令。并且它
的指令集旨在被用户根据自己的需求扩展一些加速指令，以加速其应用程序。与Tensilica
Xtensa相比，RV32I具有更简单的基础ISA，具有 64 位地址版本，并且对超级计算机和微
控制器都提供了针对性的指令集扩展。
</code></pre>
<p>所有RISC-V指令的
谱系记录在[Chen &amp;
Patterson 2016]中。</p>
<pre><code>Lindy 效应[Lin
2017]观察到技术或
想法的未来预期寿命
与其年龄成正比。它
经受住了时间的考
验，所以它过去存活
的时间越长，它在未
来的生存时间就越
长。如果这个假设成
立，RISC架构可能在
很长一段时间都会是
一个好的设计。
</code></pre>
<pre><code>D. Patterson. How close is RISC-V to RISC-I?, 2017.
A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I:
User-Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.
</code></pre>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<pre><code>过去的错误
ARM-32 (1986) MIPS-32 (1986) x86-32 (1978)
</code></pre>
<pre><code>RV32I (2011)吸
取的经验教训
成本 必须支持整数乘
除法
</code></pre>
<pre><code>必 须 支 持 整 数 乘
除法
</code></pre>
<pre><code>8 位以及 16 位
操作、必须支持
整数乘除法
</code></pre>
<pre><code>无 8 位、 16 位操
作、可选的整数
乘除法支持
(RV32M)
简洁性 无零寄存器、条
件指令执行、复
杂的寻址模式、
栈 操 作 指 令
（push/pop）、算
术/逻 辑 指 令 中
存在移位
</code></pre>
<pre><code>立 即 数 支 持 零 扩
展及符号扩展、一
些 算 术 指 令 会 造
成溢出异常
</code></pre>
<pre><code>无零寄存器、复
杂的过程 调用
指令
(enter/leave)、栈
指令
(push/pop)、复
杂寻址模式、循
环指令
</code></pre>
<pre><code>寄存器x0专门
用于存放常数 0 、
立即数只进行符
号扩展 、一种数
据寻址模式、没
有条件执行、没
有复杂的函数调
用指令以及栈指
令、算术指令不
抛异常、使用单
独的移位指令来
处理移位操作
性能 分支指令使用条
件码、在不同格
式的指令中，源
和目的寄存器的
位置不同、加载
多个计算得到的
立即数、PC是一
个通用寄存器
</code></pre>
<pre><code>在 不 同 格 式 的 指
令中，源和目的寄
存器的位置不同
</code></pre>
<pre><code>分支指令 使用
条件码、每个指
令中最多 只能
使用两个 寄存
器
</code></pre>
<pre><code>使用同一条指令
实现比较及跳转
（ 不 使 用 条 件
码）、每条指令三
个寄存器 、不能
一次load多个数
据、不同指令格
式中，源及目的
寄存器字段位置
固定、立即数是
常数（不是由计
算得出的）、PC
不是通用寄存器
架构和具体实现
的分离
</code></pre>
<pre><code>将PC像普通寄
存器一样读写，
这样暴露了流水
线长度
</code></pre>
<pre><code>分支指令延迟槽、
Load指令延迟槽、
乘 除 法 使 用 单 独
的HI，LO寄存器
</code></pre>
<pre><code>寄存器不 是通
用的
(AX,CX,DX,
DI,SI有特殊用
途)
</code></pre>
<pre><code>分支指令没有延
迟槽、Load指令
无延迟槽、通用
寄存器
</code></pre>
<pre><code>增长空间 有限的指令码空
间
</code></pre>
<pre><code>有 限 的 指 令 码 空
间
</code></pre>
<pre><code>大量可用的指令
码空间
程序大小 仅有 32 bit指令
(Thumb- 2 是作
为 一 个 独 立 的
ISA)
</code></pre>
<pre><code>仅 32 bit 指令
(microMIPS是作
为一个独立的ISA)
</code></pre>
<pre><code>指令长度 可用
是不同字节，但
这是一个 很不
好的选择
</code></pre>
<pre><code>32 位指令+ 16 位
RV32C 扩展
</code></pre>
<pre><code>易于编程/编译/
链接
</code></pre>
<pre><code>仅 15 个寄存器
内存数据必须对
齐、不规则的数
据寻址模式、不
一致的性能计数
器
</code></pre>
<pre><code>内 存 数 据 必 须 对
齐、不规则的数据
寻址模式、不一致
的性能计数器
</code></pre>
<pre><code>仅 15 个寄存器
内存数据 必须
对齐、不规则的
数据寻址模式、
不一致的 性能
计数器
</code></pre>
<pre><code>31 个寄存器、数
据可用不对齐、
PC 相对的数据
寻址模式 、对称
的 数 据 寻 址 模
式、定义在架构
中的性能计数器
</code></pre>
<p>图 <strong>2.7</strong> ： <strong>RISC-V</strong> 架构师从过去指令集设计的错误中吸取的教训。通常的教训是避免过去的 <strong>ISA</strong> “优化”。经
验和教训按照第一章中提出的七个 <strong>ISA</strong> 指标进行分类。在成本，简单性和性能下列出的许多指令集特性可
以互换，因为这只是设计的偏好问题，但不管它们出现在哪里，它们都很重要。</p>
<p>图 <strong>2.8</strong> ：插入排序的 <strong>RV32I</strong> 代码如图 <strong>2.5</strong> 所示。十六进制的地址在左边， 接下来是十六进制的机器语言代
码，然后是汇编语言指令，最后是评论以及注释。 <strong>RV32I</strong> 分配两个寄存器用以指向 <strong>a[j]</strong> 和 <strong>a[j-1]</strong> 。 <strong>RV 32 I</strong> 有
很多寄存器，其中一些被 <strong>ABI</strong> 预留用于函数调用。与其他 <strong>ISA</strong> 不同，它会跳过保存和恢复寄存器值到内存
的过程。虽然代码大小大于 <strong>x86- 32</strong> ，但使用可选的 <strong>RV32C</strong> 指令（请参阅第七章）缩小了指令大小的差距。
注意 <strong>RV32I</strong> 中的一条比较和分支指令顶得上 <strong>ARM- 32</strong> 和 <strong>x86- 32</strong> 比较所需的三条指令。</p>
<p>图 <strong>2.9</strong> ：图 <strong>2.5</strong> 中插入排序的 <strong>ARM- 32</strong> 代码。十六进制的地址在左边，接下来是十六进制的机器语言代
码，然后是汇编语言指令，最后是注释、评论。由于寄存器不足，为了腾出两个空寄存器，以便之后重
用， <strong>ARM- 32</strong> 将两个寄存器的值保存到堆栈中（和返回地址放在一起）。它使用了一种将 <strong>i</strong> 和 <strong>j</strong> 缩放为字
节地址的寻址方式。鉴于分支跳转需要同时适用于 <strong>ARM- 32</strong> 和 <strong>Thumb- 2</strong> ， <strong>bxcs</strong> 首先设置返回的最低有效
位保存前地址为 <strong>0</strong> 。条件码使得我们在递减 <strong>j</strong> 后在检查它时可以少用一条比较指令，但在其他地方比较仍
然需要三条指令。</p>
<p>图 <strong>2.10</strong> ：图 <strong>2 .5</strong> 中插入排序的 <strong>MIPS- 32</strong> 代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，
然后是汇编语言指令，最后是注释。 <strong>MIPS- 32</strong> 代码中有三条nop指令，这增加了它的长度。两个是由于延
迟分支，另一个是由于延迟加载。编译器无法找到有用的指令来填充延迟槽。延迟的分支也使代码更难
理解，因为不管分支会不会跳转，延迟槽中的指令都会被执行。例如，地址 <strong>5c</strong> 处的最后一条指令
（addiu）是循环的一部分，尽管它是在分支指令之后。</p>
<p>图 <strong>2.11</strong> ：图 <strong>2.5</strong> 中插入排序的 <strong>x86- 32</strong> 代码。十六进制的地址在左边，接下来是十六进制的机器语言代
码，然后是汇编语言指令，最后是注释。由于缺少寄存器， <strong>x86- 32</strong> 将将两个寄存器保存在堆栈中，以便
腾出这两个寄存器供后续使用。而且，本来在 <strong>RV32I</strong> 中可以分配到寄存器的两个变量（ <strong>n</strong> 和指向 <strong>a[0]</strong> 的
指针），现在是保存在内存中的。它使用扩展下标索引寻址模式，这对于访问 <strong>[i]</strong> 和 <strong>[j]</strong> 具有良好效果。 这里
的 <strong>20</strong> 条 <strong>x32- 86</strong> 指令中有 <strong>7</strong> 个是只有一个字节那么长，这使得对于这个简单的程序， <strong>x86- 32</strong> 的代码规模很
小。 <strong>x86</strong> 有两个流行的汇编语言版本： <strong>Intel / Microsoft</strong> 和 <strong>AT</strong> ＆ <strong>T / Linux</strong> 。我们使用英特尔语法，部分原
因是它将目的地放在左边，而源操作数放在右边，与 <strong>RISC-V</strong> ， <strong>ARM- 32</strong> 和 <strong>MIPS- 32</strong> 的操作数顺序一致。
而 <strong>AT</strong> ＆ <strong>T</strong> 的操作数顺序则与之相反（并且对于寄存器操作数，需要在名字前加上 <strong>%</strong> ）。对于一些程序员来
说，这看似微不足道的事情几乎是一个宗教问题。我们这里做出这样的选择，纯粹是因为教学方便，而
非因为所谓“正统的信仰”。</p>
<h2 id="第三章-risc-v汇编语言"><a class="header" href="#第三章-risc-v汇编语言">第三章 RISC-V汇编语言</a></h2>
<h4 id="给看似困难的问题找到简单的解法往往让人心满意足而且最好的解法常常是都简单的"><a class="header" href="#给看似困难的问题找到简单的解法往往让人心满意足而且最好的解法常常是都简单的">给看似困难的问题找到简单的解法往往让人心满意足，而且最好的解法常常是都简单的。</a></h4>
<pre><code>——Ivan Sutherland
</code></pre>
<h3 id="31-导言"><a class="header" href="#31-导言">3.1 导言</a></h3>
<h4 id="图-3-1表明了从c程序翻译成为可以在计算机上执行的机器语言程序的四个经典步骤"><a class="header" href="#图-3-1表明了从c程序翻译成为可以在计算机上执行的机器语言程序的四个经典步骤">图 3 .1表明了从C程序翻译成为可以在计算机上执行的机器语言程序的四个经典步骤。</a></h4>
<h4 id="这一章的内容包括了后三个步骤不过我们要从汇编语言在risc-v函数调用规范中的作用"><a class="header" href="#这一章的内容包括了后三个步骤不过我们要从汇编语言在risc-v函数调用规范中的作用">这一章的内容包括了后三个步骤，不过我们要从汇编语言在RISC-V函数调用规范中的作用</a></h4>
<h4 id="开始说起"><a class="header" href="#开始说起">开始说起。</a></h4>
<pre><code>图 3 .1 从 C 源代码翻译为可运行程序的步骤。这是从逻辑上进行的划分，实际中一些步骤会被结合起
来，加速翻译过程。我们在这里使用了 Unix 的文件后缀命名习惯，分别对应 MS-DOS 中
的.C , .ASM , .OBJ , .LIB和.EXE。
</code></pre>
<h3 id="32-函数调用规范calling-convention"><a class="header" href="#32-函数调用规范calling-convention">3.2 函数调用规范（Calling convention）</a></h3>
<pre><code>函数调用过程通常分为 6 个阶段[Patterson and Hennessy 2017]。
1. 将参数存储到函数能够访问到的位置；
2. 跳转到函数开始位置（使用RV32I的jal指令）；
3. 获取函数需要的局部存储资源，按需保存寄存器；
4. 执行函数中的指令；
5. 将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部存储资源；
</code></pre>
<pre><code>C程序
编译器
汇编程序
汇编器
对象文件
（机器语言模块）
</code></pre>
<pre><code>库文件
（机器语言模块）
链接器
可执行文件
（机器语言程序）
加载器
</code></pre>
<p><strong>Ivan Sutherland</strong>
（ 1938 - ），因为在
1962 年发明出
Sketchpad而获得
图灵奖，被誉为计
算机图形学之父。
Sketchpad是现代
计算机的图形用户
界面的先驱。</p>
<pre><code>6. 返回调用函数的位置（使用ret指令）。
</code></pre>
<p>为了获得良好的性能，变量应该尽量存放在寄存器而不是内存中，但同时也要注意避免
频繁地保存和恢复寄存器，因为它们同样会访问内存。
RISC-V有足够多的寄存器来达到两全其美的结果：既能将操作数存放在寄存器中，同
时也能减少保存和恢复寄存器的次数。其中的关键在于，在函数调用的过程中不保留部分寄
存器存储的值，称它们为临时寄存器；另一些寄存器则对应地称为保存寄存器。不再调用其
它函数的函数称为叶函数。当一个叶函数只有少量的参数和局部变量时，它们可以都被存储
在寄存器中，而不会“溢出（spilling）”到内存中。但如果函数参数和局部变量很多，程序
还是需要把寄存器的值保存在内存中，不过这种情况并不多见。
函数调用中其它的寄存器，要么被当做保存寄存器来使用，在函数调用前后值不变；要
么被当做临时寄存器使用，在函数调用中不保留。函数会更改用来保存返回值的寄存器，因
此它们和临时寄存器类似；用来给函数传递参数的寄存器也不需要保留，因此它们也类似于
临时寄存器。对于其它一些寄存器，调用者需要保证它们在函数调用前后保持不变：比如用
于存储返回地址的寄存器和存储栈指针的寄存器。图 3 .2列出了寄存器的RISC-V应用程序
二进制接口（ABI）名称和它们在函数调用中是否保留的规定。</p>
<pre><code>图 3 .2 RISC-V 整数和浮点寄存器的汇编助记符。 RISC-V 有足够的寄存器，如果过程或方法不产生其它
调用，就可以自由使用由 ABI 分配的寄存器，不需要保存和恢复。调用前后不变的寄存器也称为“由调
用者保存的寄存器”，反之则称为“由被调用者保存的寄存器”。浮点寄存器将第 5 章进行解释。（这张图
源于 [Waterman and Asanovi ́c 2017] 的表 2 0.1 。）
</code></pre>
<pre><code>根据ABI规范，我们来看看标准的RV32I函数入口和出口。下面是函数的开头：
</code></pre>
<pre><code>寄存器 接口名称 描述 在调用中是否保留？
硬编码 0
返回地址
栈指针
全局指针
线程指针
临时寄存器
</code></pre>
<pre><code>保存寄存器
</code></pre>
<pre><code>临时寄存器
</code></pre>
<pre><code>保存寄存器
</code></pre>
<pre><code>函数参数
</code></pre>
<pre><code>临时寄存器 /备用链接寄存器
保存寄存器 /帧指针
函数参数 /返回值
</code></pre>
<pre><code>浮点临时寄存器
浮点保存寄存器
浮点参数
浮点保存寄存器
浮点临时寄存器
</code></pre>
<pre><code>浮点参数/返回值
</code></pre>
<pre><code>调整栈指针（sp寄存器）分配栈帧
</code></pre>
<pre><code>保存返回地址（ra寄存器）
按需保存其它寄存器
函数体
</code></pre>
<h4 id="如果参数和局部变量太多在寄存器中存不下函数的开头会在栈中为函数帧分配空间"><a class="header" href="#如果参数和局部变量太多在寄存器中存不下函数的开头会在栈中为函数帧分配空间">如果参数和局部变量太多，在寄存器中存不下，函数的开头会在栈中为函数帧分配空间，</a></h4>
<h4 id="来存放当一个函数的功能完成后它的结尾部分释放栈帧并返回调用点"><a class="header" href="#来存放当一个函数的功能完成后它的结尾部分释放栈帧并返回调用点">来存放。当一个函数的功能完成后，它的结尾部分释放栈帧并返回调用点：</a></h4>
<h4 id="我们很快将会看到使用这套abi的一个例子但首先我们需要对汇编的其它部分进行"><a class="header" href="#我们很快将会看到使用这套abi的一个例子但首先我们需要对汇编的其它部分进行">我们很快将会看到使用这套ABI的一个例子，但首先我们需要对汇编的其它部分进行</a></h4>
<h4 id="一些解释"><a class="header" href="#一些解释">一些解释。</a></h4>
<h3 id="33-汇编器"><a class="header" href="#33-汇编器">3.3 汇编器</a></h3>
<pre><code>在Unix 系统中，这一步的输入是以.s为后缀的文件，比如foo.s；在MS-DOS中则
是.ASM。
图 3 .1中的汇编器的作用不仅仅是从处理器能够理解的指令产生目标代码，还能翻译一
些扩展指令，这些指令对汇编程序员或者编译器的编写者来说通常很有用。这类指令在巧妙
配置常规指令的基础上实现，称为伪指令。图 3 .3和 3 .4列出了RISC-V伪指令，前者中要
求x 0 寄存器始终为 0 ，后者中则没有这种要求。例如，之前提到的ret实际上是一个伪指令，
汇编器会用jalr x0, x1, 0来替换它（见图 3 .3）。大多数的RISC-V伪指令依赖于x 0 。因此，
把一个寄存器硬编码为 0 便于将许多常用指令——如跳转（jump）、返回（return）、等于 0
时转移（branch on equal to zero）——作为伪指令，进而简化RISC-V指令集。
图 3 .5为经典的C程序Hello World，编译器产生的汇编指令如图 3 .6，其中使用了图 3 .2
的调用规范和图 3 .3、 3 .4的伪指令。
汇编程序的开头是一些汇编指示符（assemble directives）。它们是汇编器的命令，具有
告诉汇编器代码和数据的位置、指定程序中使用的特定代码和数据常量等作用。图 3 .9是
RISC-V的汇编指示符。其中图 3 .6中用到的指示符有：
⚫ .text：进入代码段。
⚫ .align 2：后续代码按 22 字节对齐。
⚫ .globl main：声明全局符号“main”。
⚫ .section .rodata：进入只读数据段
⚫ .balign 4：数据段按 4 字节对齐。
⚫ .string “Hello, %s!\n”：创建空字符结尾的字符串。
⚫ .string “world”：创建空字符结尾的字符串。
</code></pre>
<pre><code>汇编器产生如图 3 .7的目标文件，格式为标准的可执行可链接文件（ELF）格式[TIS Committee
1995]。
</code></pre>
<pre><code>按需恢复其它寄存器
恢复返回地址
释放栈帧空间
返回调用点
</code></pre>
<p>Hello World程序通常
是一个新设计处理器
上运行的第一个程序。
设计者通常把能运行
操作系统并成功打印
出“Hello World”作为
新的芯片能工作的标
志。他们会马上发邮件
给领导和同事，告诉他
们这个结果，然后出去
搓一顿。</p>
<pre><code>补充说明：保存寄存器和临时寄存器为什么不是连续编号的？
为了支持RV32E——一个只有 16 个寄存器的嵌入式版本的RISC-V（参见第 11 章），只使
用寄存器x0到x15——一部分保存寄存器和一部分临时寄存器都在这个范围内。其它的保
存寄存器和临时寄存器在剩余 16 个寄存器内。RV32E较小，但由于和RV32I不匹配，目前
还没有编译器支持。
</code></pre>
<p>图 <strong>3 .3</strong> 依赖于 <strong>x 0</strong> 的 <strong>RISC-V</strong> 伪指令。附录 <strong>A</strong> 包含了这些 <strong>RISC-V</strong> 的伪指令和真实指令。在 <strong>RV32I</strong> 中，那
些读取 <strong>64</strong> 位计数器的指令默认读取低 <strong>32</strong> 位，增加“ <strong>h</strong> ”时读取高 <strong>32</strong> 位。（这张图源于 <strong>[Waterman and
Asanovi ́c 2017]</strong> 的表 <strong>2 0.2</strong> 和表 <strong>2 0.3</strong> 。）</p>
<pre><code>伪指令 基础指令 含义
</code></pre>
<pre><code>无操作
补码
字的补码
非 0 则置位
小于 0 则置位
大于 0 则置位
为 0 则转移
非 0 则转移
小于等于 0 则转移
大于等于 0 则转移
小于 0 则转移
大于 0 则转移
跳转
寄存器跳转
从子过程返回
尾调用远程子过程
读取过时指令计数器
读取周期计数器
读取实时时钟
读CSR寄存器
写CSR寄存器
CSR寄存器置零位
CSR寄存器清
立即数写入CSR
立即数置位CSR
立即数清除CSR
读取FP控制/状态寄存器
写入FP控制/状态寄存器
读取FP舍入模式
写入FP舍入模式
读取FP例外标志
写入FP例外标志
</code></pre>
<p>图 <strong>3 .4</strong> 不依赖于 <strong>x 0</strong> 寄存器的 <strong>RISC-V</strong> 伪指令。在 <strong>la</strong> 指令一栏， <strong>GOT</strong> 代表全局偏移表（ <strong>Global Offset
Table</strong> ），记录动态链接库中的符号的运行时地址。附录 <strong>A</strong> 包含了这些 <strong>RISC-V</strong> 的伪指令和真实指令。（这
张图源于 <strong>[Waterman and Asanovi ́c 2017]</strong> 的表 <strong>2 0.2</strong> 和表 <strong>2 0.3</strong> 。）</p>
<pre><code>图 3 .5 C 语言的 Hello World 程序（hello.c） 。
</code></pre>
<pre><code>伪指令 基础指令 含义
</code></pre>
<pre><code>取局部地址
取地址
</code></pre>
<pre><code>读取全局量
存储全局量
</code></pre>
<pre><code>读取浮点全局量
存储浮点全局量
读取立即数
复制寄存器
反码
有符号扩展字
为 0 时置位
复制单精度寄存器
单精度绝对值
单精度相反数
复制双精度寄存器
双精度绝对值
双精度相反数
大于时转移
小于等于时转移
无符号大于时转移
无符号小于等于时转移
跳转并链接
跳转并链接寄存器
远程调用子过程
内存和I/O屏障
交换FP控制/状态寄存器
交换FP舍入模式
交换FP例外标志
</code></pre>
<pre><code>图 3 .6 RISC-V 汇编语言的 Hello World 程序（hello.s）。
</code></pre>
<p>图 <strong>3 .7 RISC-V</strong> 机器语言的 <strong>Hello World</strong> 程序（hello.o）。位置 <strong>8</strong> 到 <strong>1c</strong> 这六条指令的地址字段为 <strong>0</strong> ，将在后
面由链接器填充。目标文件的符号表记录了链接器所需的标签和地址。</p>
<h3 id="34-链接器"><a class="header" href="#34-链接器">3.4 链接器</a></h3>
<h4 id="链接器允许各个文件独立地进行编译和汇编这样在改动部分文件时不需要重新编译"><a class="header" href="#链接器允许各个文件独立地进行编译和汇编这样在改动部分文件时不需要重新编译">链接器允许各个文件独立地进行编译和汇编，这样在改动部分文件时，不需要重新编译</a></h4>
<h4 id="全部源代码链接器把新的目标代码和已经存在的机器语言模块如函数库等拼接起"><a class="header" href="#全部源代码链接器把新的目标代码和已经存在的机器语言模块如函数库等拼接起">全部源代码。链接器把新的目标代码和已经存在的机器语言模块（如函数库）等“拼接”起</a></h4>
<p>来。链接器这个名字源于它的功能之一，即编辑所有对象文件的跳转并链接指令（jump and
link）中的链接部分。它其实是链接编辑器（link editor）的简称，图 3 .1中的这一步骤过去
就被称为链接编辑。在Unix系统中，链接器的输入文件有.o后缀，输出a.out文件；在MS-
DOS中输入文件后缀为.OBJ或.LIB，输出.EXE文件。
图 3 .10展示了一个典型的RISC-V程序分配给代码和数据的内存区域，链接器需要调
整对象文件的指令中程序和数据的地址，使之与图中地址相符。如果输入文件中的是与位置
无关的代码（PIC），链接器的工作量会有所降低。PIC中所有的指令转移和文件内的数据访</p>
<pre><code>指示符：进入代码段
指示符：按 2 ^2字节对齐代码
指示符：声明全局符号main
main开始标记
分配栈帧
存储返回地址
计算string1的地址
计算string2的地址
调用printf函数
恢复返回地址
释放栈帧
读取返回值
返回
</code></pre>
<p>(^) 指示符：进入只读数据段
指示符：按 4 字节对齐数据
第一个字符串标记
指示符：空字符结尾的字符串
第二个字符串标记
指示符：空字符结尾的字符串</p>
<p>问都不受代码位置的影响。如第 2 章所言，RV 32 I的相对转移（PC-relative branch）特性使
得程序更易于实现PIC。
除了指令，每个目标文件还包含一个符号表，存储了程序中标签，由链接过程确定地址。
其中包括了数据标签和代码标签。图 3 .6中有两个数据标签（string1和string2）和两个代
码标签（main和printf）需要确定。由于在单个 32 位指令中很难指定一个 32 位的地址，
RV32I的链接器通常需要为每个标签调整两条指令。如图 3 .6所示：数据标签需要调整lui
和addi，代码标签需要调整auipc和jalr。图 3 .8显示了图 3 .7中的目标文件链接后产生的
a.out文件。</p>
<pre><code>图 3 .8 链接后的 RISC-V 机器语言 Hello World 程序。在 Unix 系统中，它的文件名是a.out。
</code></pre>
<p>RISC-V编译器支持多个ABI，具体取决于F和D扩展是否存在。RV32的ABI分别名
为ilp32，ilp32f和ilp32d。ilp32表示C语言的整型（int），长整型（long）和指针（pointer）
都是 32 位，可选后缀表示如何传递浮点参数。在lip32中，浮点参数在整数寄存器中传递；
在ilp32f中，单精度浮点参数在浮点寄存器中传递；在ilp32d中，双精度浮点参数也在浮点
寄存器中传递。
自然，如果想在浮点寄存中传递浮点参数，需要相应的浮点ISA添加F或D扩展（见
第 5 章）。因此要编译RV32I的代码（GCC选项-march=rv32i），必须使用ilp32 ABI（GCC
选项-mabi=lib32）。反过来，调用约定并不要求浮点指令一定要使用浮点寄存器，因此
RV32IFD与ilp32，ilp 32 f和ilp 32 d都兼容。
链接器检查程序的ABI是否和库匹配。尽管编译器本身可能支持多种ABI和ISA扩展
的组合，但机器上可能只安装了特定的几种库。因此，一种常见的错误是在缺少合适的库的
情况下链接程序。在这种情况下，链接器不会直接产生有用的诊断信息，它会尝试进行链接，
然后提示不兼容。这种错误常常在从一台计算机上编译另一台计算机上运行的程序（交叉编
译）时发生。</p>
<pre><code>补充说明：链接器松弛（linker relaxation）
跳转并链接指令（jump and link）中有 20 位的相对地址域，因此一条指令就足够跳到很远
的位置。尽管编译器为每个外部函数的跳转都生成了两条指令，很多时候其实一条就已经足
够了。从两条指令到一条的优化同时节省了时间和空间开销，因此链接器会扫描几遍代码，
尽可能地把两条指令替换为一条。每次替换会导致函数和调用它的位置之间的距离缩短，所
以链接器会多次扫描替换，直到代码不再改变。这个过程称为链接器松弛，名字来源于求解
方程组的松弛技术。除了过程调用之外，对于gp指针±2KiB范围内的数据访问，RISC-V链
接器也会使用一个全局指针替换掉lui和auipc两条指令。对tp指针±2KiB范围内的线程
局部变量访问也有类似的处理。
</code></pre>
<pre><code>图 3 .9 常见 RISC-V 汇编指示符。
</code></pre>
<p>图 <strong>3 .10 RV32I</strong> 为程序和数据分配内存。图中的顶部是高地址，底部是低地址。在 <strong>RISC-V</strong> 软件规范中，
栈指针（sp）从 <strong>0 xbffffff0</strong> 开始向下增长；程序代码段从 <strong>0 x00010000</strong> 开始，包括静态链接库；程序代码
段结束后是静态数据区，在这个例子中假设从 <strong>0 x10000000</strong> 开始；然后是动态数据区，由 <strong>C</strong> 语言中的
<strong>malloc()</strong> 函数分配，向上增长，其中包含动态链接库。</p>
<pre><code>代码段（机器语言代码）。
数据段（全局变量）。
bss段（初始化为 0 的全局变量）。
命名为.foo的段。^
按 2 n字节对齐。如.align 2是按字对齐。
按n字节对齐。如.balign 4是按字对齐。
声明将字符串 sym标签为全局的，可从其它文件访问。str存入内存，空字符结尾。
在内存中连续存储n个 8 位的量。
在内存中连续存储n个^16 位的量。^
在内存中连续存储n个 32 位的量。
在内存中连续存储n个 64 位的量。
在内存中连续存储n个单精度浮点数。
在内存中连续存储n个双精度浮点数。
</code></pre>
<p>(^) 压缩指令（见第 7 章）。
不压缩指令。
允许链接器松弛（linker relaxation）。
不允许链接器松弛。
与位置无关代码段。
与位置有关代码段。
将所有的.option设置存入栈。
从栈中弹出上次存入的.option设置。
栈
动态数据
静态数据
代码段
保留</p>
<h4 id="指示符-描述"><a class="header" href="#指示符-描述">指示符 描述</a></h4>
<h3 id="35-静态链接和动态链接"><a class="header" href="#35-静态链接和动态链接">3.5 静态链接和动态链接</a></h3>
<pre><code>上一节对静态链接（static linking）进行了说明，在程序运行前所有的库都进行了链接和
加载。如果这样的库很大，链接一个库到多个程序中会十分占用内存。另外，链接时库是绑
定的，即使它们后来的更新修复了bug，强制的静态链接的代码仍然会使用旧的、有bug的
版本。
为了解决这两个问题，现在的许多系统使用动态链接（dynamic linking），外部的函数在
第一次被调用时才会加载和链接。后续所有调用都使用快速链接（fast linking），因此只会产
生一次动态开销。每次程序开始运行，它都会按照需要链接最新版本的库函数。另外，如果
多个程序使用了同一个动态链接库，库代码在内存中只会加载一次。
编译器产生的代码和静态链接的代码很相似。其不同之处在于，跳转的目标不是实际的
函数，而是一个只有三条指令的存根函数（stub function）。存根函数会从内存中的一个表中
加载实际的函数的地址并跳转。不过，在第一次调用时，表中还没有实际的函数的地址，只
有一个动态链接的过程的地址。当这个动态链接过程被调用时，动态链接器通过符号表找到
实际要调用的函数，复制到内存中，更新记录实际的函数地址的表。后续的每次调用的开销
就是存根函数的三条指令的开销。
</code></pre>
<h3 id="36-加载器"><a class="header" href="#36-加载器">3.6 加载器</a></h3>
<h4 id="类似图-3-8的程序以一个可执行文件的形式存储在计算机的存储设备上运行时加载"><a class="header" href="#类似图-3-8的程序以一个可执行文件的形式存储在计算机的存储设备上运行时加载">类似图 3 .8的程序以一个可执行文件的形式存储在计算机的存储设备上。运行时，加载</a></h4>
<h4 id="器的作用是把这个程序加载到内存中并跳转到它开始的地址如今的加载器就是操作"><a class="header" href="#器的作用是把这个程序加载到内存中并跳转到它开始的地址如今的加载器就是操作">器的作用是把这个程序加载到内存中，并跳转到它开始的地址。如今的“加载器”就是操作</a></h4>
<pre><code>系统。换句话说，加载a.out是操作系统众多的任务之一。
动态链接程序的加载稍微有些复杂。操作系统不直接运行程序，而是运行一个动态链接
器，再由动态链接器开始运行程序，并负责处理所有外部函数的第一次调用，把它们加载到
内存中，并且修改程序，填入正确的调用地址。
</code></pre>
<h3 id="37-结束语"><a class="header" href="#37-结束语">3.7 结束语</a></h3>
<pre><code>保持简洁，保持功能单一。
——Kelly Johnson，提出“KISS原则”的航空工程师， 1960
</code></pre>
<pre><code>汇编器向RISC-V ISA中增加了 60 条伪指令，使得RISC-V代码更易于读写，并且不增
加硬件开销。将一个寄存器硬编码为 0 使得其中许多伪指令更容易实现。使用加载高位立即
数（lui）和程序计数器与高位立即数相加（auipc）两条指令，简化了编译器和链接器寻找
外部数据/函数的地址的过程。使用相对地址转移的代码与位置无关，减少了链接器的工作。
大量的寄存器减少了寄存器保存和恢复的次数，加速函数调用和返回。
RISC-V提供了一系列简单又有影响力的机制，降低成本，提高性能，并且使得编写程
序更加容易。
</code></pre>
<p>体系结构研究者常用
静态链接的基准程序
来测试处理器，尽管
大多数实际的程序都
有动态链接。他们说，
关心性能的用户应该
只使用静态链接，但
其实这并不合理，因
为加速实际的程序显
然比加速基准程序更
有意义。</p>
<h3 id="38-扩展阅读"><a class="header" href="#38-扩展阅读">3.8 扩展阅读</a></h3>
<pre><code>D. A. Patterson and J. L. Hennessy. Computer Organization and Design RISC-V Edition:
The Hardware Software Interface. Morgan Kaufmann, 2017.
</code></pre>
<pre><code>TIS Committee. Tool interface standard (TIS) executable and linking format (ELF)
specification version 1.2. TIS Committee , 1995.
</code></pre>
<pre><code>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I: User-
Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.
</code></pre>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<h2 id="第四章-乘法和除法指令"><a class="header" href="#第四章-乘法和除法指令">第四章 乘法和除法指令</a></h2>
<pre><code>若非必要，勿增实体。——奥卡姆的威廉（William of Occam）， 1320
</code></pre>
<h3 id="41-导言"><a class="header" href="#41-导言">4.1 导言</a></h3>
<pre><code>RV32M向RV32I中添加了整数乘法和除法指令。图4.1是RV32M扩展指令集的图形
表示，图4.2列出了它们的操作码。
除法是直截了当的。可以回想起如下的式子：
商=(被除数−余数)÷除数
或者
被除数=除数×商+余数
余数=被除数−(商×除数)
RV32M具有有符号和无符号整数的除法指令：divide(div)和divide unsigned(divu)，它们将
商放入目标寄存器。在少数情况下，程序员需要余数而不是商，因此RV32M提供
remainder(rem)和remainder unsigned(remu)，它们在目标寄存器写入余数，而不是商。
</code></pre>
<pre><code>图 4.1 ： RV32M 指令的图示
</code></pre>
<pre><code>图 4.2 ： RV32M 操作码映射包含指令布局，操作码，指令格式类型和它们的名称（ [Waterman and
Asanovic 2017] 的表 19.2 是此图的基础。）
</code></pre>
<pre><code>乘法的式子很简单：
</code></pre>
<p>奥 卡 姆 的 威廉( 1452 -
1519)是一位英国神学
家，他推广了现在所谓
的“奥卡姆剃刀”原理，
它意味着在科学方法
中对简洁性的偏爱。</p>
<p>srl可以做除数为 2 i的
无符号除法。例如，如
果a2=16(2^4 )，那么srli
t2,a1,4这 条 指 令和
divu t2,a1,a2得到的
结果相同。</p>
<h4 id="积被乘数乘数"><a class="header" href="#积被乘数乘数">积=被乘数×乘数</a></h4>
<h4 id="它比除法要更为复杂是因为积的长度是乘数和被乘数长度的和将两个-32-位数相乘得到"><a class="header" href="#它比除法要更为复杂是因为积的长度是乘数和被乘数长度的和将两个-32-位数相乘得到">它比除法要更为复杂，是因为积的长度是乘数和被乘数长度的和。将两个 32 位数相乘得到</a></h4>
<h4 id="的是-64-位的乘积为了正确地得到一个有符号或无符号的-64-位积risc-v中带有四个乘"><a class="header" href="#的是-64-位的乘积为了正确地得到一个有符号或无符号的-64-位积risc-v中带有四个乘">的是 64 位的乘积。为了正确地得到一个有符号或无符号的 64 位积，RISC-V中带有四个乘</a></h4>
<p>法指令。要得到整数 32 位乘积（ 64 位中的低 32 位）就用mul指令。要得到高 32 位，如果
操作数都是有符号数，就用mulh指令；如果操作数都是无符号数，就用mulhu指令；如
果一个有符号一个无符号，可以用mulhsu指令。在一条指令中完成把 64 位积写入两个 32
位寄存器的操作会使硬件设计变得复杂，所以RV32M需要两条乘法指令才能得到一个完整
的 64 位积。
对许多微处理器来说，整数除法是相对较慢的操作。如前述，除数为 2 的幂次的无符号
除法可以用右移来代替。事实证明，通过乘以近似倒数再修正积的高 32 位的方法，可以优
化除数为其它数的除法。例如，图4.3显示了 3 为除数的无符号除法的代码。</p>
<p>图 <strong>4.3</strong> ： <strong>RV32M</strong> 中用乘法来实现除以常数操作的代码。要证明该算法适用于任何除数需要仔细的数值分析，
而对于其它除数，其中的修正步骤更为复杂。算法正确性的证明以及产生倒数和修正步骤的算法在
<strong>[Granlund and Montgomery 1994]</strong> 中可以找到。</p>
<p>有什么不同之处？ 长期以来，ARM- 32 只有乘法而无除法指令。直到第一台ARM处理器
诞生的大约 20 年后（ 2005 年），除法指令才成为ARM的必要组成部分。MIPS- 32 使用特殊
寄存器（HI和LO）作为乘法和除法指令的唯一目标寄存器。虽然这种设计降低了早期MIPS
处理器实现的复杂性，但它需要额外的移动指令以使用乘法或除法的结果，这可能会降低性
能。HI和LO寄存器也会增加架构状态，使得在任务之间切换的速度稍慢。</p>
<pre><code>补充说明：mulh和mulhu可以检查乘法的溢出
如果mulhu的结果为零，则在使用mul进行无符号乘法时不会溢出。类似地，如果mulh
结果中的所有位与mul结果的符号位匹配（即当mul结果为正时mulh结果为 0 ，mul结
果为负时mulh结果为十六进制的ffffffff），则使用mul进行有符号乘法时不会溢出。
</code></pre>
<pre><code>补充说明：检查是否除零也很简单
要测试除数是否为零，只需要在除法操作之前加入一条用于测试的beqz指令。RV32I不会
因为除零操作而trap，因为极少数程序需要这种行为，而且在那些软件中可以很容易地检查
是否除零。当然，除以其它常数永远不需要检查。
</code></pre>
<pre><code>补充说明：mulhsu对于多字有符号乘法很有用
当乘数有符号且被乘数无符号时，mulhsu产生乘积的上半部分。当乘数的最高有效字（包
含符号位）与被乘数的较低有效字（无符号）相乘时，它是多字有符号乘法的子步骤。该指
令将多字乘法的性能提高了约15%。
</code></pre>
<pre><code>sll可以做乘数为 2 i的
无符号乘法。例如，如
果a2=16(2^4 )，那么slli
t2,a1,4这 条 指 令和
mul t2,a1,a2得到的结
果相同。
</code></pre>
<pre><code>对于几乎所有的处理
器，乘法比移位和加法
慢很多，除法比乘法慢
很多。
</code></pre>
<h3 id="42-结束语"><a class="header" href="#42-结束语">4.2 结束语</a></h3>
<pre><code>最便宜，最快，并且最可靠的组件是那些没有出现的组件。
——C. Gordan Bell，著名小型计算机的架构师
</code></pre>
<p>为了为嵌入式应用提供最小的RISC-V处理器，乘法和除法被归入RISC-V的第一个可
选标准扩展的一部分RV32M。许多RISC-V处理器将包括RV32M。</p>
<h3 id="43-扩展阅读"><a class="header" href="#43-扩展阅读">4.3 扩展阅读</a></h3>
<p>T. Granlund and P. L. Montgomery. Division by invariant integers using multiplication. In ACM
SIGPLAN Notices, volume 29, pages 61–72. ACM, 1994.</p>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I: User-
Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.</p>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<h2 id="第五章-rv32f和rv32d单精度和双精度浮点数"><a class="header" href="#第五章-rv32f和rv32d单精度和双精度浮点数">第五章 RV32F和RV32D：单精度和双精度浮点数....................................................................</a></h2>
<pre><code>只有当没有任何东西可以去除，而不是没有东西可以添加时，我们才最终达到了完美。
——Antoine de Saint Exup’ery, L’Avion, 1940
</code></pre>
<h3 id="5-1-导言"><a class="header" href="#5-1-导言">5. 1 导言</a></h3>
<h4 id="尽管rv32f和rv-32-d是分开的单独的可选指令集扩展他们通常是包括在一起的"><a class="header" href="#尽管rv32f和rv-32-d是分开的单独的可选指令集扩展他们通常是包括在一起的">尽管RV32F和RV 32 D是分开的，单独的可选指令集扩展，他们通常是包括在一起的。</a></h4>
<h4 id="为简洁起见我们在一章中介绍了几乎所有的单精度和双精度-32-位和-64-位浮点指令"><a class="header" href="#为简洁起见我们在一章中介绍了几乎所有的单精度和双精度-32-位和-64-位浮点指令">为简洁起见，我们在一章中介绍了几乎所有的单精度和双精度（ 32 位和 64 位）浮点指令。</a></h4>
<h4 id="图51是一个-rv32f和rv32d扩展指令集的图形表示图52列出-rv32f的操作码图"><a class="header" href="#图51是一个-rv32f和rv32d扩展指令集的图形表示图52列出-rv32f的操作码图">图5.1是一个 RV32F和RV32D扩展指令集的图形表示。图5.2列出 RV32F的操作码，图</a></h4>
<h4 id="53列出了rv32d的操作码和几乎所有其他现代isa一样risc-v服从ieee-754--2008"><a class="header" href="#53列出了rv32d的操作码和几乎所有其他现代isa一样risc-v服从ieee-754--2008">5.3列出了RV32D的操作码。和几乎所有其他现代ISA一样，RISC-V服从IEEE 754- 2008</a></h4>
<h4 id="浮点标准ieee标准委员会2008"><a class="header" href="#浮点标准ieee标准委员会2008">浮点标准[IEEE标准委员会2008]。</a></h4>
<h3 id="52浮点寄存器"><a class="header" href="#52浮点寄存器">5.2浮点寄存器</a></h3>
<pre><code>RV32F和RV32D使用 32 个独立的f寄存器而不是x寄存器。使用两组寄存器的主要
原因是：处理器在不增加RISC-V指令格式中寄存器描述符所占空间的情况下使用两组寄存
器来将寄存器容量和带宽是乘 2 ，这可以提高处理器性能。使用两组寄存器对RISC-V指令
集的主要影响是，必须要添加新的指令来加载和存储数据f寄存器，还需要添加新指令用于
在x和f寄存器之间传递数据。图5.4列出了RV32D和RV32F寄存器及对应的由RISC-V
ABI确定的寄存器名称。
如果处理器同时支持RV32F和RV32D扩展，则单精度数据仅使用f寄存器中的低 32
位。与RV32I中的x0不同，寄存器f0不是硬连线到常量 0 ，而是和所有其他 31 个 f寄存
器一样，是一个可变寄存器。
IEEE 754- 2008 标准提供了几种浮点运算舍入的方法，这有助于确定误差范围和编写数
值库。最准确且最常见的舍入模式是舍入到最近的偶数（RNE）。舍入模式可以通过浮点控
制和状态寄存器fcsr进行设置。图5.5显示了fcsr并列出了舍入选项。它还包含标准所需
的累积异常标志。
有什么不同之处？ ARM- 32 和MIPS- 32 都有 32 个单精度浮点寄存器但都只有 16 个双
精度寄存器。它们都将两个单精度寄存器映射到双精度寄存器的左右两半。x86- 32 浮点数算
术没有任何寄存器，而是使用堆栈代替。堆栈条目是 80 位宽度提高精度，因此浮点数负载
</code></pre>
<pre><code>补充说明：RV32FD允许逐条指令设置舍入模式
这被称为静态舍入，当你只需要更改一条指令的舍入模式时，它可以帮助提高性能。默认设
置是在fcsr中使用动态舍入模式。静态舍入所选择的模式是作为指令可选的最后一个参数，
如fadd.s ft0，ft1，ft2，rtz，将向零舍入，无论fcsr如何。图5.5的标题列出了不同舍入
模式的名称。
</code></pre>
<p>Antoine de Saint
Exup’ery, L’Avion
（ 1900 - 1944 ）是法国
作家和飞行员，以《小
王子》一书而闻名。</p>
<pre><code>根据MIPS架构师之一
John Mashey的说法，只
有 16 个双精度寄存器
是MIPS的ISA设计中
犯过的最痛苦的错误。
</code></pre>
<p>将 32 位或 64 位操作数转换为 80 位，对于存储指令，反之亦然。x86- 32 的一个后续版本增
加了 8 个传统的 64 位浮点寄存器以及相关的操作指令。与RV32FD和MIPS- 32 不同，ARM-
32 和x86- 32 忽视了在浮点和整数寄存器之间直接移动数据的指令。唯一的解决方案是先将
浮点寄存器的内容存储在内存中，然后将其从内存加载到整数寄存器，反之亦然。</p>
<pre><code>图 5.1 ： RV32F 和 RV32D 的指令图示。
</code></pre>
<h3 id="53浮点加载存储和算术指令"><a class="header" href="#53浮点加载存储和算术指令">5.3浮点加载，存储和算术指令</a></h3>
<p>对于RV32F和RV32D，RISC-V有两条加载指令（flw，fld）和两条存储指令（fsw，
fsd）。他们和lw和sw拥有相同的寻址模式和指令格式。添加到标准算术运算中的指令有：
（fadd.s，fadd.d，fsub.s，fsub.d，fmul.s，fmul.d，fdiv.s，fdiv.d），RV32F和RV32D
还包括平方根（fsqrt.s，fsqrt.d）指令。它们也有最小值和最大值指令（fmin.s，fmin.d，
fmax.s，fmax.d），这些指令在不使用分支指令进行比较的情况下，将一对源操作数中的较
小值或较大值写入目的寄存器。
许多浮点算法（例如矩阵乘法）在执行完乘法运算后会立即执行一条加法或减法指令。
因此，RISC-V提供了指令用于先将两个操作数相乘然后将乘积加上（fmadd.s，fmadd.d）
或减去（fmsub.s，fmsub.d）第三个操作数，最后再将结果写入目的寄存器。它还有在加
上或减去第三个操作数之前对乘积取反的版本：fnmadd.s，fnmadd.d，fnmsub.s，fnmsub.d。
这些融合的乘法 - 加法指令比单独的使用乘法及加法指令更准确，也更快，因为它们只（在
加法之后）舍入过一次，而单独的乘法及加法指令则舍入了两次（先是在乘法之后，然后在
加法之后）。这些指令需要一条新指令格式指定第 4 个寄存器，称为R4。图5.2和5.3显示
了R4格式，它是R格式的一个变种。
RV32F和RV32D没有提供浮点分支指令，而是提供了浮点比较指令，这些根据两个浮
点的比较结果将一个整数寄存器设置为 1 或 0 ：feq.s，feq.d，flt.s，flt.d，fle.s，fle.d。这
些指令允许整数分支指令根据浮点数比较指令设置的条件进行分支跳转。例如，这段代码在
f1 &lt;f2时，则分支跳转到Exit：
flt x5，f1，f2 ＃如果f 1 &lt; f 2 ，则x5 = 1;否则x5 = 0
bne x5，x0，Exit ＃如果x5！= 0，则跳转到Exit</p>
<pre><code>不同于整数运算，浮点
乘法的乘积大小与其操
作数相同。此外，RV32F
和RF32D省略了浮点
余数指令。
</code></pre>
<p>31 27 26 25 24 20 19 15 14 12 11 7 6 0
imm[11:0] rs1 010 rd 000011
1</p>
<pre><code>I flw
imm[11:5] rs2 rs1 010 imm[4:0] 010011
1
</code></pre>
<pre><code>S fsw
rs3 00 rs2 rs1 rm rd 100001
1
</code></pre>
<pre><code>R4
fmadd.s
fmadd.
</code></pre>
<pre><code>rs3 00 rs2 rs1 rm rd 100011
1
</code></pre>
<pre><code>R4
fmsub.s
fmadd.
</code></pre>
<pre><code>rs3 00 rs2 rs1 rm rd 100101
1
</code></pre>
<pre><code>R4
fnmsub.s
fmadd.
</code></pre>
<pre><code>rs3 00 rs2 rs1 rm rd 100111
1
</code></pre>
<pre><code>R4
fnmadd.s
fmadd.
</code></pre>
<pre><code>0000000 rs2 rs1 rm^ rd 101001
1
</code></pre>
<pre><code>R fadd.s
0000100 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fsub.s
0001000 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fmul.s
0001100 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fdiv.s
0001100 00000 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fsqrt.s
0010000 rs2^ rs1 000 rd 101001
1
</code></pre>
<pre><code>R fsgnj.s
0010000 rs2^ rs1 001 rd 101001
1
</code></pre>
<pre><code>R fsgnjn.s
0010000 rs2^ rs1 010 rd 101001
1
</code></pre>
<pre><code>R fsgnjx.s
0010100 rs2 rs1 000 rd 101001
1
</code></pre>
<pre><code>R fmin.s
0010100 rs2 rs1 001 rd 101001
1
</code></pre>
<pre><code>R fmax.s
1100000 00000 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fcvt.w.s
1100000 00001 rs1 rm^ rd 101001
1
</code></pre>
<pre><code>R
</code></pre>
<p>1110000 00000 rs1 000 rd (^101001) fcvt.wu.s
1
R fmv.x.w
1010000 rs2^ rs1 010 rd 101001
1
R feq.s
1010000 rs2^ rs1 001 rd 101001
1
R flt.s
1010000 rs2 rs1 000 rd 101001
1
R fle.s
1110000 00000 rs1 001 rd 101001
1
R fclass.s
1101000 00000 rs1 rm rd 101001
1
R fcvt.s.w
1101000 00001 rs1 rm^ rd 101001
1
R
1111000 00000 rs1 000 rd (^101001) fcvt.s.wu
1
R fmv.w.x
图 <strong>5.2</strong> ： <strong>RV32F</strong> 操作码表包含了指令布局，操作码，格式类型和名称。这张表与下一张表在编码上的主要
区别是：对于这张表，前两个指令第 <strong>12</strong> 位是 <strong>0</strong> ，并且对于其余指令，第 <strong>25</strong> 位为 <strong>0</strong> ，而在下一张表中，
<strong>RV32D</strong> 中的这两个位均为 <strong>1</strong> （基于 <strong>[Waterman and Asanovic 2017]</strong> 的表 <strong>19.2</strong> ）。</p>
<p>31 27 26 25 24 20 19 15 14 12 11 7 6 0
imm[11:0] rs1 011 rd 000011
1</p>
<pre><code>I fld
imm[11:5] rs2 rs1 011 imm[4:0] 010011
1
</code></pre>
<pre><code>S fsd
rs3 01 rs2 rs1 rm rd 100001
1
</code></pre>
<pre><code>R4
fmadd.d
fmadd.
</code></pre>
<pre><code>rs3 01 rs2 rs1 rm rd 100011
1
</code></pre>
<pre><code>R4
fmsub.d
fmadd.
</code></pre>
<pre><code>rs3 01 rs2 rs1 rm rd 100101
1
</code></pre>
<pre><code>R4
fnmsub.d
fmadd.
</code></pre>
<pre><code>rs3 01 rs2 rs1 rm rd 100111
1
</code></pre>
<pre><code>R4
fnmadd.d
fmadd.
</code></pre>
<pre><code>0000001 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fadd.d
0000101 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fsub.d
0001001 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fmul.d
0001101 rs2 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fdiv.d
0001101 00000 rs1 rm^ rd 101001
1
</code></pre>
<pre><code>R fsqrt.d
0010001 rs2^ rs1 000 rd 101001
1
</code></pre>
<pre><code>R fsgnj.d
0010001 rs2^ rs1 001 rd 101001
1
</code></pre>
<pre><code>R fsgnjn.d
0010001 rs2 rs1 010 rd 101001
1
</code></pre>
<pre><code>R fsgnjx.d
0010101 rs2 rs1 000 rd 101001
1
</code></pre>
<pre><code>R fmin.d
0010101 rs2 rs1 001 rd 101001
1
</code></pre>
<pre><code>R fmax.d
0100000 00001 rs1 rm^ rd 101001
1
</code></pre>
<pre><code>R fcvt.s.d
0100001 00000 rs1 rm^ rd 101001
1
</code></pre>
<pre><code>R fcvt.d.s
1010001 Rs2^ rs1 010 rd 101001
1
</code></pre>
<pre><code>R feq.d
1010001 rs2 rs1 001 rd 101001
1
</code></pre>
<pre><code>R flt.d
1010001 rs2 rs1 000 rd 101001
1
</code></pre>
<pre><code>R fle.d
1110001 00000 rs1 001 rd 101001
1
</code></pre>
<pre><code>R fclass.d
1100001 00000 rs1 rm rd 101001
1
</code></pre>
<pre><code>R fcvt.w.d
1100001 00001 rs1 rm^ rd 101001
1
</code></pre>
<pre><code>R
</code></pre>
<p>1101001 00000 rs1 rm^ rd (^101001) fcvt.wu.d
1
R fmv.d.w
1101001 00001 rs1 rm^ rd 101001
1
R
(^) fmv.d.wu
图 <strong>5.3</strong> ： <strong>RV32D</strong> 操作码表包含了指令布局，操作码，格式类型和名称。这两个图中的一些指令并不仅仅是
数据宽度不同。只有这张表有fcvt.s.d和fcvt.d.s指令，而只有另一张表有fmv.x.w和fmv.w.x**.** 指令
（基于 <strong>[Waterman and Asanovic 2017]</strong> 的表 <strong>19.2</strong> ）。</p>
<pre><code>63 32 31 0
</code></pre>
<p>(^) f0 / ft0 FP Temporary
(^) f1 / ft 1 FP Temporary
(^) f2 / ft 2 FP Temporary
(^) f 3 / ft 3 FP Temporary
(^) f 4 / ft 4 FP Temporary
(^) f 5 / ft 5 FP Temporary
(^) f 6 / ft 6 FP Temporary
(^) f 7 / ft 7 FP Temporary
(^) f 8 / fs 0 FP Saved register
(^) f 9 / fs1 FP Saved register
(^) f 10 / fa 0 FP Function argument, return value
(^) f 11 / fa1 FP Function argument, return value
(^) f 12 / fa2 FP Function argument
(^) f 13 / fa3 FP Function argument
(^) f 14 / fa4 FP Function argument
(^) f 15 / fa5 FP Function argument
(^) f 16 / fa6 FP Function argument
(^) f 17 / fa7 FP Function argument
f 18 / fs2 FP Saved register
(^) f 19 / fs3 FP Saved register
(^) f 20 / fs4 FP Saved register
(^) f 21 / fs5 FP Saved register
(^) f 22 / fs6 FP Saved register
(^) f 23 / fs7 FP Saved register
(^) f 24 / fs8 FP Saved register
(^) f 25 / fs9 FP Saved register
(^) f 26 / fs10 FP Saved register
f 27 / fs11 FP Saved register
(^) f 28 / ft 8 FP Temporary
(^) f 29 / ft 9 FP Temporary
(^) f 30 / ft 10 FP Temporary
(^) f 31 / ft 11 FP Temporary
32 32
图 <strong>5.4</strong> ： <strong>RV32F</strong> 和 <strong>RV32D</strong> 的浮点寄存器。单精度寄存器占用了 <strong>32</strong> 个双精度寄存器中最右边的一半。第 <strong>3</strong>
章解释了 <strong>RISC-V</strong> 对于浮点寄存器的调用约定，阐述了 <strong>FP</strong> 参数寄存器（ <strong>fa0-fa7</strong> ）， <strong>FP</strong> 保存寄存器（ <strong>fs0-
fs11</strong> ）和 <strong>FP</strong> 临时寄存器（ <strong>ft0-ft11</strong> ）背后的基本原理（基于 <strong>[Waterman and Asanovic 2017]</strong> 的表 <strong>20.1</strong> ）。</p>
<p>图 <strong>5.5</strong> ：浮点控制和状态寄存器。它保存舍入模式和异常标志。舍入模式包括向最近的偶数舍入（frm中
的 <strong>rte</strong> ， <strong>000</strong> ） <strong>;</strong> 向零舍入（ <strong>rtz</strong> ， <strong>001</strong> ） <strong>;</strong> 向下(−∞)舍入（ <strong>rdn</strong> ， <strong>010</strong> ） <strong>;</strong> 向上(+∞)舍入（ <strong>rup</strong> ， <strong>011</strong> ） <strong>;</strong> 以及
向最近的最大值舍入（ <strong>rmm</strong> ， <strong>100</strong> ）。 五个累积异常标志表示自上次由软件重置字段以来在任何浮点运算
指令上出现的异常条件： <strong>NV</strong> 表示非法操作 <strong>; DZ</strong> 表示除以零 <strong>; OF</strong> 表示上溢 <strong>; UF</strong> 表示下溢 <strong>; NX</strong> 表示不精确
（基于 <strong>[Waterman andAsanovic 2017]</strong> 的图 <strong>8.2</strong> ）。</p>
<pre><code>图 5.6 ： RV32F 和 RV32D 转换指令。在列中列出了源数据类型，在行中列出转换的目标数据类型。
</code></pre>
<h3 id="54浮点转换和搬运"><a class="header" href="#54浮点转换和搬运">5.4浮点转换和搬运</a></h3>
<h4 id="rv32f和rv32d支持在在-32-位有符号整数-32-位无符号整数-32-位浮点和-64-位之"><a class="header" href="#rv32f和rv32d支持在在-32-位有符号整数-32-位无符号整数-32-位浮点和-64-位之">RV32F和RV32D支持在在 32 位有符号整数， 32 位无符号整数， 32 位浮点和 64 位之</a></h4>
<h4 id="间浮点进行所有组合的转换只要这个转换是有用有意义的图56按源数据类型以及"><a class="header" href="#间浮点进行所有组合的转换只要这个转换是有用有意义的图56按源数据类型以及">间浮点进行所有组合的转换（只要这个转换是有用，有意义的）。图5.6按源数据类型以及</a></h4>
<h4 id="转换后的目的数据类型罗列了这-10-条指令"><a class="header" href="#转换后的目的数据类型罗列了这-10-条指令">转换后的目的数据类型，罗列了这 10 条指令。</a></h4>
<p>RV32F还提供了将数据从f寄存器（fmv.x.w）移动到x寄存器的指令，以及反方向移
动数据的指令（fmv.w.x）。</p>
<h3 id="55其他浮点指令"><a class="header" href="#55其他浮点指令">5.5其他浮点指令</a></h3>
<h4 id="rv32f和rv32d提供了不寻常的指令有助于编写数学库以及提供有用的伪指令"><a class="header" href="#rv32f和rv32d提供了不寻常的指令有助于编写数学库以及提供有用的伪指令">RV32F和RV32D提供了不寻常的指令，有助于编写数学库以及提供有用的伪指令。</a></h4>
<h4 id="ieee-754-浮点标准需要一种复制并且操作符号并对浮点数据进行分类的方式这启发我"><a class="header" href="#ieee-754-浮点标准需要一种复制并且操作符号并对浮点数据进行分类的方式这启发我">（IEEE 754 浮点标准需要一种复制并且操作符号并对浮点数据进行分类的方式，这启发我</a></h4>
<h4 id="们添加了这些指令"><a class="header" href="#们添加了这些指令">们添加了这些指令。）</a></h4>
<h4 id="第一个是符号注入指令它从第一个源操作数复制了除符号位之外的所有内容符号位"><a class="header" href="#第一个是符号注入指令它从第一个源操作数复制了除符号位之外的所有内容符号位">第一个是符号注入指令，它从第一个源操作数复制了除符号位之外的所有内容。符号位</a></h4>
<h4 id="的取值取决于具体是什么指令"><a class="header" href="#的取值取决于具体是什么指令">的取值取决于具体是什么指令：</a></h4>
<ol>
<li>浮点符号注入（fsgnj.s，fsgnj.d）：结果的符号位是rs2的符号位。</li>
<li>浮点符号取反注入（fsgnjn.s，fsgnjn.d）：结果的符号位与rs2的符号位相反。</li>
<li>浮点符号异或注入（fsgnjx.s，fsgnjx.d）：结果符号位是rs1和rs2的符号位异或的
结果。
除了有助于数学库中的符号操作，基于符号注入指令我们还提供了三种流行的浮点伪指
令（参见第 37 页的图3.4）：</li>
</ol>
<h4 id="1-复制浮点寄存器"><a class="header" href="#1-复制浮点寄存器">1. 复制浮点寄存器：</a></h4>
<pre><code>fmv.s rd，rs事实上是fsgnj.s rd，rs，rs
fmv.d rd，rs事实上是sgnj.d rd，rs，rs。
</code></pre>
<pre><code>图 5.7: 用 C 编写的 浮点运算密集型的 DAXPY 程序
</code></pre>
<pre><code>图 5.8 ： DAXPY 在四个 ISA 上生成的指令数和代码大小。它列出了每个循环的指令数量以及指令总数。
第 7 章介绍 ARM Thumb- 2 ， microMIPS 和 RV32C 指令集。
</code></pre>
<ol start="2">
<li>否定：
fneg.s rd，rs映射到fsgnjn.s rd，rs，rs
fneg.d rd，rs映射到fsgnjn.d rd，rs，rs。</li>
<li>绝对值（因为 0 ⊕0= 0且 1 ⊕1= 0）：
fabs.s rd，rs变成了fsgnjx.s rd，rs，rs
fabs.d rd，rs变成了sgnjx.d rd，rs，rs。</li>
</ol>
<p>第二个不常见的浮点指令是classify分类指令（fclass.s，fclass.d）。分类指令对数学库
也很有帮助。他们测试一个源操作数来看源操作数满足下列 10 个浮点数属性中的哪些属性
（参见下表），然后将测试结果的掩码写入目的整数寄存器的低 10 位。十位中仅有一位被设
置为 1 ，其余为都设置为 0 。</p>
<pre><code>x[rd] 位 含义
0 f [ rs1 ]为−∞。
1 f [ rs1 ]是负规格化数。
2 f [ rs1 ]是负的非规格化数。
3 f [ rs1 ]是- 0 。
4 f [ rs1 ]是+0。
5 f [ rs1 ]是正的非规格化数。
6 f [ rs1 ]是正的规格化数。
7 f [ rs1 ]为+∞。
8 f [ rs1 ]是信号(signaling)NaN。
9 f [ rs1 ]是一个安静(quiet)NaN。
</code></pre>
<h3 id="56-使用-daxpy-程序比较-rv32fd--arm--32--mips--32-和-x86--32"><a class="header" href="#56-使用-daxpy-程序比较-rv32fd--arm--32--mips--32-和-x86--32">5.6 使用 DAXPY 程序比较 RV32FD ， ARM- 32 ， MIPS- 32 和 x86- 32</a></h3>
<h4 id="我们现在将使用daxpy作为我们的浮点基准对不同isa进行比较图57它以双精"><a class="header" href="#我们现在将使用daxpy作为我们的浮点基准对不同isa进行比较图57它以双精">我们现在将使用DAXPY作为我们的浮点基准对不同ISA进行比较（图5.7）。它以双精</a></h4>
<p>度计算푌 = 푎×푋+ 푌，其中X和Y是矢量，a是标量。图5.8总结了DAXPY在四个不同
的ISA下对应的指令数和字节数。他们的代码如图5.9至5.12所示。
与第 2 章中的插入排序一样，尽管RISC-V指令集强调本身的简单性，RISC-V版本的
不管是指令数量还是代码大小，都接近或者优于其他ISA。在此示例中，RISC-V的比较和
执行分支指令和ARM- 32 和x 86 - 32 中更复杂的寻址模式，以及入栈、退栈指令节省了差不
多数量的指令。</p>
<h3 id="57结束语"><a class="header" href="#57结束语">5.7结束语..............................................................................................................................................</a></h3>
<pre><code>少即是多。
——Robert Browning, 1855，极简主义（建筑）建筑学派在 20 世纪 80 年代采用这首诗作为公理。
</code></pre>
<p>IEEE 754- 2008 浮点标准[IEEE Standards Committee 2008]定义了浮点数据类型，计算精
度和所需操作。它的广泛流行大大降低了移植浮点程序的难度，这也意味着不同ISA中的浮
点数部分可能比其他章节中描述的其他部分的指令更一致。</p>
<h3 id="58-扩展阅读"><a class="header" href="#58-扩展阅读">5.8 扩展阅读</a></h3>
<p>IEEE Standards Committee. 754-2008 IEEE standard for floating-point arithmetic. IEEE
Computer Society Std, 2008.</p>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I:
User-Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.</p>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<pre><code>补充说明： 16 位， 128 位和十进制浮点运算
修订后的IEEE浮点标准（IEEE 754- 2008 ）除了单精度和双精度之外，还描述了几种新的浮
点数格式，它们称为binary32和binary64。不出意料，修订后，新增了四倍精度，名为
binary128。 RISC-V暂时计划用RV32Q扩展来支持新的浮点数格式（见第 11 章）。该标准
还为二进制数据交换提供了两种新的数据尺寸，程序员可以会将这些浮点数以特定宽度存
储在内存或存储中，但是或许不能以这种宽度进行计算计算。它们分别是半精度（binary16）
和八元精度（binary256）。尽管标准对这两种新宽度的存储使用定义的，但GPU确实以半
精度计算并将它们保存在内存中。 RISC-V的计划在向量指令（第 8 章中的RV32V）中包
含半精度计算，但是前提是处理器如果支持向量半精度指令，则也必须支持半精度标量指
令。令人惊讶的是，修订后标准还添加了十进制浮点数，新增的三种十进制格式分别是
decimal32，decimal64和decimal128。RISC-V预留RV32L指令集扩展用于支持它（见第 11
章）。
</code></pre>
<pre><code>DAXPY这个名字来自
公式本身：以双精度计
算A乘上X加Y
(Double-precision A
times X Plus Y)。此公
式的单精度版本被称做
SAXPY。
</code></pre>
<p>图 <strong>5.9</strong> ：图 <strong>5.7</strong> 中 <strong>DAXPY</strong> 的 <strong>RV32D</strong> 代码。十六进制的地址位于机器的左侧，接下来是十六进制的语言代
码，然后是汇编语言指令，最后是注释。比较和分支指令避免了 <strong>ARM- 32</strong> 和 <strong>X86- 32</strong> 代码中的两条比较指
令。</p>
<pre><code>图 5.10 ：图 5.7 中 DAXPY 的 ARM- 32 代码。 与 RISC-V 相比， ARM- 32 的自动增量寻址模式可以节省
两条指令。与插入排序不同， DAXPY 在 ARM- 32 上不需要压栈和出栈寄存器。
</code></pre>
<p>图 <strong>5.11</strong> ：图 <strong>5.7</strong> 中 <strong>DAXPY</strong> 的 <strong>MIPS- 32</strong> 代码。三个分支延迟槽中的两个填充了有用的指令。检查两个寄存
器之间是否相等的指令避免了 <strong>ARM- 32</strong> 和 <strong>x86- 32</strong> 中的两条比较指令。与整数加载不同，浮点加载没有延
迟槽。</p>
<pre><code>图 5.12 ：图 5.7 中 DAXPY 的 x86- 32 代码。在这个例子中， x86- 32 缺少寄存器的劣势在这里表现得很明
显——有四个变量被分配到了内存，而在其他 ISA 中，这些变量是被存放在寄存器中的。它展示了 x86-
32 中，如何将寄存器与零比较（test ecx，ecx）以及如何将一个寄存器清零（xor eax,eax）。
</code></pre>
<h2 id="第六章-原子指令"><a class="header" href="#第六章-原子指令">第六章 原子指令</a></h2>
<pre><code>所有的事物都应该尽量简单，但是不能太过简单。
——阿尔伯特·爱因斯坦（Albert Einstein）， 1933
</code></pre>
<h3 id="61-导言"><a class="header" href="#61-导言">6.1 导言</a></h3>
<h4 id="我们假定你已经了解了isa对如何支持多进程所以我们在这儿只对rv32a指令和它"><a class="header" href="#我们假定你已经了解了isa对如何支持多进程所以我们在这儿只对rv32a指令和它">我们假定你已经了解了ISA对如何支持多进程，所以我们在这儿只对RV32A指令和它</a></h4>
<h4 id="们的行为进行解释如果你觉得需要一些背景知识补充可以看一下维基百科上的同步计"><a class="header" href="#们的行为进行解释如果你觉得需要一些背景知识补充可以看一下维基百科上的同步计">们的行为进行解释。如果你觉得需要一些背景知识补充，可以看一下维基百科上的“同步（计</a></h4>
<pre><code>算机科学）”词条（英文维基地址：https://en.wikipedia.org/wiki/Synchronization 中文地址：
https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5 ）或者阅读《RISC-V体系结构》 2 .1
节[Patterson and Hennessy 2017]。
RV32A有两种类型的原子操作：
⚫ 内存原子操作（AMO）
⚫ 加载保留/条件存储（load reserved / store conditional）
图 6 .1是RV32A扩展指令集的示意图，图 6 .2列出了它们的操作码和指令格式。
</code></pre>
<pre><code>图 6 .1 RV32A 指令图示
</code></pre>
<pre><code>图 6 .2 RV 32 A 指令格式、操作码、格式类型和名称。（这张图源于 [Waterman and Asanovi ́c 2017] 的表
19. 2 。）
</code></pre>
<p>阿尔伯特·爱因斯坦
（ 1879 - 1955 ）， 20 世
纪最著名的科学家。他
提出了相对论，在第二
次世界大战中提出制
造原子弹。</p>
<h4 id="amo指令对内存中的操作数执行一个原子操作并将目标寄存器设置为操作前的内存"><a class="header" href="#amo指令对内存中的操作数执行一个原子操作并将目标寄存器设置为操作前的内存">AMO指令对内存中的操作数执行一个原子操作，并将目标寄存器设置为操作前的内存</a></h4>
<h4 id="值原子表示内存读写之间的过程不会被打断内存值也不会被其它处理器修改"><a class="header" href="#值原子表示内存读写之间的过程不会被打断内存值也不会被其它处理器修改">值。原子表示内存读写之间的过程不会被打断，内存值也不会被其它处理器修改。</a></h4>
<h4 id="加载保留和条件存储保证了它们两条指令之间的操作的原子性加载保留读取一个内存"><a class="header" href="#加载保留和条件存储保证了它们两条指令之间的操作的原子性加载保留读取一个内存">加载保留和条件存储保证了它们两条指令之间的操作的原子性。加载保留读取一个内存</a></h4>
<h4 id="字存入目标寄存器中并留下这个字的保留记录而如果条件存储的目标地址上存在保留"><a class="header" href="#字存入目标寄存器中并留下这个字的保留记录而如果条件存储的目标地址上存在保留">字，存入目标寄存器中，并留下这个字的保留记录。而如果条件存储的目标地址上存在保留</a></h4>
<h4 id="记录它就把字存入这个地址如果存入成功它向目标寄存器中写入-0-否则写入一个非"><a class="header" href="#记录它就把字存入这个地址如果存入成功它向目标寄存器中写入-0-否则写入一个非">记录，它就把字存入这个地址。如果存入成功，它向目标寄存器中写入 0 ；否则写入一个非</a></h4>
<h4 id="0-的错误代码"><a class="header" href="#0-的错误代码">0 的错误代码。</a></h4>
<h4 id="为什么rv32a要提供两种原子操作呢因为实际中存在两种不同的使用场景"><a class="header" href="#为什么rv32a要提供两种原子操作呢因为实际中存在两种不同的使用场景">为什么RV32A要提供两种原子操作呢？因为实际中存在两种不同的使用场景。</a></h4>
<p>编程语言的开发者会假定体系结构提供了原子的比较-交换（compare-and-swap）操作：
比较一个寄存器中的值和另一个寄存器中的内存地址指向的值，如果它们相等，将第三个寄
存器中的值和内存中的值进行交换。这是一条通用的同步原语，其它的同步操作可以以它为
基础来完成[Herlihy 1991]。
尽管将这样一条指令加入ISA看起来十分有必要，它在一条指令中却需要 3 个源寄存
器和 1 个目标寄存器。源操作数从两个增加到三个，会使得整数数据通路、控制逻辑和指令
格式都变得复杂许多。（RV32FD的多路加法（multiply-add）指令有三个源操作数，但它影
响的是浮点数据通路，而不是整数数据通路。）不过，加载保留和条件存储只需要两个源寄
存器，用它们可以实现原子的比较交换（见图 6 .3的上半部分）。</p>
<pre><code>图 6 .3 同步的两个例子。第一个例子使用加载保留 lr.w/ 条件存储 sc.w 实现比较 - 交换操作；第二个例子使
用原子交换 amoswap.w 实现互斥。
</code></pre>
<p>另外还提供AMO指令的原因是，它们在多处理器系统中拥有比加载保留/条件存储更
好的可扩展性，例如可以用它们来实现高效的归约。AMO指令在于I/O设备通信时也很有
用，可以实现总线事务的原子读写。这种原子性可以简化设备驱动，并提高I/O性能。图 6 .3
的下半部分展示了如何使用原子交换实现临界区。</p>
<pre><code>AMO和LR/SC指令
要求内存地址对齐，
因为保证跨cache行
的原子读写的难度很
大。
</code></pre>
<pre><code>用lr/sc实现内存字M[a0]的比较-交换操作
</code></pre>
<pre><code>用AMO操作实现的测试-置位自旋锁（test and set spinlock）临界区
#初始化锁
#尝试获取锁
#如果失败，继续尝试
...临界区代码...
#释放锁
</code></pre>
<pre><code>#加载旧的值
#比较旧的值与a 1 是否相等
#相等则存入新的值
#如果存入失败，重新尝试
...比较-交换成功之后的代码...
#比较-交换不成功
</code></pre>
<pre><code>补充说明： 内存一致性模型
RISC-V具有宽松的内存一致性模型（relaxed memory consistency model），因此其他线程看
到的内存访问可以是乱序的。图6.2中，所有的RV32A指令都有一个请求位（aq）和一个
释放位（rl）。aq被置位的原子指令保证其它线程在随后的内存访问中看到顺序的AMO操
作；rl被置位的原子指令保证其它线程在此之前看到顺序的原子操作。想要了解更详细的
有关知识，可以查看[Adve and Gharachorloo 1996]。
</code></pre>
<h4 id="有什么不同之处-原始的mips--32-没有同步机制设计者在后来的mips-isa中加入"><a class="header" href="#有什么不同之处-原始的mips--32-没有同步机制设计者在后来的mips-isa中加入">有什么不同之处？ 原始的MIPS- 32 没有同步机制，设计者在后来的MIPS ISA中加入</a></h4>
<h4 id="了加载保留条件存储指令"><a class="header" href="#了加载保留条件存储指令">了加载保留/条件存储指令。</a></h4>
<h3 id="6-2-结束语"><a class="header" href="#6-2-结束语">6. 2 结束语</a></h3>
<h4 id="rv32a是可选的一个risc-v处理器如果没有它就会更加简单然而正如爱因斯坦"><a class="header" href="#rv32a是可选的一个risc-v处理器如果没有它就会更加简单然而正如爱因斯坦">RV32A是可选的，一个RISC-V处理器如果没有它就会更加简单。然而，正如爱因斯坦</a></h4>
<h4 id="所言一切事物都应该尽量简单但不应该太过简单rv-32-a正是如此许多的场景都离不"><a class="header" href="#所言一切事物都应该尽量简单但不应该太过简单rv-32-a正是如此许多的场景都离不">所言，一切事物都应该尽量简单，但不应该太过简单。RV 32 A正是如此，许多的场景都离不</a></h4>
<h4 id="开它"><a class="header" href="#开它">开它。</a></h4>
<h3 id="63-扩展阅读"><a class="header" href="#63-扩展阅读">6.3 扩展阅读</a></h3>
<pre><code>S. V. Adve and K. Gharachorloo. Shared memory consistency models: A tutorial. Computer ,
29(12):66–76, 1996.
</code></pre>
<pre><code>M. Herlihy. Wait-free synchronization. ACM Transactions on Programming Languages and
Systems , 1991.
</code></pre>
<pre><code>D. A. Patterson and J. L. Hennessy. Computer Organization and Design RISC-V Edition: The
Hardware Software Interface. Morgan Kaufmann, 2017.
</code></pre>
<pre><code>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I: User-
Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.
</code></pre>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<h2 id="第七章-压缩指令"><a class="header" href="#第七章-压缩指令">第七章 压缩指令</a></h2>
<pre><code>小即是美。 ——E. F. Schumacher, 1973
</code></pre>
<h3 id="71-导言"><a class="header" href="#71-导言">7.1 导言</a></h3>
<pre><code>以前的ISA为了缩短代码长度而显著扩展了指令和指令格式的数量，比如添加了一些
只有两个（而不是三个）操作数的指令，减小立即数域，等等。ARM和MIPS为了能缩小
代码，重新设计了两遍指令集，ARM设计出了ARM Thumb和Thumb 2，MIPS先后设计
出了MIPS16和microMIPS。这些新的ISA为处理器和编译器增加了负担，同时也增加了
汇编语言程序员的认知负担。
RV32C采用了一种新颖的方法：每条短指令必须和一条标准的 32 位RISC-V指令一一
对应。此外， 16 位指令只对汇编器和链接器可见，并且是否以短指令取代对应的宽指令由
它们决定。编译器编写者和汇编语言程序员可以幸福地忽略RV32C指令及其格式，他们能
感知到的则是最后的程序大小小于大多数其它ISA的程序。图7.1是RV32C扩展指令集的
图形化表示。
为了能在一系列的程序上得到良好的代码压缩效果，RISC-V架构师精心挑选了RVC
扩展中的指令。同时，基于以下的三点观察，架构师们成功地将指令压缩到了 16 位。第
一，对十个常用寄存器（a0-a5，s0-s1，sp以及ra）访问的频率远超过其他寄存器；第
二，许多指令的写入目标是它的源操作数之一；第三，立即数往往很小，而且有些指令比
较喜欢某些特定的立即数。因此，许多RV32C指令只能访问那些常用寄存器；一些指令隐
式写入源操作数的位置；几乎所有的立即数都被缩短了，load和store操作只使用操作数整
数倍尺寸的无符号数偏移量。
</code></pre>
<pre><code>图 7.1 ： RV32C 的指令图示。移位指令的立即数域和 c.addi4spn 是零扩展的，其它指令采用符号位扩展。
</code></pre>
<p>E.F.Schumacher
（ 1911 - 1977 ）撰写了
一本经济学著作，主张
人性化，分散化和适当
的技术。它被翻译成多
种语言，被评为第二次
世界大战以来最具影
响力的 100 本书之一。</p>
<pre><code>图 7.2 ：用压缩指令集写成的插入排序和 DAXPY 程序的指令数和代码长度。
</code></pre>
<p>图7.3和7.4列出了插入排序和DAXPY程序的RV32C代码。我们展示了这些RV32C
指令，从而清楚地显示了这些压缩操作的效果，但是通常这些指令在汇编程序中是不可见
的。注释中在括号内标出了与RV32C指令对应的等效 32 位指令。附录A中完整列出了 16
位RV32C指令和 32 位RISC-V指令的对应关系。
例如，在图7.3的插入排序程序中地址为 4 的地方，汇编器将如下的 32 位RV32I指
令：
addi a4,x0,1 # i = 1
替换为了这条 16 位RV32C指令：
c.li a4,1 # （可扩展为 addi a4,x0,1） i = 1
RV32C的load立即数指令比较短，是因为它只能指定一个寄存器和一个小的立即数。
c.li的机器码在图7.3中只有 4 个十六进制数，这表明c.li指令确实只有 2 字节长。
另一个例子在图7.3中地址为 10 的地方，汇编器将：
add a2,x0,a3 # a2是指向a[j]的指针
换成了这条 16 位RV32C指令：
c.mv a2,a3 #（可扩展为add a2,x0,a3） a2是指向a[j]的指针
RV32C的move指令只有 16 位长，因为它只指定两个寄存器。
尽管处理器的设计者们不能忽略RV32C的存在，但是有一个技巧可以让实现的代价变
小：在执行之前用一个解码器将所有的 16 位指令转换为等价的 32 位指令。图7.6到7.8列
出了解码器可以转换的RV32C指令的格式和操作码。最小的不支持任何扩展的 32 位
RISC-V处理器要用到 8000 个门电路，而解码器只要 400 个门。如果它在这么小的设计中
都只占5%的体量，那么它在约有 100 , 000 个门的中等大小带有cache的处理器中相当于不
占资源。</p>
<p>有什么不同之处？RV32C中没有字节或半字指令，因为其他指令对代码长度的影响更大。
第 9 页图1.5中Thumb- 2 相对于RV32C，在代码长度上更有优势，这是由于Load and Store
Multiple对于过程（函数、子例程）进入和退出时可以节省不少代码。为了保证能和
RV32G中的指令一一对应，RV32C中没有包括它们。而RV32G为了降低高端处理器的实
现复杂性而省略了这些指令。由于Thumb- 2 是独立于ARM- 32 的ISA，但是处理器可以在
两个ISA间切换。为了支持两套ISA，硬件必须有两个指令解码器，一个用于ARM- 32 ，
一个用于Thumb- 2 。RV32GC是一个单独的ISA，因此RISC-V处理器只需要一个解码器。</p>
<pre><code>补充说明：为什么有些架构师不考虑RV32C？
超标量处理器在一个时钟周期内同时取几条指令，因此译码阶段可能成为超标量处理器的
瓶颈。macrofusion是另一个例子，其中指令解码器把RISC-V指令组合为更加强大的指令
来执行（参见第一章）。在这种情况下， 16 位RV32C指令和 32 位RV32I指令混杂在一起增
加了解码的复杂度，从而使得高性能处理器中在一个时钟周期内完成解码变得更难。
</code></pre>
<h3 id="72-rv32gcthumb--2-micromips和x86--32-的比较"><a class="header" href="#72-rv32gcthumb--2-micromips和x86--32-的比较">7.2 RV32GC，Thumb- 2 ，microMIPS和x86- 32 的比较</a></h3>
<p>图7.2汇总了这四个ISA写成的插入排序和DAXPY程序的代码大小。
在插入排序的原始 19 条RV32I指令中， 12 条被替换成了RV32C指令，所以代码长
度从 19 × 4 = 76 个字节变成了 12 × 2 + 7 × 4 = 52 个字节，节省了 24 / 76 =32%。DAXPY
程序从 11 × 4 = 44 个字节缩减到了 8 × 2 + 3 × 4 = 28 个字节，节省了 16 / 44 =36%。
这两个小例子的结果与第二章第 9 页的图1.5惊人的一致，那里提到说，对于更多更
复杂的程序，RV32G代码比RV32GC代码长37%。要达到这种程度的长度缩减，程序中必
须有一半的指令可以被替换成RV32C指令。</p>
<h3 id="73-结束语"><a class="header" href="#73-结束语">7.3 结束语</a></h3>
<p>我本可以把信写得更短，但我没有时间。——Blaise Pascal, 1656
他是建造了第一台机械计算器的数学家，因此图灵奖得主Niklaus Wirth用他的名字命名了一门编程语言。</p>
<p>RV32C让RISC-V程序拥有了当今几乎最小的代码尺寸。你几乎可以将它们视为硬件
协助的伪指令。但是，现在汇编器将它们在汇编语言程序员和编译器编写者面前隐藏起
来。这里我们没有像第三章那样，将能提升RISC-V代码易用性与易读性的常用操作的组
织成指令，来扩展真实的指令集。这两种方法都有助于提供程序员的工作效率。
RISC-V提倡用一套简洁、有效的机制来提升性价比，RV32C就是一个极佳的范例。</p>
<h3 id="74-扩展阅读"><a class="header" href="#74-扩展阅读">7.4 扩展阅读</a></h3>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I: User-
Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.</p>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<pre><code>补充说明：RV32C真的是独一无二的吗？
RV32指令在RV32IC中无法区分。Thumb- 2 实际上是一个单独的ISA，包含 16 位指令和
ARMv7中大多数（但不是全部）的指令。例如，在Thumb- 2 中有Compare and Branch on
Zero，而ARMv7中没有，而对于Reverse Subtarct with Carry则正好相反。microMIPS也不
是MIPS32的超集。例如，microMIPS计算分支偏移量的时候乘以 2 ，但在MIPS32中则为
4 。RISC-V中总是乘以 2 。
</code></pre>
<p>图 <strong>7.3</strong> ：插入排序的 <strong>RV32C</strong> 代码。 <strong>12</strong> 条 <strong>16</strong> 位指令使得代码长度缩减了 <strong>32 %</strong> 。每条指令的宽度可以很容
易地得知。 <strong>RV32C</strong> 指令（以c.开头）在这个例子中显式出现，但通常汇编语言程序员和编译器无法看到
它们。</p>
<p>图 <strong>7.4</strong> ： <strong>DAXPY</strong> 的 <strong>RV32DC</strong> 代码。 <strong>8</strong> 条十六位指令将代码长度缩减了 <strong>36%</strong> 。每条指令的宽度见第二列的
十六进制字符个数。 <strong>RV32C</strong> 指令（以c.开头）在这个例子中显式出现，但通常汇编语言程序员和编译器
无法看到它们。</p>
<pre><code>图 7.5 ： RV32C 操作码映射（ bits[1:0] = 01 ）列出了指令布局，操作码，指令格式和指令名称。 rd’,rs1’ 和
rs2’ 指的是 10 个常用的寄存器a0-a5，s0-s1，sp和ra。（本图来源于 [Waterman and Asanovi ́c 2017] 的表
12.5 。）
</code></pre>
<p>图 <strong>7.6</strong> ： <strong>RV32C</strong> 操作码表（ <strong>bits[1:0] = 00</strong> ）列出了指令布局，操作码，指令格式和指令名称。 <strong>rd’,rs1’</strong> 和 <strong>rs2’</strong>
指的是 <strong>10</strong> 个常用的寄存器a0-a5，s0-s1，sp和ra。（本图来源于 <strong>[Waterman and Asanovi ́c 2017]</strong> 的表
<strong>12.4</strong> 。）</p>
<pre><code>图 7.7 ： RV32C 操作码表（ bits[1:0] = 10 ）列出了指令布局，操作码，指令格式和指令名称。（本图来源于
[Waterman and Asanovi ́c 2017] 的表 12.6 。）
</code></pre>
<p>图 <strong>7.8</strong> ： <strong>16</strong> 位 <strong>RVC</strong> 压缩指令的格式。rd’,rs1’和rs2’指的是 <strong>10</strong> 个常用的寄存器a0-a5，s0-s1，sp和ra。（本图
来源于 <strong>[Waterman and Asanovi ́c 2017]</strong> 的表 <strong>12.1</strong> 。）</p>
<h2 id="第八章-向量"><a class="header" href="#第八章-向量">第八章 向量</a></h2>
<pre><code>我追求简洁。我理解不了那些复杂的东西。——Seymour Cray
</code></pre>
<h3 id="81-导言"><a class="header" href="#81-导言">8.1 导言</a></h3>
<h4 id="本章重点介绍数据并行当存在大量数据可供应用程序同时计算时我们称之为数据"><a class="header" href="#本章重点介绍数据并行当存在大量数据可供应用程序同时计算时我们称之为数据">本章重点介绍数据并行，当存在大量数据可供应用程序同时计算时，我们称之为数据</a></h4>
<h4 id="级并行性数组是一个常见的例子虽然它是科学应用的基础但它也被多媒体程序使"><a class="header" href="#级并行性数组是一个常见的例子虽然它是科学应用的基础但它也被多媒体程序使">级并行性。数组是一个常见的例子。虽然它是科学应用的基础，但它也被多媒体程序使</a></h4>
<h4 id="用前者使用单精度和双精度浮点数据后者通常使用-8-位和-16-位整数数据"><a class="header" href="#用前者使用单精度和双精度浮点数据后者通常使用-8-位和-16-位整数数据">用。前者使用单精度和双精度浮点数据，后者通常使用 8 位和 16 位整数数据。</a></h4>
<pre><code>最著名的数据级并行架构是单指令多数据(SIMD，Single Instruction Multiple Data)。
SIMD最初的流行是因为它将 64 位寄存器的数据分成许多个 8 位、 16 位或 32 位的部分，
然后并行地计算它们。操作码提供了数据宽度和操作类型。数据传输只用单个（宽）SIMD
寄存器的load和store进行。
把现有的 64 位寄存器进行拆分的做法由于其简单性而显得十分诱人。为了使SIMD
更快，架构师随后加宽寄存器以同时计算更多部分。由于SIMD ISA属于增量设计阵营的
一员，并且操作码指定了数据宽度，因此扩展SIMD寄存器也就意味着要同时扩展SIMD
指令集。将SIMD寄存器宽度和SIMD指令数量翻倍的后续演进步骤都让ISA走上了复杂
度逐渐提升的道路，这一后果由处理器设计者、编译器编写者和汇编语言程序员共同承
担。
一个更老的，并且在我们看来更优雅的，利用数据级并行性的方案是向量架构。本章
解释了我们在RISC-V中使用向量而不是SIMD的理由。
</code></pre>
<pre><code>图 8.1 ： RV32V 的指令图示。由于采用了动态寄存器类型，这个指令图示也可以不加改变地用于第九章的
RV64V
</code></pre>
<p><strong>Seymour Cray</strong> ( 1925 -
1996 )是 1976 年第一个
采用向量架构的，并且
在商业上取得成功的
超级计算机Cray- 1 的
架构师。Cray- 1 是一颗
明珠，即使没有使用向
量指令，它也是世界上
最快的计算机。</p>
<pre><code>1997 年的英特尔多媒
体扩展（M M X）使
SIMD流行起来。它们
通过 1999 年的流媒体
S I M D扩展（SSE,
S t r e a m i n g S I M D
Extensions）和 2010 年
的高级向量扩展（AVX）
得到了接受和扩展。
MMX的名声在英特尔
的一则广告中得到了宣
扬，该广告的内容是一
种采用彩色干净套装的
半导体产品线的光纤工
作者在跳迪斯科(https：
//www.youtube.com/wat
ch?v=paU16B-bZEA)。
</code></pre>
<h4 id="向量计算机从内存中中收集数据并将它们放入长的顺序的向量寄存器中在这些向"><a class="header" href="#向量计算机从内存中中收集数据并将它们放入长的顺序的向量寄存器中在这些向">向量计算机从内存中中收集数据并将它们放入长的，顺序的向量寄存器中。在这些向</a></h4>
<h4 id="量寄存器上流水线执行单元可以高效地执行运算然后向量架构将结果从向量寄存器"><a class="header" href="#量寄存器上流水线执行单元可以高效地执行运算然后向量架构将结果从向量寄存器">量寄存器上，流水线执行单元可以高效地执行运算。然后，向量架构将结果从向量寄存器</a></h4>
<h4 id="中取出并将其并分散地存回主存向量寄存器的大小由实现决定而不是像simd中那"><a class="header" href="#中取出并将其并分散地存回主存向量寄存器的大小由实现决定而不是像simd中那">中取出，并将其并分散地存回主存。向量寄存器的大小由实现决定，而不是像SIMD中那</a></h4>
<h4 id="样嵌入操作码中我们将会看到将向量的长度和每个时钟周期可以进行的最大操作数分"><a class="header" href="#样嵌入操作码中我们将会看到将向量的长度和每个时钟周期可以进行的最大操作数分">样嵌入操作码中。我们将会看到，将向量的长度和每个时钟周期可以进行的最大操作数分</a></h4>
<h4 id="离是向量体系结构的关键所在向量微架构可以灵活地设计数据并行硬件而不会影响到"><a class="header" href="#离是向量体系结构的关键所在向量微架构可以灵活地设计数据并行硬件而不会影响到">离，是向量体系结构的关键所在：向量微架构可以灵活地设计数据并行硬件而不会影响到</a></h4>
<h4 id="程序员程序员可以不用重写代码就享受到长向量带来的好处此外向量架构比simd"><a class="header" href="#程序员程序员可以不用重写代码就享受到长向量带来的好处此外向量架构比simd">程序员，程序员可以不用重写代码就享受到长向量带来的好处。此外，向量架构比SIMD</a></h4>
<h4 id="架构拥有更少的指令数量而且与simd不同向量架构有着完善的编译器技术"><a class="header" href="#架构拥有更少的指令数量而且与simd不同向量架构有着完善的编译器技术">架构拥有更少的指令数量。而且，与SIMD不同，向量架构有着完善的编译器技术。</a></h4>
<h4 id="向量架构比simd架构更少出现因此知晓向量isa的读者也更少因此本章会比"><a class="header" href="#向量架构比simd架构更少出现因此知晓向量isa的读者也更少因此本章会比">向量架构比SIMD架构更少出现，因此知晓向量ISA的读者也更少。因此，本章会比</a></h4>
<p>前几章更加具有教程的风格。如果你想深入了解向量架构，请阅读[Hennessy and Patterson
2011]的第 4 章和附录G。RV32V还有一些简化了ISA的新颖功能。即使你已经熟悉了向
量架构，也可能需要阅读我们的进一步解释。</p>
<h3 id="82-向量计算指令"><a class="header" href="#82-向量计算指令">8.2 向量计算指令</a></h3>
<h4 id="图81是rv32v扩展指令集的图形表示rv32v的编码尚未最终确定所以本版不包"><a class="header" href="#图81是rv32v扩展指令集的图形表示rv32v的编码尚未最终确定所以本版不包">图8.1是RV32V扩展指令集的图形表示。RV32V的编码尚未最终确定，所以本版不包</a></h4>
<h4 id="含通常的指令布局图"><a class="header" href="#含通常的指令布局图">含通常的指令布局图。</a></h4>
<h4 id="前面章节提到的每一个整数和浮点计算指令基本都有对应的向量版本图81中的指"><a class="header" href="#前面章节提到的每一个整数和浮点计算指令基本都有对应的向量版本图81中的指">前面章节提到的每一个整数和浮点计算指令基本都有对应的向量版本：图8.1中的指</a></h4>
<h4 id="令继承了来自rv32irv32mrv32frv32d和rv32a的操作每个向量指令都有几"><a class="header" href="#令继承了来自rv32irv32mrv32frv32d和rv32a的操作每个向量指令都有几">令继承了来自RV32I、RV32M、RV32F、RV32D和RV32A的操作。每个向量指令都有几</a></h4>
<p>种类型，具体取决于源操作数是否都是向量（.vv后缀），或者源操作数包含一个向量和一
个标量（.vs后缀）。一个标量后缀意味着有一个操作数来自x或f寄存器，另一个来自向
量寄存器（v）。比方说，我们的DAXPY程序（见第 55 页第五章图5.7）计算푌=푎×푋+
푌。其中푋和푌是向量，푎是标量。对于向量-标量操作，rs1域指定了要访问的标量寄存器。
对诸如减法和除法之类的非对称运算，他们还会使用向量指令的第三种变体。其中第
一个操作数是标量，第二个是向量（.sv后缀）。像푌=푎−푋这样的操作就会使用这种变
体。这种变体对于加法和乘法等对称运算来说是多余的，因此这些指令没有.sv的版本。融
合的（fused）乘法-加法指令有三个操作数，因此它们有着最多的向量和标量选项的组
合：.vvv、.vvs，.vsv和.vss。
读者可能会注意到，图8.1忽略了向量运算的数据类型和宽度。下一节解释了这么做
的原因。</p>
<h3 id="83-向量寄存器和动态类型"><a class="header" href="#83-向量寄存器和动态类型">8.3 向量寄存器和动态类型</a></h3>
<p>RV32V添加了 32 个向量寄存器，它们的名称以v开头，但每个向量寄存器的元素个
数不同。该数量取决于操作的宽度和专用于向量寄存器的存储大小，而这取决于处理器的
设计者。比方说，如果处理器为向量寄存器分配了 4096 个字节，则这足以让这些 32 个向
量寄存器中有 16 个 64 位元素，或者 32 个 32 位元素，或者 64 个 16 位元素，或 128 个 8
位元素。
为了在向量ISA中保持元素数量的灵活性，向量处理器会计算会最大向量长度
（mvl），即在给定的容量限制下，向量程序使用这个向量寄存器可以运算的最大向量长
度。向量长度寄存器（vl）为特定操作设定了向量中含有的元素数量，这有助于数组维度
不是mvl的整数倍时的编程。我们将在下面的小节中更详细地演示mvl，vl和 8 个谓词寄</p>
<pre><code>存器（vpi）的应用。
RV32V采用了一种新颖的方法，即将数据类型和长度与向量寄存器而不是与指令操作
码相关联。程序在执行向量计算指令之前用它们的数据类型和宽度标记向量寄存器。使用
动态寄存器类型会减少向量指令的数量。这一点很重要，因为每个向量指令通常有六个整
数版本和三个浮点版本，如图8.1所示。我们将在第8.9节看到，当我们面对众多的SIMD
指令时，使用动态寄存器类型的向量架构减少了汇编语言程序员的认知负担以及编译器生
成代码的难度。
动态类型的另一个优点是程序可以禁用未使用的向量寄存器。此功能可以将所有的向
量存储器分配给已启用的向量寄存器。比如，假设只启用了两个 64 位浮点类型的向量寄存
器，处理器有 1024 字节的向量寄存器空间。处理器将这些空间对半分，给每个向量寄存器
512 字节（512/8=64个元素），因此将mvl设置位 64 。因此我们可以看到，mvl是动态
的，但它的值由处理器设置，不能由软件直接改变。
源寄存器和目标寄存器决定了操作的类型和大小以及结果，因此动态类型隐含了转
换。例如，处理器可以将双精度浮点数的向量乘以单精度标量，而无需先将操作数转换为
相同的精度。这个额外的好处减少了向量指令的总数和实际执行的指令的数量。
可以用vsetdcfg指令来设置向量寄存器的类型。图8.2显示了RV32V可用的向量寄
存器类型以及RV64V的更多类型（见第九章）。RV32V要求向量浮点运算也有标量版本。
因此，要使用F32类型，你也必须用到RV32FV；要使用F64类型，你也必须用到
RV32FDV。RV32V引入了 16 位浮点类型F16。如果一个实现同时支持RV32V和RV32F，
则它必须支持F16和F32类型。
</code></pre>
<pre><code>图 8.2 ： RV32V 向量寄存器类型的编码。字段的最右边三位指示了数据的位宽，左边两位给出其类型。
X64 和 U64 仅适用于 RV64V 。 F16 和 F32 需要 RV32F 扩展， F64 需要 RV32F 和 RV32D 。 F16 是 IEEE
754 - 2008 16 位浮点格式（ binary16 ）。将vetype设置为 00000 会禁用向量寄存器。（本图基于 [Waterman
and Asanovic 2017] 的表 17.4 。）
</code></pre>
<pre><code>补充说明：RV32V可以快速切换上下文
向量架构不如SIMD架构受欢迎的一个原因是：大家担心增加大型向量寄存器会延长中断
时保存和恢复程序（上下文切换）的时间。动态寄存器类型对此很有帮助。程序员必须告诉
处理器正在使用哪些向量寄存器，这意味着处理器需要在上下文切换中仅保存和恢复那些
寄存器。RV32V约定在不使用向量指令的时候禁用所有向量寄存器，这意味着处理器既可
以具有向量寄存器的性能优势，又仅会在向量指令执行过程中发生中断时才会带来额外的
上下文切换开销。早期的向量架构在发生中断时，不得不忍受保存和恢复全部向量寄存器的
最大的上下文切换开销。
</code></pre>
<pre><code>为了避免上下文切换时
间过慢，英特尔尽量避
免在原始MMX SIMD
扩展中添加寄存器。它
只是重用现有的浮点寄
存器，这意味着没有额
外的上下文切换，但程
序无法同时出现浮点和
多媒体指令。
</code></pre>
<p>每个load和store指令
都有一个 7 位的无符号
立即数偏移量。它对于
load按照目标寄存器的
元素类型进行缩放，而
对于store则按源寄存
器缩放。</p>
<h3 id="84-向量的load和store操作"><a class="header" href="#84-向量的load和store操作">8.4 向量的Load和Store操作</a></h3>
<p>向量Load和Store操作的最简单情况是处理按顺序存储在内存中的一维数组。向量
Load用以vld指令中地址为起始地址的顺序存储的数据来填充向量寄存器。向量寄存器的
数据类型确定数据元素的大小，向量长度寄存器vl中设置了要取的元素数量。向量store
执行vld的逆操作。
例如，如果a0中存有 1024 ，且v0的类型是X32，则vld v0, 0(a0)会生成地址 1024 ，
1028 ， 1032 ， 1036 ，......直到达到由vl设置的限制。
对于多维数组，某些访问不是顺序的。如果二维数组以行优先序存储，且对列元素进
行顺序访问，则相邻列元素之间的地址差正好是行大小。向量架构通过跨步数据传输来支
持vlds和vsts数据访问。对于vlds与vsts，虽然可以通过将步长设置为元素大小来达到
与vld和vst相同的效果，但vld和vst保证了所有的访问都是顺序的，这可以提供更高
的内存带宽。另一个原因是，对于常见的按单位步长访问，使用vld和vst可以缩减代码
长度，并减少执行的指令数。毕竟使用vlds和vsts指令来需要指定两个源寄存器，一个
给出起始地址，另一个给出以字节为单位的步长，而对于单位步长的访问，多花指令来设
置第二个寄存器，无遗是一种浪费。
例如，假设a0中的起始地址是地址 1024 ，且a1中行的长度是 64 字节。vlds v0,
a0, a1会将这个地址序列发送到内存： 1024 , 1088 ( 1024 + 1 × 64 ), 1152 ( 1024 +
2 × 64 ), 1216 ( 1024 + 3 × 64 )，以此类推，直到向量长度寄存器vl告诉它停止。返回的数
据被顺序写入目标向量寄存器的各个元素。
到目前为止，我们都假设该程序在对密集数组进行操作。为了支持稀疏数组，向量架
构用vldx和vstx提供索引数据传输。这些指令的一个源寄存器是向量寄存器，另一个是
标量寄存器。标量寄存器具有稀疏数组的起始地址，向量寄存器的每个元素包含稀疏数组
的非零元素的字节索引。
假设a0中的起始地址是地址 1024 ，向量寄存器v1在前四个元素中有这些字节索
引： 16 ， 48 ， 80 ， 160 。vldx v0, a0, v1会将这个地址序列发送到内存： 1040 （ 1024 +
16 ）, 1072 ( 1024 + 48 ), 1104 ( 1024 + 80 ), 1184 ( 1024 + 160 )。它将返回的数据顺序写入目
标向量寄存器的元素中。
以上我们把稀疏数组访问作为索引Load和Store操作的主要支持目标，但是还有许多
其他算法通过索引表来间接访问数据。</p>
<h3 id="85-向量操作期间的并行性"><a class="header" href="#85-向量操作期间的并行性">8.5 向量操作期间的并行性</a></h3>
<h4 id="虽然简单的向量处理器一次操作一个向量元素但由于元素操作根据定义是独立的"><a class="header" href="#虽然简单的向量处理器一次操作一个向量元素但由于元素操作根据定义是独立的">虽然简单的向量处理器一次操作一个向量元素，但由于元素操作根据定义是独立的，</a></h4>
<h4 id="所以理论上处理器可以同时计算所有这些元素rv32g的数据位宽最大位-64-位而如今"><a class="header" href="#所以理论上处理器可以同时计算所有这些元素rv32g的数据位宽最大位-64-位而如今">所以理论上处理器可以同时计算所有这些元素。RV32G的数据位宽最大位 64 位，而如今</a></h4>
<h4 id="的向量处理器通常在每个时钟周期内操作两个四个或八个-64-位元素当向量长度不是每"><a class="header" href="#的向量处理器通常在每个时钟周期内操作两个四个或八个-64-位元素当向量长度不是每">的向量处理器通常在每个时钟周期内操作两个、四个或八个 64 位元素。当向量长度不是每</a></h4>
<h4 id="个时钟周期执行的元素数量的倍数时由硬件处理处理这些边缘情况"><a class="header" href="#个时钟周期执行的元素数量的倍数时由硬件处理处理这些边缘情况">个时钟周期执行的元素数量的倍数时，由硬件处理处理这些边缘情况。</a></h4>
<h4 id="与simd一样对于较小数据的操作数量是较窄数据的位宽和较宽数据的位宽之比"><a class="header" href="#与simd一样对于较小数据的操作数量是较窄数据的位宽和较宽数据的位宽之比">与SIMD一样，对于较小数据的操作数量是较窄数据的位宽和较宽数据的位宽之比。</a></h4>
<h4 id="因此每个时钟周期计算-4-个-64-位操作的向量处理器通常每个时钟周期可以做-8-个-32"><a class="header" href="#因此每个时钟周期计算-4-个-64-位操作的向量处理器通常每个时钟周期可以做-8-个-32">因此，每个时钟周期计算 4 个 64 位操作的向量处理器通常每个时钟周期可以做 8 个 32</a></h4>
<h4 id="位-16-个-16-位或-32-个-8-位操作"><a class="header" href="#位-16-个-16-位或-32-个-8-位操作">位， 16 个 16 位或 32 个 8 位操作。</a></h4>
<h4 id="在simd中isa架构师在设计过程中决定了每个时钟周期可以并行操作的最大数据"><a class="header" href="#在simd中isa架构师在设计过程中决定了每个时钟周期可以并行操作的最大数据">在SIMD中，ISA架构师在设计过程中决定了每个时钟周期可以并行操作的最大数据</a></h4>
<h4 id="数和每个寄存器的元素个数相比之下rv32v处理器设计人员无需更改isa或编译器就"><a class="header" href="#数和每个寄存器的元素个数相比之下rv32v处理器设计人员无需更改isa或编译器就">数和每个寄存器的元素个数。相比之下，RV32V处理器设计人员无需更改ISA或编译器就</a></h4>
<pre><code>带索引的load也称为
收集( gather )；带索引
的store通常称为分散
( scatter )。
</code></pre>
<h4 id="可以选择它们的值而对于simd寄存器每增加一倍都会使simd指令的数量翻倍并"><a class="header" href="#可以选择它们的值而对于simd寄存器每增加一倍都会使simd指令的数量翻倍并">可以选择它们的值，而对于SIMD，寄存器每增加一倍都会使SIMD指令的数量翻倍，并</a></h4>
<h4 id="且需要修改simd编译器这种隐藏的灵活性意味着相同的rv32v程序不用改变就可以"><a class="header" href="#且需要修改simd编译器这种隐藏的灵活性意味着相同的rv32v程序不用改变就可以">且需要修改SIMD编译器。这种隐藏的灵活性意味着相同的RV32V程序不用改变，就可以</a></h4>
<h4 id="在最简单或最复杂的向量处理器上运行"><a class="header" href="#在最简单或最复杂的向量处理器上运行">在最简单或最复杂的向量处理器上运行。</a></h4>
<h3 id="86-向量运算的条件执行"><a class="header" href="#86-向量运算的条件执行">8.6 向量运算的条件执行</a></h3>
<pre><code>一些向量计算包括if语句。向量架构不依赖于条件分支，而是包含了一个掩码，这个
掩码禁止向量操作作用于某些元素。图8.1中的谓词指令在两个向量或向量和标量之间执
行条件测试，如果条件成立则在掩码向量的每一个元素中写入一个 1 ，反之写入 0 。（掩码
向量必须和向量寄存器有相同的元素个数。）任何后续的向量指令都可以使用这个掩码。第
i位为 1 表示元素i会被向量运算更改，为 0 表示该元素不会由向量运算改变。
RV32V为掩码向量提供了 8 个向量谓词寄存器（vpi）。vpand，vpandn，vpor，
vpxor和vpnot指令在它们之间执行逻辑运算，从而有效处理嵌套条件语句。
RV32V指定vp0或vp1作为控制向量操作的掩码。要对所有元素执行一个正常的操
作，必须将这两个谓词寄存器中的一个设置为全 1 。RV32V中有一条vpswap指令，用于
将其他六个谓词寄存器的一个快速交换到vp0或vp1。谓词寄存器也是动态启用的，禁用
它们可以快速清除所有谓词寄存器中的值。
例如，假设向量寄存器v3中的所有偶数元素都是负整数，所有奇数元素都是正整数。
考虑如下的代码：
vplt.vs vp0,v3,x0 # 将 v3 &lt; 0的掩码位置 1
add.vv,vp0 v0,v1,v2 # 将v0的掩码为 1 的对应元素替换为v1+v2
这段代码将把vp0中所有的偶数位设为 1 ，奇数位设为 0 ，并且将把v0中所有的偶数元素
替换为v1和v2中对应元素的和。v0中的奇数元素不会改变。
</code></pre>
<h3 id="87-其他向量指令"><a class="header" href="#87-其他向量指令">8.7 其他向量指令</a></h3>
<pre><code>除了之前提到过的设置向量寄存器数据类型的指令（vsetdcfg），其他指令还有
setvl，它将向量长度寄存器（vl）设置为源操作数和最大向量长度（mvl）中的较小值。
选择较小值的原因是，在循环中我们需要判断这些向量代码到底是可以按最大向量长度
（mvl）运行，还是要以一个较小值运行，从而能处理循环尾部剩下的元素。因此，为了
处理循环尾部的元素，每次循环迭代都执行setvl。
RV32V中还有三条指令可以操作向量寄存器中的元素。
向量选择（vselect）按第二个源向量（索引向量）指定的元素位置，从第一个源数据
向量中取得元素，从而生成一个新的结果向量：
# vindices存有 0 到mvl- 1 的值，它们用来从vsrc中选取元素
vselect vedst, vsrc, vindices
因此，如果v2的前四个元素是 8 、 0 、 4 、 2 ，那么vselect v0, v1, v2将用v1的第 8 个元
素替换v0的第 0 个元素；v1的第 0 个元素替换v0的第 1 个元素；v1的第 4 个元素替换
v0的第 2 个元素；v1的第 2 个元素替换v0的第 3 个元素。
向量合并（vmerge）类似于向量选择，但它用向量谓词寄存器来选择源向量中要用到
元素。新的结果向量由根据谓词寄存器从两个源寄存器之一取得元素产生。若谓词向量寄
</code></pre>
<p>当一个程序中的绝大
部分操作都是用向量
指令来实现的，那么这
个程序被称为可向量
化。Gather，scatter，以
及谓词指令让更多的
程序变得可向量化了。</p>
<p>存器元素为 0 ，则新元素来自vsrc1；如果为 1 ，则来自vsrc2。</p>
<h1 id="vp0的第i位决定vdest中新元素i来自vsrc1若第i位是-0-"><a class="header" href="#vp0的第i位决定vdest中新元素i来自vsrc1若第i位是-0-">vp0的第i位决定vdest中新元素i来自vsrc1（若第i位是 0 ）</a></h1>
<h1 id="还是vsrc2第i位为-1-"><a class="header" href="#还是vsrc2第i位为-1-">还是vsrc2（第i位为 1 ）</a></h1>
<p>vmerge,vp0 vdest, vsrc1, vsrc2
因此，如果vp0的前四个元素是 1 、 0 、 0 、 1 ，v1的前四个元素是 1 、 2 、 3 、 4 ，v2的前四
个元素是 10 、 20 、 30 、 40 ，那么vmerge,vp0 v0, v1, v2将把v0的前四个元素变为 10 、
2 、 3 、 40 。
向量提取指令从一个向量的中间开始取元素，并将它们放在第二个向量寄存器的开
头：</p>
<h1 id="start是一个标量寄存器其中存储着从vsrc中取元素的起始位置"><a class="header" href="#start是一个标量寄存器其中存储着从vsrc中取元素的起始位置">start是一个标量寄存器，其中存储着从vsrc中取元素的起始位置</a></h1>
<p>vextract vdest, vsrc, start
例如，如果向量长度vl是 64 ，而a0的值是 32 ，那么vextract v0,v1,a0会把v1中的后
32 个元素复制到v0的前三十二个元素。
对于任意的二元结合运算符，可以利用vextract指令以递归减半的方法进行缩减运
算。例如，要对向量寄存器的所有元素求和，可以用vextract将向量的后半部分复制到另
一个向量寄存器的前半部分，这就将向量长度缩短了一半。接下来，将这两个向量寄存器
加到一起，并将它们的和作为新一轮递归的操作数，直到向量长度减少到 1 。此时第零个
元素中的结果就是原向量寄存器中所有元素的和。</p>
<pre><code>图 8.3 ：图 5.7 中 DAXPY 程序的 RV32V 代码。没有出现机器语言是因为 RV32V 的操作码还未定义。
</code></pre>
<h3 id="88-例子用rv32v写成的daxpy程序"><a class="header" href="#88-例子用rv32v写成的daxpy程序">8.8 例子：用RV32V写成的DAXPY程序</a></h3>
<h4 id="图83显示了用rv32v汇编写成的daxpy程序见第五章第-55-页图57我们一"><a class="header" href="#图83显示了用rv32v汇编写成的daxpy程序见第五章第-55-页图57我们一">图8.3显示了用RV32V汇编写成的DAXPY程序（见第五章第 55 页图5.7），我们一</a></h4>
<h4 id="次解释一个步骤"><a class="header" href="#次解释一个步骤">次解释一个步骤。</a></h4>
<h4 id="rv32v-daxpy程序做的第一件事是启用这个函数需要的向量寄存器它只需要两个"><a class="header" href="#rv32v-daxpy程序做的第一件事是启用这个函数需要的向量寄存器它只需要两个">RV32V DAXPY程序做的第一件事是启用这个函数需要的向量寄存器。它只需要两个</a></h4>
<p>向量寄存器保存x和y的部分元素，这些元素一个个都是 8 字节宽的双精度浮点数。第一
条指令生成一个常量，第二条指令将它写入配置向量寄存器的控制状态寄存器（vcfgd），</p>
<pre><code>RISC-V中的V也代表
向量。 RISC-V架构师
在向量架构方面拥有
丰富的经验，并且对
SIMD在微处理器中的
主导地位感到沮丧。
因此，V不仅代表这是
第五个伯克利RISC项
目，也意味着这个ISA
会突出向量。
</code></pre>
<h4 id="从而获得两个f64类型的寄存器见图82根据定义硬件按数字顺序分配配置好的寄"><a class="header" href="#从而获得两个f64类型的寄存器见图82根据定义硬件按数字顺序分配配置好的寄">从而获得两个F64类型的寄存器（见图8.2）。根据定义，硬件按数字顺序分配配置好的寄</a></h4>
<pre><code>存器，这样便有了v0和v1。
假设我们的RV32V处理器由 1024 字节的空间专门用于向量寄存器。硬件平均地给这
两个双精度浮点型（ 8 字节）的向量寄存器分配空间。每个向量寄存器有 512 / 8 = 64 个元
素，因此处理器将此函数的最大向量长度（mvl）设置为 64 。
循环中的第一条指令为接下来的向量指令设置向量长度。setvl指令把mvl和n中的
小值写入vl和t0。其中的深刻原因是，如果循环的迭代次数大于n，那么这段代码最快可
以一次处理 64 个值，所以把mvl的值写入vl。如果n比mvl小，那么我们的读写不能超
出x和y的范围，所以我们应该在循环最后一次迭代中只计算最后剩下的n个元素。setvl
还写入t0，用于保存vl的值，在地址为 10 的循环控制变量中会用到。
地址c处的指令vld是一个向量load操作，按照标量寄存器a1中存储的变量x的地
址从x中取值。它把x的vl个元素从内存传输到v0。下面的移位指令slli将向量长度乘
以数据的宽度（ 8 字节），以便稍后用于递增指向x和y的指针。
地址 14 处的指令（vld）将来自内存的vl个元素load到v1中，接下来的一条指令
（add）将指向x的指针进行了递增。
地址1c处的指令是最重要的部分。vfmadd将x（v0）中的vl个元素乘以标量a
（f0）并将每个乘积加上y（v1）中的vl个元素，最后将这vl个和存回y（v1）。
剩下的就是将结果存到内存中以及一些必须的循环开销。在地址 20 处的指令（sub）
将n（a0）的减去vl，以记录在本次迭代中完成的操作数。接下来的一条指令（vst）将vl
个结果写入内存中y数组中。地址 28 处的指令（add）将指向y数组的指针递增。接下来
的指令判断n（a0）是否为 0 ，若不是则继续循环，反之执行最后一条ret指令返回调用
点。
向量架构的强大之处在于，这个包含 10 条指令的循环的每次迭代都会进行 3 × 64 =
192 次访存操作和 2 × 64 = 128 个浮点乘加（假设n至少为 64 ）。这意味着每条指令平均有
19 次访存和 13 次运算。我们将在下一节看到，SIMD的这些数据要差一个数量级。
</code></pre>
<h3 id="89-rv32vmips-32-msa-simd和x86-32-avx-simd的比较"><a class="header" href="#89-rv32vmips-32-msa-simd和x86-32-avx-simd的比较">8.9 RV32V，MIPS-32 MSA SIMD和x86-32 AVX SIMD的比较</a></h3>
<h4 id="我们即将看到simd和向量架构执行daxpy程序的对比如果你换一种角度来看"><a class="header" href="#我们即将看到simd和向量架构执行daxpy程序的对比如果你换一种角度来看">我们即将看到SIMD和向量架构执行DAXPY程序的对比。如果你换一种角度来看，</a></h4>
<h4 id="也可以把simd视为有着短向量寄存器-8-个-8-位元素的受限向量架构但它没有向"><a class="header" href="#也可以把simd视为有着短向量寄存器-8-个-8-位元素的受限向量架构但它没有向">也可以把SIMD视为有着短向量寄存器（ 8 个 8 位“元素”）的受限向量架构，但它没有向</a></h4>
<h4 id="量长度寄存器也没有跨步或索引数据传输"><a class="header" href="#量长度寄存器也没有跨步或索引数据传输">量长度寄存器，也没有跨步或索引数据传输。</a></h4>
<h4 id="mips-simd-第-83-页的图85显示了daxpy程序的mips-simd架构msa版本由"><a class="header" href="#mips-simd-第-83-页的图85显示了daxpy程序的mips-simd架构msa版本由">MIPS SIMD 第 83 页的图8.5显示了DAXPY程序的MIPS SIMD架构（MSA）版本。由</a></h4>
<h4 id="于msa寄存器为-128-位宽所以每个msa-simd指令可以操作两个双精度浮点数"><a class="header" href="#于msa寄存器为-128-位宽所以每个msa-simd指令可以操作两个双精度浮点数">于MSA寄存器为 128 位宽，所以每个MSA SIMD指令可以操作两个双精度浮点数。</a></h4>
<pre><code>与RV32V不同，由于没有向量长度寄存器，MSA需要额外的指令来检查n的值是否
有问题。当n为奇数时，计算单个浮点数的乘-加运算需要额外的代码，因为MSA必须对
成对的操作数进行操作。该代码位于图8.5的地址3c到4c处。尽管概率不大，但n也有
可能为 0 。在这种情况下，地址为 10 处的分支将跳过主计算循环。
如果没有在循环附近执行分支跳转，则地址为 18 处的指令（splati.d）把a的值同时
放入SIMD寄存器w2的两半中。在SIMD中，要加一个标量数据，我们需要将其复制拓
宽到与SIMD寄存器等宽。
在循环内部，地址为1c处的ld.d指令将y的两个元素load到SIMD寄存器w0中，
然后将指向y的指针进行递增。然后它将x的两个元素load到SIMD寄存器w1中。接下
</code></pre>
<pre><code>没有setvl的向量架构
具有额外的类似露天
采矿（意为降低效率）
的代码，用于将vl设
置为循环的最后n个
元素，并检查n是否为
零。
</code></pre>
<p><strong>ARM- 32</strong> 有一个名为
NEON的SIMD扩展，
但它不支持双精度浮
点 指 令 ，所 以 它 对
DAXPY没有帮助。</p>
<p>这种簿记代码被认为
是向量架构中露天采
矿代码的一部分。如图
8.5的标题所示，向量
长度寄存器vl使得这
样的SIMD簿记代码
对于RV32V没有实际
意义。传统的向量架构
需要额外的代码来处
理n = 0的极端情况。
RV32V只是在n = 0时
使向量指令像nops一
样。</p>
<p>来地址 28 处的指令执行将指向x的指针进行递增，紧接在后面的是地址为2c处的最重要
的乘加指令。
循环结束时的分支指令（带延迟槽）判断指向y的指针是否已经超出了y的范围。如
果没有，循环继续。地址 34 处的延迟槽中的SIMD store指令将结果写入y的两个元素。
主循环终止后，代码检查n是否是奇数。若n是奇数，用第五章的标量指令执行最后
一次乘加操作。最后一条指令返回到调用点。
MIPS MSA DAXPY代码核心的循环部分包含了 7 条指令，执行了 6 次双精度访存操
作和 4 次浮点乘加。平均每个指令大约有 1 个访存和0.5个运算操作。</p>
<pre><code>图 8.4 ：向量 ISA 的 DAXPY 指令数和代码大小。他列出了指令总数（静态），代码大小，每个循环的指
令数和运算结果数，以及执行的指令数（ n = 1000 ）。带 MSA 的 microMIPS 将代码大小缩减到 64 字节，
RV32FDCV 将代码缩减到 40 字节。
</code></pre>
<p><strong>x86 SIMD</strong> 在 84 页的图8.6的代码中我们可以看到，Intel公司经历了多代SIMD扩展。
SSE扩展到了 128 位SIMD，带来了xmm寄存器和可以使用这些寄存器的指令；AVX的
一部分带来了 256 位SIMD，以及ymm寄存器及其指令。
地址 0 到 25 的第一组指令从内存中load变量，在 256 位ymm寄存器中创建a的四个
副本，并在进入主循环之前进行测试，以确保n至少为 4 。这用到了两条SSE指令和一条
AVX指令。（图8.6的标题中有更详细的解释）
主循环是DAXPY计算的核心。地址 27 处的AVX指令vmovapd将x的 4 个元素
load到ymm0中。地址2c处的AVX指令vfmadd213pd将a（ymm2）乘以x（ymm0）
的 4 个元素的 4 个副本，加上y的四个元素（在内存中地址为ecx+edx*8处），并将 4 个和
放入ymm0。接下来地址 32 处的AVX指令vmovapd将 4 个结果存储到变量y中。随后
的三条指令执行计数器的递增操作并在需要的时候重复循环。
与MIPS MSA的情况一样，地址3e和 57 之间的“边缘”代码处理了n不是 4 的倍数
的情况。它用到了三个SSE指令。
x86- 32 AVX2 DAXPY代码中主循环的 6 条指令执行了 12 次双精度访存和 8 次浮点的
乘法和加法操作。这样每条指令平均有约 2 次访存和 1 次运算。</p>
<pre><code>补充说明：Illiac IV最先显现了SIMD的编译复杂性
凭借 64 个并行的 64 位浮点单元（FPU），在摩尔定律发布之前，Illiac IV计划拥有超过 100
万个逻辑门。它的架构师最初预测它每秒可以进行 10 亿次浮点运算（1000MFLOPS），但它
的实际最好性能只有15MFLOPS。它的成本从 1966 年估计的 800 万美元上升到了 1972 年
的 3100 万美元（尽管只建造了计划的 256 个FPU中的 64 个）。该项目于 1965 年启动，但
直到 1976 年（Cray- 1 发布的那一年）才开始发挥实际作用。它可能是最臭名昭著的超级计
算机，成为了十大工程灾难之一[Falk 1976]。
</code></pre>
<h3 id="810-结束语"><a class="header" href="#810-结束语">8.10 结束语</a></h3>
<p>如果代码能向量化，最好的架构就是向量架构。
——Jim Smith于 1994 年在国际计算机体系结构研讨会上的主旨演讲</p>
<p>图8.4总结了RV32IFDV，MIPS- 32 MSA和x86- 32 AVX2的DAXPY程序中的指令数
和字节数。SIMD架构程序中用于计算的代码比用于循环控制的代码要少不少。MIPS- 32
MSA和x86- 32 AVX2代码中的三分之二到四分之三是SIMD开销：这些额外的代码要么是
在为主SIMD循环准备数据，要么是在n不是SIMD寄存器中浮点数个数的倍数时处理那
些边缘元素。
图8.3中的RV32V代码不需要这样的循环控制代码，因此它的指令数量少了一半。与
SIMD不同，RV32V有一个向量长度寄存器，使得不论n为何值，向量指令都可以工作。
你可能会觉得n为 0 时RV32V会出现问题。实际上它不会，因为RV32V中的向量指令在
vl=0时不会做出任何改变。
但是，SIMD和向量处理之间的最为显著的区别不在于代码的长短。SIMD执行的指令
数比RV32V多 10 到 20 倍，因为每个SIMD循环在向量模式下只操作 2 到 4 个元素，而不
是RV32V的 64 个元素。额外的取指和译码意味着在执行相同任务时要耗费更多的能量。
将图8.4中的结果与第五章中第 29 页的图5.8中的DAXPY的标量版本进行比较，我
们发现SIMD大概使得代码的指令数和字节数加倍，但主循环的大小相同。执行的动态指
令的数量以 2 或 4 的因子减少，这取决于SIMD寄存器的宽度。然而，RV32V的向量代码
大小变为原来的1.2倍（主循环1.4倍），但动态指令数是原来的1/43！
即使动态指令的数量差别很大，但在我们看来，这并不是SIMD和向量架构的最主要
的差异。没有向量长度寄存器会让指令数和循环控制代码暴增。像MIPS- 32 和x86- 32 这些
遵循增量主义的ISA必须每次在将SIMD寄存器宽度翻倍时，都复制所有那些为较窄的
SIMD寄存器定义的指令。于是不出意外地，在许多代SIMD ISA的传承中一共创造了数
百条MIPS- 32 和x86- 32 指令，而且将来还会有数以百计的新指令出现。汇编语言程序员一
定因这种粗暴的ISA演变方式而承担了难以承受的认知负担。像vfmadd213pd这样的指
令，谁能记住它的含义并知道什么时候要用它？
相比之下，RV32V代码不受向量寄存器的可用存储空间的大小影响。如果向量内存变
大，不仅RV32V不会改变，而且你甚至不用重新编译。处理器提供了最大向量长度mvl
的值，因此无论处理器将用于向量的存储空间从 1024 字节提升到了 4096 字节，还是将其
降低到 256 字节，图8.3中的代码都不受影响。
不同于SIMD中由ISA指示所需的硬件，而且更改ISA意味着更改编译器那样，
RV32V ISA允许处理器设计人员为其应用分配合适资源用于数据并行，而不必影响程序员
或编译器。可以说SIMD违反了第一章中将ISA架构和实现分离开来的ISA设计原则。
我们认为RV32V的模块化向量实现对比ARM- 32 、MIPS- 32 和x86- 32 的增量式SIMD
架构在成本-能耗-性能、复杂度和编程简易性等方面的极大优势，可能是选用RISC-V的最
有说服力的论据。</p>
<h3 id="811-扩展阅读"><a class="header" href="#811-扩展阅读">8.11 扩展阅读</a></h3>
<p>H. Falk. What went wrong V: Reaching for a gigaflop: The fate of the famed Illiac IV was shaped
by both research brilliance and real-world disasters. IEEE spectrum, 13(10):65–70, 1976.</p>
<p>J. L. Hennessy and D. A. Patterson. Computer architecture: a quantitative approach. Elsevier,</p>
<ol start="2011">
<li></li>
</ol>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I: User-
Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.</p>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<p>图 <strong>8.5</strong> ：图 <strong>5.7</strong> 中 <strong>DAXPY</strong> 的 <strong>MIPS- 32 MSA</strong> 代码。将此代码与图 <strong>8.3</strong> 中的 <strong>RV32V</strong> 代码进行比较时， <strong>SIMD</strong>
的循环控制开销显而易见。 <strong>MIPS MSA</strong> 代码的第一部分（地址 <strong>0</strong> 到 <strong>18</strong> ）复制了 <strong>SIMD</strong> 寄存器中的标量变
量 <strong>a</strong> ，并在进入主循环之前执行确保 <strong>n</strong> 至少为 <strong>2</strong> 的检查。当 <strong>n</strong> 不是 <strong>2</strong> 的倍数时， <strong>MIPS MSA</strong> 代码的第三
部分（地址 <strong>38</strong> 到 <strong>4c</strong> ）处理了这种边界情况情况。在 <strong>RV32V</strong> 中不需要这样的代码，因为向量长度寄存器
vl和setvl指令使得该循环的代码适用于 <strong>n</strong> 的所有值，不论是奇数还是偶数。</p>
<p>图 <strong>8.6</strong> ：图 <strong>5.7</strong> 中 <strong>DAXPY</strong> 的 <strong>x86- 32 AVX2</strong> 代码。地址 <strong>a</strong> 处的 <strong>SSE</strong> 指令vmovsd把 <strong>a load</strong> 到 <strong>128</strong> 位xmm1
寄存器的一半。地址 <strong>14</strong> 处的 <strong>SSE</strong> 指令vmovddup将 <strong>a</strong> 复制到xmm1的全部两半，以用于接下来的
<strong>SIMD</strong> 计算。地址 <strong>1d</strong> 处的 <strong>AVX</strong> 指令vinsertf128从xmm1中的 <strong>a</strong> 的两个副本，在ymm2中生成 <strong>a</strong> 的四
个副本。地址 <strong>42</strong> 到 <strong>4d</strong> 的三个 <strong>AVX</strong> 指令（vmovsd，vfmadd213sd，vmovsd）处理퐦퐨퐝（퐧，ퟒ）≠ퟎ
的情况。它们以一次一个元素的方式执行 <strong>DAXPY</strong> 操作，循环在这个函数正好进行了 <strong>n</strong> 次乘 <strong>-</strong> 加操作的时
候停止。再提一次， <strong>RV32V</strong> 不需要这样的代码，因为向量长度寄存器vl和setvl指令使得那些循环代码
适用于 <strong>n</strong> 为任意值的情况。</p>
<h2 id="第九章-rv64-64-位地址指令"><a class="header" href="#第九章-rv64-64-位地址指令">第九章 RV64： 64 位地址指令</a></h2>
<pre><code>在计算机设计中只能出现一个错误是难以恢复的——没有足够的地址位用于存储器寻址和存储器管理。
——C. Gordon Bell, 1976
</code></pre>
<h3 id="91-导言"><a class="header" href="#91-导言">9.1 导言</a></h3>
<h4 id="图91至94是rv32g指令集的-64-位版本rv64g指令集的图示由图可见要切换"><a class="header" href="#图91至94是rv32g指令集的-64-位版本rv64g指令集的图示由图可见要切换">图9.1至9.4是RV32G指令集的 64 位版本RV64G指令集的图示。由图可见，要切换</a></h4>
<pre><code>到 64 位ISA，ISA只添加了少数指令。指令集只添加了 32 位指令对应的字(word)，双字
(doubleword)和长整数(long)版本的指令，并将所有寄存器（包括PC）扩展为 64 位。因此，
RV64I中的sub操作的是两个 64 位数字而不是RV32I中的 32 位数字。RV64很接近RV 32
但实际上又有所不同;它添加了少量指令同时基础指令做的事情与RV 32 中稍有不同。
例如，图9.8中RV64I版本的插入排序与第 2 章第 27 页的图2.8中RV 32 I版本的插入
排序非常相似。它们指令数量和大小都相同。唯一的变化是加载和存储字指令变为加载并存
储双字，地址增量从对应字的 4 （ 4 字节）变为对应双字的 8 （ 8 字节）。图9.5列出了图9.1
到9.4中的RV64GC指令的操作码。
尽管RV64I有 64 位地址且默认数据大小为 64 位， 32 位字仍然是程序中的有效数据类
型。因此，RV64I需要支持字，就像RV32I需要支持字节和半字一样。更具体地说，由于寄
存器现在是 64 位宽，RV64I添加字版本的加法和减法指令：addw，addiw，subw。这些指
令将计算结果截断为 32 位，结果符号扩展后再写入目标寄存器。 RV64I也包括字版本的移
位指令（sllw，slliw，srlw，srliw，sraw，sraiw），以获得 32 位移位结果而不是 64 位移
位结果。要进行 64 位数据传输，RV 64 提供了加载和存储双字指令：ld，sd。最后，就像
RV32I中有无符号版本的加载单字节和加载半字的指令，RV64I也有一个无符号版本的加载
字：lwu。
出于类似的原因，RV64需要添加字版本的乘法，除法和取余指令：mulw，divw，divuw，
remw，remuw。为了支持对单字及双字的同步操作，RV64A为其所有的 11 条指令都添加
了双字版本。
</code></pre>
<p>C. Gordon Bell
( 1934 - ) 是当时最受
欢迎的两种小型机架
构的首席架构师之一：
1970 年宣布的数字设
备公司PDP- 11 （ 16 位
地址）及其七年后的继
任者，数字设备公司 32
位地址VAX- 11 （虚拟地
址扩展）。</p>
<p>图 <strong>9.1</strong> ： <strong>RV64I</strong> 指令图示。带下划线的字母从左到右连起来构成 <strong>RV64I</strong> 指令。灰色部分是扩展到 <strong>64</strong> 位寄
存器的旧 <strong>RV64I</strong> 指令，而暗（红色）部分是 <strong>RV64I</strong> 的新指令。</p>
<h4 id="图-9-2--rv64m-和-rv-64-a-指令图示"><a class="header" href="#图-9-2--rv64m-和-rv-64-a-指令图示">图 9 .2 ： RV64M 和 RV 64 A 指令图示</a></h4>
<p>图 <strong>9 .3</strong> ： <strong>RV 64 F</strong> 和 <strong>RV 64 D</strong> 指令图</p>
<pre><code>图 9 .4L ： RV 64 C 指令图
</code></pre>
<p>31 27 26 25 24 20 19 15 14 12 11 7 6 0
imm[11:0] rs1 110 rd 0000011 I lwu
imm[11:0] rs1 011 rd 0000011 I ld
imm[11:5] rs2 rs1 011 imm[4:0] 0100011 S sd
0000000 shamt rs1 001 rd 0010011 I slli
0000000 shamt rs1 101 rd 0010011 I srli
0100000 shamt rs1 101 rd 0010011 I srai
imm[11:0] rs1 000 rd 0011011 I addiw
0000000 shamt rs1 001 rd 0011011 I slliw
0000000 shamt rs1 101 rd 0011011 I srliw
0100000 shamt rs1 101 rd 0011011 I sraiw
0000000 rs2 rs1 000 rd 0111011 R addw
0100000 rs2 rs1 000 rd 0111011 R subw
0000000 rs2 rs1 001 rd 0111011 R sllw
0000000 rs2 rs1 101 rd 0111011 R srlw
0100000 rs2 rs1 101 rd 0111011 R sraw</p>
<pre><code>RV64M Satndard Extension (in addition to RV32M)
0000001 rs2 rs1 000 rd 0111011 R mulw
0000001 rs2 rs1 100 rd 0111011 R divw
0000001 rs2 rs1 101 rd 0111011 R divuw
0000001 rs2 rs1 110 rd 0111011 R remw
0000001 rs2 rs1 111 rd 0111011 R remuw
RV64A Satndard Extension (in addition to RV32A)
00010 aq rl 00000 rs1 011 rd 0101111 R lr.d
00011 aq rl rs2 rs1 011 rd 0101111 R sc.d
00001 aq rl rs2 rs1 011 rd 0101111 R amoswap..d
00000 aq rl rs2 rs1 011 rd 0101111 R amoadd.d
00100 aq rl rs2 rs1 011 rd 0101111 R amoxor.d
01100 aq rl rs2 rs1 011 rd 0101111 R amoand.d
01000 aq rl rs2 rs1 011 rd 0101111 R amoor.d
10000 aq rl rs2 rs1 011 rd 0101111 R amomin.d
10100 aq rl rs2 rs1 011 rd 0101111 R amomax.d
11000 aq rl rs2 rs1 011 rd 0101111 R amominu.d
11100 aq rl rs2 rs1 011 rd 0101111 R amomaxu.d
RV64F Satndard Extension (in addition to RV32F)
1100000 00010 rs1 rm rd 1010011 R fcvt.l.s
1100000 00011 rs1 rm rd 1010011 R fcvt.lu.s
1101000 00010 rs1 rm rd 1010011 R fcvt.s.l
1101000 00011 rs1 rm rd 1010011 R fcvt.s.lu
RV64D Satndard Extension (in addition to RV32D)
1100001 00010 rs1 rm rd 1010011 R fcvt.l.d
1100001 00011 rs1 rm rd 1010011 R fcvt.lu.d
1110001 00000 rs1 000 rd 1010011 R fmv.x.d
1101001 00010 rs1 rm rd 1010011 R fcvt.d.l
1101001 00011 rs1 rm rd 1010011 R fcvt.d.lu
1111001 00000 rs1 000 rd 1010011 R fmv.d.x
图 9.5 ： RV 64 基本指令和可选扩展指令的的操作码表。这张图包含了指令布局，操作码，格式类型和名
称 ( 基于 [Waterman and Asanovic 2017] 的表 19.2 ）。
</code></pre>
<h4 id="rv64f和rv64d添加了整数双字转换指令并称它们为长整数以避免与双精度浮点"><a class="header" href="#rv64f和rv64d添加了整数双字转换指令并称它们为长整数以避免与双精度浮点">RV64F和RV64D添加了整数双字转换指令，并称它们为长整数，以避免与双精度浮点</a></h4>
<p>数据混淆：fcvt.l.s，fcvt.l.d，fcvt.lu.s，fcvt.lu.d，fcvt.s.l，fcvt.s.lu，fcvt.d.l，fcvt.d.lu.
由于整数x寄存器现在是 64 位宽，它们现在可以保存双精度浮点数据，因此RV64D增加了
两个浮点指令：fmv.x.w和fmv.w.x.
RV64和RV32之间基本是超集关系，但是有一个例外是压缩指令。 RV64C取代了一些
RV32C指令，因为其他一些指令对于 64 位地址可以取得更好的代码压缩效果。RV64C放弃
了压缩跳转并链接（c.jal）和整数和浮点加载和存储字指令（c.lw，c.sw，c.lwsp，c.swsp，
c.flw，c.fsw，c.flwsp和c.fswsp）。在他们的位置，RV64C添加了更受欢迎的字加减指令
（c.addw，c.addiw，c.subw）以及加载和存储双字指令（c.ld，c.sd，c.ldsp，c.sdsp）。</p>
<h3 id="92使用插入排序来比较rv64与其他-64-位isa"><a class="header" href="#92使用插入排序来比较rv64与其他-64-位isa">9.2使用插入排序来比较RV64与其他 64 位ISA</a></h3>
<p>正如Gordon Bell在本章开头所说，一个架构致命的缺陷是用光了地址位。随着程序使
用的内存大小逐渐逼近 32 位地址空间的极限，不同指令集的架构师开始了设计他们指令集
的 64 位地址版本[Mashey 2009]。
最早的是MIPS，在 1991 年，它将所有寄存器以及程序计数器从 32 扩展至 64 位并添
加了新的 64 位版本的MIPS- 32 指令。 MIPS- 64 汇编语言指令都以字母“d”开头，例如daddu
或dsll（参见图9.10）。程序员可以在同一个程序中混合使用MIPS- 32 和MIPS- 64 指令。
MIPS- 64 删除了MIPS- 32 中的加载延迟槽（流水线在侦测到写后读相关时会停止）。
十年之后，是x86- 32 指令集也迎来了 64 位。架构师们在拓展地址空间的同时，也借机
在x86- 64 中进行了一系列改进：
⚫ 整数寄存器的数量从 8 增加到 16 （r8-r15）;
⚫ 将SIMD寄存器的数量从 8 增加到 16 （xmm8-xmm15）并且添加了PC相关数据寻址，
以更好地支持与位置无关的代码。
⚫ 添加了PC相关数据寻址，以更好地支持与位置无关的代码。
这些改进部分缓和了x86- 32 指令集长久以来的一些弊端。</p>
<p>通过比较插入排序的x86- 32 版本（第 2 章第 30 页上图2.11中）和x 86 - 64 版本（图9.11
中）的指令，我们可以发现x 86 - 64 指令集的优势。新的 64 位ISA将所有变量分配在寄存器
中，而不是像x 86 - 32 一样，要将多个变量保存到内存中，这将指令的数量从 20 条减少到了
15 条。尽管 64 位代码指令数量比 32 位少，但是代码大小实际上要大一个字节，从 45 变成</p>
<pre><code>补充说明：RV64 ABI包括lp64，lp64f和lp64d
lp64表示C语言中的长整型以及指针类型为 64 位; 整型仍然是 32 位。与RV32（见第 3 章）
相同，后缀f和d表示如何传递浮点参数。
</code></pre>
<pre><code>补充说明：RV64V没有指令图示
是因为有动态寄存器类型的存在，它与RV32V的完全一致。唯一的变化是第 75 页的图8.2
中的X64和X64U动态寄存器类型仅在RV64V中出现，RV32V并不支持。
</code></pre>
<p>了 46 字节。原因是为了挤进新的操作码以便操作更多的寄存器，x86- 64 添加了一个前缀字</p>
<p>图 <strong>9.6</strong> ：四个 <strong>ISA</strong> 的插入排序的指令数和代码大小。 <strong>ARM Thumb- 2</strong> 和 <strong>microMIPS</strong> 是 <strong>32</strong> 位地址 <strong>ISA</strong> ，因
此不适用于 <strong>ARM- 64</strong> 和 <strong>MIPS- 64</strong> 。</p>
<p>节来识别新指令。从x86- 32 到x86- 64 平均指令长度增长了。
又过了十年，ARM也遇到了同样的地址问题。但是他们没有像x 86 - 64 那样，把旧的ISA
扩展到支持 64 位地址。他们利用这个机会发明了一个全新的ISA。从头设计一个新ISA，
使得他们不必继承ARM- 32 的许多尴尬特性，他们重新设计了一个现代ISA：
⚫ 将整数寄存器的数量从 15 增加到31;
⚫ 从寄存器组中删除PC;
⚫ 为大多数指令提供硬连线到零的寄存器（r31）;
⚫ 与ARM- 32 不同，ARM- 64 的所有数据寻址模式都适用于所有数据大小和类型;
⚫ ARM- 64 去除了ARM- 32 的加载存储多个数据的指令
⚫ ARM- 64 去除了ARM- 32 指令的条件执行选项。</p>
<p>ARM- 32 的一些弱点依然存在于ARM- 64 指令集中：分支指令使用的条件码，指令中源和目
标寄存器字段并不固定，条件移动指令，复杂寻址模式，不一致的性能计数器，以及只支持
32 位长度的指令。另外ARM- 64 无法切换到Thumb-2 ISA，因为Thumb- 2 仅适用于 32 位地
址。
与RISC-V不同，ARM决定采用最大主义的方法来设计ISA。虽然ISA比ARM- 32 更
好，但它也更大。例如，它有超过 1000 条指令并且ARM- 64 手册长 3185 页[ARM 2015]。
而且，它的指令数仍然在增长。自公布几年以来，ARM- 64 已经经历了三次扩展。
图9.9中插入排序的ARM- 64 代码看起来更接近RV64I代码或x86- 64 代码，而不太像
ARM- 32 代码。例如，因为有 31 个寄存器可用，就没有必要从堆栈中保存和恢复寄存器。
而且由于PC不再存放于通用寄存器中，ARM- 64 单独增加了一条返回指令。
图9.6总结了插入排序在不同ISA下的指令数和字节数。图9.8到9.11显示了RV64I，
ARM- 64 ，MIPS- 64 和x86- 64 的代码。这四段代码注释中括号内的短语阐明了第 2 章中的
RV32I版本与这些RV64I版本之间的差异。
MIPS- 64 用到了最多的指令，主要是因为它需要使用nop指令来填充无法有效利用起
来的分支延迟槽。由于比较和分支用一条指令完成，而且分支指令没有延迟槽，RV64I需要
的指令更少。虽然相较于RV 64 I，对于每个分支，ARM- 64 和x86- 64 需要多使用两条指令，
但它们的缩放寻址模式避免了RV64I中所需的地址算术指令，可以让它们少使用一些指令。
但是总的而言，RV64I + RV64C代码大小要小得多，具体原因会在下一节阐述。</p>
<pre><code>补充说明：ARM- 64 ，MIPS- 64 和x86- 64 不是官方名称
他们的官方名称是：我们所说的ARM- 64 实则是ARMv8，MIPS- 64 是MIPS-IV和x86- 64
是AMD64（有关x86- 64 的历史记录，请参见上一页的侧栏）。
</code></pre>
<pre><code>英特尔没有发明x86- 64
ISA。 当向 64 位地址转
换时，英特尔发明了一
种名为Itanium 的新
ISA，它与x86- 32 不兼
容。x86- 32 处理器的竞
争对手被拦在了
Itanium的门外，因此
AMD发明了一款名为
AMD64的 64 位版x86-
32 。Itanium最终失败
了，因此英特尔被迫采
用AMD64 ISA 作为
x86- 32 的 64 位地址继
承者，我们称之为x86-
64 [Kerner &amp; Padgett
2007]。
</code></pre>
<p>图 <strong>9.7</strong> ： <strong>RV64G</strong> ， <strong>ARM- 64</strong> 和 <strong>x86- 64</strong> 与 <strong>RV64GC</strong> 的相对程序大小比较。我们使用了比图 <strong>9.6</strong> 中更大的程
序来进行对比。该图第 <strong>2</strong> 章中第 <strong>9</strong> 页的图 <strong>1.5</strong> 中的 <strong>32</strong> 位 <strong>ISA</strong> 比较的对应的 <strong>64</strong> 位 <strong>ISA</strong> 比较 <strong>.RV32C</strong> 代码
大小与 <strong>RV64C</strong> 几乎一致 <strong>;</strong> 仅比 <strong>RV 64 C</strong> 小 <strong>1</strong> ％。 <strong>ARM- 64</strong> 没有 <strong>Thumb- 2</strong> 选项，因此其他 <strong>64</strong> 位 <strong>ISA</strong> 的代码
大小明显大于 <strong>RV64GC</strong> 代码。测量的程序是 <strong>SPEC CPU2006</strong> 基准测试，使用的 <strong>GCC</strong> 编译器 <strong>[Waterman
2016]</strong> 。</p>
<h3 id="93程序大小"><a class="header" href="#93程序大小">9.3程序大小</a></h3>
<p>图9.7比较了RV64，ARM- 64 和x86- 64 的平均相对代码大小。将这个图见第 1 章第 9
页的图1.5比较。首先，RV32GC代码的大小与RV64GC几乎相同;它只比RV 64 GC小 1 ％。
RV32I和RV64I的代码大小也很接近。而ARM- 64 代码比ARM- 32 代码小 8 ％，由于没有
64 位地址版本的Thumb- 2 ，所以所有指令都保持 32 位长。因此，ARM- 64 代码比ARMThumb-
2 代码大 25 ％。由于添加了前缀操作码以装下新的指令以及扩展的寄存器，x86- 64 的代码比
x86- 32 代码大 7 ％。因此，就程序大小而言，RV64GC更优秀，因为ARM- 64 代码比RV64GC
大 23 ％，x86- 64 代码比RV 64 GC大 34 ％。程序大小的差异如此得大，以至于RV64可以较
低的指令高速缓存缺失率来提供更高的性能，或者可以使用更小的指令缓存来降低成本，但
依然能提供令人满意的缺失率。</p>
<h3 id="94结束语"><a class="header" href="#94结束语">9.4结束语</a></h3>
<p>成为先驱者的一个问题是你总是犯错误，而我永远不会想成为先驱者。最好是在看到先驱者所犯的错误后，
赶紧来做这件事情，成为第二个做这件事情的人。
——Seymour Cray，第一台超级计算机的架构师， 1976 年</p>
<pre><code>耗尽地址位是计算机体系结构的致命弱点，许多架构因为这个缺点而消亡。 ARM- 32 和
</code></pre>
<p>Thumb- 2 仍然是 32 位架构，所以他们对大型程序没有帮助。像MIPS- 64 和x86- 64 这样的一
些ISA在转型中幸存下来，但x86- 64 并不是ISA设计的典范，而写这篇文章的时候，MIPS-
64 的前路依然迷茫。ARM- 64 是一个新的大型ISA，时间会告诉我们它会有多成功。</p>
<p>RISC-V受益于同时设计 32 位和 64 位架构，而较老的ISA必须依次设计它们。不出所
料，对于RISC-V程序员和编译器编写者来说， 32 位到 64 位之间的过渡是最简单的; RV64I
ISA几乎包含了所有RV32I指令。这也就是为什么我们只用两页参考卡片，就可以列出
RV32GCV和RV64GCV指令集。更重要的是，同步设计意味着 64 位架构指令集不必被狭
窄的 32 位操作码空间限制。 RV64I有足够的空间用于可选的指令扩展，特别是RV64C，这
使它成为代码大小比其他所有 64 位ISA都要小。
我们认为 64 位架构更能体现RISC-V设计上的优越性，毕竟我们设计 64 位ISA比先行
者们晚了 20 年，这样我们可以可以学习先行者们的好的设计并从他们的错误中吸取教训。</p>
<h3 id="95-扩展阅读"><a class="header" href="#95-扩展阅读">9.5 扩展阅读</a></h3>
<pre><code>I. ARM. Armv8-a architecture reference manual. 2015.
</code></pre>
<pre><code>M. Kerner and N. Padgett. A history of modern 64-bit computing. Technical report, CS
Department,University of Washington, Feb 2007. URL http://courses.cs.washington.edu/cou
rses/csep590/06au/projects/history- 64 - bit.pdf.
</code></pre>
<pre><code>J. Mashey. The long road to 64 bits. Communications of the ACM, 52(1):45– 5 3, 2009.
</code></pre>
<pre><code>A.Waterman. Design of the RISC-V Instruction Set Architecture. PhD thesis, EECS Department,
University of California, Berkeley, Jan 2016. URL http://www2.eecs.berkeley.edu/Pubs
/TechRpts/2016/EECS- 2016 - 1.html.
</code></pre>
<pre><code>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual, Volume I:
User-Level ISA, Version 2.2. May 2017. URL https://riscv.org/specifications/.
</code></pre>
<pre><code>J. Woodruff, R. N. Watson, D. Chisnall, S. W. Moore, J. Anderson, B. Davis, B. Laurie, P. G.
Neumann, R. Norton, and M. Roe. The CHERI capability model: Revisiting RISC in an age of risk.
In Computer Architecture (ISCA), 2014 ACM/IEEE 41st International Symposium on, pages 457–
</code></pre>
<ol start="468">
<li>IEEE, 2014.</li>
</ol>
<pre><code>补充说明：RV128
RV128最初是作为RISC-V架构师内部的一个玩笑话，只是为了显示 128 位地址的ISA是
可能的。但是，仓库规模的计算机可能很快就会拥有超过 264 字节存储容量的半导体存储器
（DRAM和闪存），同时程序员可能会想要用访问内存的方式来访问这些存储。同时还有人
[伍德拉夫等人2014]提议使用 128 位地址来提高安全性。 RISC-V手册确实指定了一个完
整的 128 位ISA叫做RV128G [Waterman and Asanovic 2017]。如图9.1至9.4所示，新增的
指令基本上是与从RV32切换到RV64新增的指令类似。所有的寄存器也增长到 128 位，新
的RV128指令要么指定了 128 位版本的指令（指令名称中使用Q，意为四字（quadword））
或其他指令的 64 位版本（指令名称中使用D，意为双字（double word）的）。
</code></pre>
<pre><code>MIPS 正 在 出 售 。
Imagination Technologies
于 2012 年以 1 亿美元收
购了MIPS ISA，最近宣
布将其出售; 还没有买
家。
</code></pre>
<p>图 <strong>9.8</strong> ：图 <strong>2.5</strong> 中插入排序的 <strong>RV64I</strong> 代码。 <strong>RV64I</strong> 汇编语言程序与第 <strong>2</strong> 章中第 <strong>27</strong> 页的图 <strong>2.8</strong> 中的 <strong>RV32I</strong>
汇编语言程序类似。我们在注释中的括号内列出了差异。数据的大小现在是 <strong>8</strong> 个字节而不是 <strong>4</strong> 个，所以三
条指令中的常数从 <strong>4</strong> 变到了 <strong>8.</strong> 由于数据宽度的变化，两个加载字（ <strong>lw</strong> ）相应变成了加载双字（ <strong>ld</strong> ）和两个
存储字（ <strong>sw</strong> ）相应变成了存储双字（ <strong>sd</strong> ）。</p>
<p>图 <strong>9.9</strong> ：图 <strong>2.5</strong> 所示的插入排序的 <strong>ARM- 64</strong> 代码。 <strong>ARM- 64</strong> 汇编语言程序是第 <strong>2</strong> 章中第 <strong>30</strong> 页图 <strong>2.11</strong> 中的
<strong>ARM- 32</strong> 汇编语言不同，它是一套全新的指令系统。寄存器以 <strong>x</strong> 开始而不是以 <strong>a</strong> 开头。数据寻址模式支持
将寄存器移位 <strong>3</strong> 位用于将索引缩放为字节地址。使用 <strong>31</strong> 个寄存器，所以无需保存和恢复寄存器堆栈。由
于 <strong>PC</strong> 不是寄存器之一，因此它使用了单独的返回指令。事实上，代码看起来更接近 <strong>RV64I</strong> 代码或 <strong>x86-
64</strong> 代码而不是 <strong>ARM- 32</strong> 代码。</p>
<p>图 <strong>9.10</strong> ：图 <strong>2 .5</strong> 中所示的插入排序的 <strong>MIPS- 64</strong> 代码。 <strong>MIPS- 64</strong> 汇编语言程序与第 <strong>2</strong> 章第 <strong>29</strong> 页图 <strong>2.10</strong> 中的
<strong>MIPS- 32</strong> 汇编语言有一些不同之处。首先，对于 <strong>64</strong> 位数据的大多数操作都在其名称前加上 <strong>“d”</strong> ：
<strong>daddiu</strong> ， <strong>daddu</strong> ， <strong>dsll</strong> 。如图 <strong>9.8</strong> ，由于数据大小从 <strong>4</strong> 字节增加到 <strong>8</strong> 字节，因此有三条指令将常量从 <strong>4</strong> 更改
为 <strong>8</strong> 。再次与 <strong>RV64I</strong> 类似，增加的数据宽度，使得两个加载字（ <strong>lw</strong> ）变成了加载双字（ <strong>ld</strong> ），两个存储字
（ <strong>sw</strong> ）变成了存储双字（ <strong>sd</strong> ）。最后， <strong>MIPS- 64</strong> 没有了 <strong>MIPS- 32</strong> 中的加载延迟槽 <strong>;</strong> 当出现写后读依赖时，
流水线会阻塞。</p>
<p>图 <strong>9.11</strong> ：图 <strong>2.5</strong> 中插入排序的 <strong>x86- 64</strong> 代码。 <strong>x86- 64</strong> 汇编语言程序与第 <strong>2</strong> 章中第 <strong>30</strong> 页图 <strong>2.11</strong> 中的 <strong>x86- 32</strong>
汇编语言非常不同。首先，与 <strong>RV64I</strong> 不同，较宽的寄存器有不同的名称 <strong>rax</strong> ， <strong>rcx</strong> ， <strong>rdx</strong> ， <strong>rsi</strong> ， <strong>rdi</strong> ， <strong>r8</strong> 。
第二，因为 <strong>x86- 64</strong> 增加了 <strong>8</strong> 个寄存器，现在可以将所有变量保存在寄存器而不是内存中。第三， <strong>x86- 64</strong>
指令比 <strong>x86- 32</strong> 更长，因为许多指令需要预先添加 <strong>8</strong> 位或 <strong>16</strong> 位前缀码，才能使得操作码空间中放得下这些
新指令。例如，递增或递减寄存器（ <strong>inc</strong> ， <strong>dec</strong> ）在 <strong>x 86 - 32</strong> 中只需要 <strong>1</strong> 字节，但 <strong>x86- 64</strong> 中需要 <strong>3</strong> 个字节。
因此，对于 <strong>Insertion Sort</strong> ，虽然 <strong>x86- 64</strong> 指令数比 <strong>x 86 - 32</strong> 少，但代码大小为几乎与 <strong>x86- 32</strong> 相同： <strong>45</strong> 个字
节对 <strong>46</strong> 个字节。</p>
<h2 id="第十章-rv3264特权架构"><a class="header" href="#第十章-rv3264特权架构">第十章 RV32/64特权架构</a></h2>
<pre><code>简洁性是可靠性的前提。——Edsger W. Dijkstra
</code></pre>
<h3 id="101-导言"><a class="header" href="#101-导言">10.1 导言</a></h3>
<pre><code>到目前为止，本书主要关注RISC-V对通用计算的支持：我们引入的所有指令都在用
户模式（应用程序的代码在此模式下运行）下可用。本章介绍两种新的权限模式：运行最
可信的代码的机器模式（machine mode），以及为Linux，FreeBSD和Windows等操作系统
提供支持的监管者模式（supervisor mode）。这两种新模式都比用和模式有着更高的权限，
这也是本章标题的来源。有更多权限的模式通常可以使用权限较低的模式的所用功能，并
且它们还有一些低权限模式下不可用的额外功能，例如处理中断和执行I/O的功能。处理
器通常大部分时间都运行在权限最低的模式下，处理中断和异常时会将控制权移交到更高
权限的模式。
嵌入式系统运行时（runtime）和操作系统用这些新模式的功能来响应外部事件，如网
络数据包的到达；支持多任务处理和任务间保护；抽象和虚拟化硬件功能等。鉴于这些主
题的广度，为此而编撰的全面的程序员指南会是另外一本完整的书。但我们的这一章节旨
在强调RISC-V这部分功能的亮点。对嵌入式系统运行时和操作系统不感兴趣的程序员可
以跳过或略读本章。
图10.1是RISC-V特权指令的图形表示，图10.2列出了这些指令的操作码。显然，特
权架构添加的指令非常少。作为替代，几个新的控制状态寄存器（CSR）显示了附加的功
能。
本章将RV32和RV64特权架构一并介绍。一些概念仅在整数寄存器的大小上有所不
同，因此为了描述简洁，我们引入术语XLEN来指代整数寄存器的宽度（以位为单位）。
对于RV32，XLEN为 32 ；对RV64，XLEN则是 64 。
</code></pre>
<pre><code>图 10.1 ： RISC-V 特权指令的指令图示。
</code></pre>
<pre><code>图 10.2 ： RISC-V 特权指令的指令布局、操作码、指令类型和名称。（来自 [Waterman and Asanovic 2017]
中的表 6.1 。）
</code></pre>
<p>Edsger W. Dijkstra
( 1930 - 2002 ）因开发编
程语言的基础性贡献
而获得 1972 年图灵奖。</p>
<h3 id="102-简单嵌入式系统的机器模式"><a class="header" href="#102-简单嵌入式系统的机器模式">10.2 简单嵌入式系统的机器模式</a></h3>
<p>机器模式（缩写为M模式，M-mode）是RISC-V中 <em>hart</em> （hardware thread，硬件线
程）可以执行的最高权限模式。在M模式下运行的hart对内存，I/O和一些对于启动和配
置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准RISC-V处理器都
必须实现的权限模式。实际上简单的RISC-V微控制器仅支持M模式。这类系统是本节的
重点。
机器模式最重要的特性是拦截和处理异常（不寻常的运行时事件）的能力。RISC-V将
异常分为两类。一类是同步异常，这类异常在指令执行期间产生，如访问了无效的存储器
地址或执行了具有无效操作码的指令时。另一类是中断，它是与指令流异步的外部事件，
比如鼠标的单击。RISC-V中实现精确例外：保证异常之前的所有指令都完整地执行了，而
后续的指令都没有开始执行（或等同于没有执行）。图10.3列出了触发标准例外的原因。
在M模式运行期间可能发生的同步例外有五种：
⚫ 访问错误异常 当物理内存的地址不支持访问类型时发生（例如尝试写入ROM）。
⚫ 断点异常 在执行ebreak指令，或者地址或数据与调试触发器匹配时发生。
⚫ 环境调用异常 在执行ecall指令时发生。
⚫ 非法指令异常 在译码阶段发现无效操作码时发生。
⚫ 非对齐地址异常 在有效地址不能被访问大小整除时发生，例如地址为0x12的
amoadd.w。</p>
<pre><code>图 10.3 ： RISC-V 异常和中断的原因。中断时mcause的最高有效位置 1 ，同步异常时置 0 ，且低有效位
标识了中断或异常的具体原因。只有在实现了监管者模式时才能处理监管者模式中断和页面错误异常
（参见第 10.5 节）。（来自 [Waterman and Asanovic 2017] 中的表 3.6 。）
</code></pre>
<pre><code>C扩展不会发生非对齐
的指令地址异常，因为
它永远不可能跳转到奇
数地址：分支和JAL的
立即数总是偶数，JALR
屏蔽其有效地址的最低
有效位。 如果没有C扩
展，跳转到被 4 除余 2
的地址时会发生此异
常。
</code></pre>
<pre><code>hart 是硬件线程
(hardware thread)的缩略
形式。 我们用该术语将
它们与大多数程序员熟
悉的软件线程区分开
来。软件线程在harts上
进行分时复用。 大多数
处理器核都只有一个
hart。
</code></pre>
<p>如果你还记得第二章声明允许非对齐的load和store，你可能会问为什么图10.3中还
会有非对齐的load和store地址异常。原因有两个，首先，第六章的原子内存操作需要自
然对齐的地址；其次，一些实现者选择省略对于非对齐的常规load和store的硬件支持，
因为它是一个难以实现的不常用特性。没有这种硬件的处理器依赖于异常处理程序，用一
系列较小的对齐load和store来模拟软件中非对齐的load和store。应用程序代码并没有变
得更好：虽然速度很慢，非对齐访存操作仍按预期进行，而硬件仍然很简单。或者，在更
高性能的处理器中可以硬件实现非对齐的load和store。这种实现上的灵活性归功于RISC-
V允许非对齐load和store与常规load和store共用操作码。这遵照了第一章将架构和具体
实现隔离开的准则。
有三种标准的中断源：软件、时钟和外部来源。软件中断通过向内存映射寄存器中存
数来触发，并通常用于由一个hart中断另一个hart（在其他架构中称为处理器间中断机
制）。当hart的时间比较器（一个名为mtimecmp的内存映射寄存器）大于实时计数器
mtime时，会触发时钟中断。外部中断由平台级中断控制器（大多数外部设备连接到这个
中断控制器）引发。不同的硬件平台具有不同的内存映射并且需要中断控制器的不同特
性，因此用于发出和消除这些中断的机制因平台而异。所有RISC-V系统的共同问题是如
何处理异常和屏蔽中断，这是下一节的主题。</p>
<h3 id="103-机器模式下的异常处理"><a class="header" href="#103-机器模式下的异常处理">10.3 机器模式下的异常处理</a></h3>
<h4 id="八个控制状态寄存器csr是机器模式下异常处理的必要部分"><a class="header" href="#八个控制状态寄存器csr是机器模式下异常处理的必要部分">八个控制状态寄存器（CSR）是机器模式下异常处理的必要部分：</a></h4>
<pre><code>⚫ mtvec（Machine Trap Vector）它保存发生异常时处理器需要跳转到的地址。
⚫ mepc（Machine Exception PC）它指向发生异常的指令。
⚫ mcause（Machine Exception Cause）它指示发生异常的种类。
⚫ mie（Machine Interrupt Enable）它指出处理器目前能处理和必须忽略的中断。
⚫ mip（Machine Interrupt Pending）它列出目前正准备处理的中断。
⚫ mtval（Machine Trap Value）它保存了陷入（trap）的附加信息：地址例外中出错
的地址、发生非法指令例外的指令本身，对于其他异常，它的值为 0 。
⚫ mscratch（Machine Scratch）它暂时存放一个字大小的数据。
⚫ mstatus（Machine Status）它保存全局中断使能，以及许多其他的状态，如图
10.4所示。
</code></pre>
<pre><code>图 10.4 ：mstatus控制状态寄存器。在仅有机器模式且没有 F 和 V 扩展的简单处理中，有效的域只有全
局中断使能、 MIE 和 MPIE （它在异常发生后保存 MIE 的旧值）。 RV32 的 XLEN 时 32 ， RV64 是 40 。
（来自 [Waterman and Asanovic 2017] 中的表 3.6 ；有关其他域的说明请参见该文档的第 3.1 节。）
</code></pre>
<p>处理器在M模式下运行时，只有在全局中断使能位mstatus.MIE置 1 时才会产生中
断.此外，每个中断在控制状态寄存器mie中都有自己的使能位。这些位在mie中的位置</p>
<p>对应于图10.3中的中断代码。例如，mie[7]对应于M模式中的时钟中断。控制状态寄存器
mip</p>
<pre><code>图 10.5 ： RISC-V 的权限模式和它们的编码
</code></pre>
<p>具有相同的布局，并且它指示当前待处理的中断。将所有三个控制状态寄存器合在一起考
虑，如果mstatus.MIE = 1 ，mie[7] = 1 ，且mip[7] = 1，则可以处理机器的时钟中断。
当一个hart发生异常时，硬件自动经历如下的状态转换：
⚫ 异常指令的PC被保存在mepc中，PC被设置为mtvec。（对于同步异常，mepc
指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。）
⚫ 根据异常来源设置mcause（如图10.3所示），并将mtval设置为出错的地址或
者其它适用于特定异常的信息字。
⚫ 把控制状态寄存器mstatus中的MIE位置零以禁用中断，并把先前的MIE值保
留到MPIE中。
⚫ 发生异常之前的权限模式保留在mstatus的MPP域中，再把权限模式更改为
M。图10.5显示了MPP域的编码（如果处理器仅实现M模式，则有效地跳过这
个步骤）。
为避免覆盖整数寄存器中的内容，中断处理程序先在最开始用mscratch和整数
寄存器（例如a0）中的值交换。通常，软件会让mscratch包含指向附加临时内存空
间的指针，处理程序用该指针来保存其主体中将会用到的整数寄存器。在主体执行之
后，中断程序会恢复它保存到内存中的寄存器，然后再次使用mscratch和a0交换，
将两个寄存器恢复到它们在发生异常之前的值。最后，处理程序用mret指令（M模
式特有的指令）返回。mret将PC设置为mepc，通过将mstatus的MPIE域复制到
MIE来恢复之前的中断使能设置，并将权限模式设置为mstatus的MPP域中的值。
这基本是前一段中描述的逆操作。
图10.6展示了遵循此模式的基本时钟中断处理程序的RISC-V汇编代码。它只对
时间比较器执行了递增操作，然后继续执行之前的任务。更实际的时钟中断处理程序
可能会调用调度程序，从而在任务之间切换。它是非抢占的，因此在处理程序的过程
中中断会被禁用。不考虑这些限制条件的话，它就是一个只有一页的RISC-V中断处
理程序的完整示例！
有时需要在处理异常的过程中转到处理更高优先级的中断。唉，mepc，
mcause，mtval和mstatus这些控制寄存器只有一个副本，处理第二个中断的时候
如果软件不进行一些帮助的话，这些寄存器中的旧值会被破坏，导致数据丢失。可抢
占的中断处理程序可以在启用中断之前把这些寄存器保存到内存中的栈，然后在退出
之前，禁用中断并从栈中恢复寄存器。
除了上面介绍的mret指令之外，M模式还提供了另外一条指令：wfi（Wait For
Interrupt）。wfi通知处理器目前没有任何有用的工作，所有它应该进入低功耗模式，
直到任何使能有效的中断等待处理，即mie&amp;mip≠ 0 。RISC-V处理器以多种方式实现
该指令，包括到中断待处理之前都停止时钟。有的时候只把这条指令当作nop来执
行。因此，wfi通常在循环内使用。</p>
<pre><code>RISC-V还支持向量中
断，其中处理器跳转到
各类中断各自对应的地
址，而不是一个统一的
入口点。这种寻址消除
了读取和解码mcause
的需要，加快了中断处
理速度。将mtval [0]设
置为 1 可启用此功能;
然后根据中断原因x将
PC设置为（mtval-1 +
4x）， 而 不 是 通 常 的
mtval。
</code></pre>
<p>图 <strong>10.6</strong> ；简单的 <strong>RISC-V</strong> 时钟中断处理程序代码。代码中假定了全局中断已通过置位mstatus <strong>.MIE</strong> 启
用；时钟中断已通过置位mie[7]启用；mtvec <strong>CSR</strong> 已设置为此处理程序的入口地址；而且mscratch
<strong>CSR</strong> 已经设置为有 <strong>16</strong> 个字节用于保存寄存器的临时空间的地址。第一部分保存了五个寄存器，把a0保
存在mscratch中，a1到a4保存在内存中。然后它检查mcause来读取异常的类别：如果mcause <strong>&lt;0</strong> 则
是中断，反之则是同步异常。如果是中断，就检查mcause的低位是否等于 <strong>7</strong> ，如果是，就是 <strong>M</strong> 模式的
时钟中断。如果确定是时钟中断，就给时间比较器加上 <strong>1000</strong> 个时钟周期，于是下一个时钟中断会发生在
大约 <strong>1000</strong> 个时钟周期之后。最后一段恢复了a0到a4和mscratch，然后用mret指令返回。</p>
<p>图 <strong>10.7</strong> ： <strong>PMP</strong> 地址和配置寄存器。地址寄存器右移两位，如果物理地址位宽小于 <strong>XLEN- 2</strong> ，则高位为 <strong>0</strong> 。
<strong>R</strong> 、 <strong>W</strong> 和 <strong>X</strong> 域分别对应读、写和执行权限。 <strong>A</strong> 域设置是否启用此 <strong>PMP</strong> ， <strong>L</strong> 域锁定了 <strong>PMP</strong> 和对应的地址
寄存器。</p>
<pre><code>图 10.8 ：pmpcfg CSR 中 PMP 配置的布局。对于 RV32 （上半部分）， 16 个配置寄存器被分配到 4 个
CSR 中。对于 RV64 （下半部分），它们则分配到了两个偶数编号的 CSR 中。
</code></pre>
<h3 id="104-嵌入式系统中的用户模式和进程隔离"><a class="header" href="#104-嵌入式系统中的用户模式和进程隔离">10.4 嵌入式系统中的用户模式和进程隔离</a></h3>
<h4 id="虽然机器模式对于简单的嵌入式系统已经足够但它仅适用于那些整个代码库都可信"><a class="header" href="#虽然机器模式对于简单的嵌入式系统已经足够但它仅适用于那些整个代码库都可信">虽然机器模式对于简单的嵌入式系统已经足够，但它仅适用于那些整个代码库都可信</a></h4>
<h4 id="的情况因为m模式可以自由地访问硬件平台更常见的情况是不能信任所有的应用程"><a class="header" href="#的情况因为m模式可以自由地访问硬件平台更常见的情况是不能信任所有的应用程">的情况，因为M模式可以自由地访问硬件平台。更常见的情况是，不能信任所有的应用程</a></h4>
<h4 id="序代码因为不能事先得知这一点或者它太大难以证明正确性因此risc-v提供了"><a class="header" href="#序代码因为不能事先得知这一点或者它太大难以证明正确性因此risc-v提供了">序代码，因为不能事先得知这一点，或者它太大，难以证明正确性。因此，RISC-V提供了</a></h4>
<h4 id="保护系统免受不可信的代码危害的机制并且为不受信任的进程提供隔离保护"><a class="header" href="#保护系统免受不可信的代码危害的机制并且为不受信任的进程提供隔离保护">保护系统免受不可信的代码危害的机制，并且为不受信任的进程提供隔离保护。</a></h4>
<pre><code>补充说明：wfi不论全局中断使能有效与否都有用
如果在全局中断使能有效（mstatus.MIE = 1）时执行wfi，然后有一个使能有效的中断等
待执行，则处理器跳转到异常处理程序。另一方面，如果在全局禁用中断时执行wfi，接着
一个使能有效的中断等待执行，那么处理器继续执行wfi之后的代码。这些代码通常会检
查控制状态寄存器mip，以决定下一步该做什么。与跳转到异常处理程序相比，这个策略可
以减少中断延迟，因为不需要保存和恢复整数寄存器。
</code></pre>
<pre><code>必须禁止不可信的代码执行特权指令（如mret）和访问特权控制状态寄存器（如
mstatus），因为这将允许程序控制系统。这样的限制很容易实现，只要加入一种额外的权
限模式：用户模式（U模式）。这种模式拒绝使用这些功能，并在尝试执行M模式指令或
访问CSR的时候产生非法指令异常。其它时候，U模式和M模式的表现十分相似。通过
将mstatus.MPP设置为U（如图10.5所示，编码为 0 ），然后执行mret指令，软件可以
从M模式进入U模式。如果在U模式下发生异常，则把控制移交给M模式。
这些不可信的代码还必须被限制只能访问自己那部分内存。实现了M和U模式的处
理器具有一个叫做物理内存保护（PMP，Physical Memory Protection）的功能，允许M模
式指定U模式可以访问的内存地址。PMP包括几个地址寄存器（通常为 8 到 16 个）和相
应的配置寄存器。这些配置寄存器可以授予或拒绝读、写和执行权限。当处于U模式的处
理器尝试取指或执行load或store操作时，将地址和所有的PMP地址寄存器比较。如果地
址大于等于PMP地址i，但小于PMP地址i+1，则PMP i+1的配置寄存器决定该访问是否
可以继续，如果不能将会引发访问异常。
图10.7显示了PMP地址寄存器和配置寄存器的布局。两者都是CSR，地址寄存器名
为pmpaddr0到pmpaddrN，其中N+1是实现的PMP个数。地址寄存器右移两位，因为
PMP以四字节为单位。配置寄存器密集地填充在CSR中以加速上下文切换，如图10.8所
示。PMP的配置由R、W和X位组成，他们分别对于load，store和fetch操作，还有另一
个域A，当它为 0 时禁用此PMP，当它为 1 时启用。PMP配置还支持其他模式，还可以加
锁，[Waterman and Asanovic 2017]中描述了这些功能。
</code></pre>
<h3 id="105-现代操作系统的监管者模式"><a class="header" href="#105-现代操作系统的监管者模式">10.5 现代操作系统的监管者模式</a></h3>
<h4 id="上一节中描述的pmp方案对嵌入式系统的实现很有吸引力因为它以相对较低的成本"><a class="header" href="#上一节中描述的pmp方案对嵌入式系统的实现很有吸引力因为它以相对较低的成本">上一节中描述的PMP方案对嵌入式系统的实现很有吸引力，因为它以相对较低的成本</a></h4>
<h4 id="提供了内存保护但它的一些缺点限制了它在通用计算中的使用由于pmp仅支持固定数"><a class="header" href="#提供了内存保护但它的一些缺点限制了它在通用计算中的使用由于pmp仅支持固定数">提供了内存保护，但它的一些缺点限制了它在通用计算中的使用。由于PMP仅支持固定数</a></h4>
<h4 id="量的内存区域因此无法对它进行扩展从而适应复杂的应用程序而且由于这些区域必须"><a class="header" href="#量的内存区域因此无法对它进行扩展从而适应复杂的应用程序而且由于这些区域必须">量的内存区域，因此无法对它进行扩展从而适应复杂的应用程序。而且由于这些区域必须</a></h4>
<h4 id="在物理存储中连续因此系统可能产生存储碎片化的问题另外pmp不能有效地支持对"><a class="header" href="#在物理存储中连续因此系统可能产生存储碎片化的问题另外pmp不能有效地支持对">在物理存储中连续，因此系统可能产生存储碎片化的问题。另外，PMP不能有效地支持对</a></h4>
<h4 id="辅存的分页"><a class="header" href="#辅存的分页">辅存的分页。</a></h4>
<h4 id="更复杂的risc-v处理器用和几乎所有通用架构相同的方式处理这些问题使用基于"><a class="header" href="#更复杂的risc-v处理器用和几乎所有通用架构相同的方式处理这些问题使用基于">更复杂的RISC-V处理器用和几乎所有通用架构相同的方式处理这些问题：使用基于</a></h4>
<h4 id="页面的虚拟内存这个功能构成了监管者模式s模式的核心这是一种可选的权限模"><a class="header" href="#页面的虚拟内存这个功能构成了监管者模式s模式的核心这是一种可选的权限模">页面的虚拟内存。这个功能构成了监管者模式（S模式）的核心，这是一种可选的权限模</a></h4>
<pre><code>式，旨在支持现代类Unix操作系统，如Linux，FreeBSD和Windows。S模式比U模式权
限更高，但比M模式低。与U模式一样，S模式下运行的软件不能使用M模式的CSR和
指令，并且受到PMP的限制。本届介绍S模式的中断和异常，下一节将详细介绍S模式
下的虚拟内存系统。
默认情况下，发生所有异常（不论在什么权限模式下）的时候，控制权都会被移交到
M模式的异常处理程序。但是Unix系统中的大多数例外都应该进行S模式下的系统调
用。M模式的异常处理程序可以将异常重新导向S模式，但这些额外的操作会减慢大多数
异常的处理速度。因此，RISC-V提供了一种异常委托机制。通过该机制可以选择性地将中
断和同步异常交给S模式处理，而完全绕过M模式。
mideleg（Machine Interrupt Delegation，机器中断委托）CSR控制将哪些中断委托给S
模式。与mip和mie一样，mideleg中的每个位对应于图10.3中相同的异常。例如，
mideleg[5]对应于S模式的时钟中断，如果把它置位，S模式的时钟中断将会移交S模式
的异常处理程序，而不是M模式的异常处理程序。
委托给S模式的任何中断都可以被S模式的软件屏蔽。sie（Supervisor Interrupt
</code></pre>
<p>存储碎片化的问题发生
在内存可用的时候，但
不包括足够大的连续块
的情况。</p>
<pre><code>为什么不无条件地将中
断委托给S模式？ 一
个原因是虚拟化：如果
M模式想要虚拟一个S
模式的设备，其中断应
该转到M模式，而不是
S模式。
</code></pre>
<p>图 <strong>10.9</strong> ：sstatus <strong>CSR</strong> 。sstatus是mstatus（图 <strong>10.4</strong> ）的一个子集，因此它们的布局类似。 <strong>SIE</strong> 和 <strong>SPIE</strong>
中分别保存了当前的和异常发生之前的中断使能，类似于mstatus中的 <strong>MIE</strong> 和 <strong>MPIE</strong> 。 <strong>RV32</strong> 的 <strong>XLEN</strong>
为 <strong>32</strong> ， <strong>RV64</strong> 为 <strong>40</strong> 。（来自 <strong>[Waterman and Asanovic 2017]</strong> 中的图 <strong>4.2</strong> ；有关其他域的说明请参见该文档的
第 <strong>4.1</strong> 节。）</p>
<p>Enable，监管者中断使能）和sip（Supervisor Interrupt Pending，监管者中断待处理）CSR
是S模式的控制状态寄存器，他们是mie和mip的子集。它们有着和M模式下相同的布
局，但在sie和sip中只有与由mideleg委托的中断对应的位才能读写。那些没有被委派
的中断对应的位始终为零。
M模式还可以通过medeleg CSR将同步异常委托给S模式。该机制类似于刚才提到
的中断委托，但medeleg中的位对应的不再是中断，而是图10.3中的同步异常编码。例
如，置上medeleg[15]便会把store page fault（store过程中出现的缺页）委托给S模式。
请注意，无论委派设置是怎样的，发生异常时控制权都不会移交给权限更低的模式。
在M模式下发生的异常总是在M模式下处理。在S模式下发生的异常，根据具体的委派
设置，可能由M模式或S模式处理，但永远不会由U模式处理。
S模式有几个异常处理CSR：sepc、stvec、scause、sscratch、stval和sstatus，它
们执行与10.2中描述的M模式CSR相同的功能。图10.9显示了sstatus寄存器的布局。
监管者异常返回指令sret与mret的行为相同，但它作用于S模式的异常处理CSR，而不
是M模式的CSR。
S模式处理例外的行为已和M模式非常相似。如果hart接受了异常并且把它委派给了
S模式，则硬件会原子地经历几个类似的状态转换，其中用到了S模式而不是M模式的
CSR：
⚫ 发生例外的指令的PC被存入sepc，且PC被设置为stvec。
⚫ scause按图10.3根据异常类型设置，stval被设置成出错的地址或者其它特定异
常的信息字。
⚫ 把sstatus CSR中的SIE置零，屏蔽中断，且SIE之前的值被保存在SPIE中。
⚫ 发生例外时的权限模式被保存在sstatus的SPP域，然后设置当前模式为S模
式。</p>
<h3 id="106-基于页面的虚拟内存"><a class="header" href="#106-基于页面的虚拟内存">10.6 基于页面的虚拟内存</a></h3>
<h4 id="s模式提供了一种传统的虚拟内存系统它将内存划分为固定大小的页来进行地址转"><a class="header" href="#s模式提供了一种传统的虚拟内存系统它将内存划分为固定大小的页来进行地址转">S模式提供了一种传统的虚拟内存系统，它将内存划分为固定大小的页来进行地址转</a></h4>
<p>换和对内存内容的保护。启用分页的时候，大多数地址（包括load和store的有效地址和
PC中的地址）都是虚拟地址。要访问物理内存，它们必须被转换为真正的物理地址，这通
过遍历一种称为页表的高基数树实现。页表中的叶节点指示虚地址是否已经被映射到了真
正的物理页面，如果是，则指示了哪些权限模式和通过哪种类型的访问可以操作这个页。</p>
<pre><code>S模式不直接控制时钟
中断和软件中断，而是
使用ecall指令请求M
模式设置定时器或代表
它发送处理器间中断。
该软件约定是监管者二
进 制 接 口(Supervisor
Binary Interface)的一部
分。
</code></pre>
<pre><code>图 10.10 ：一个 RV32 Sv32 页表项（ PTE ）。
</code></pre>
<pre><code>图 10.11 ：一个 RV64 Sv39 页表项（ PTE ）。
</code></pre>
<pre><code>访问未被映射的页或访问权限不足会导致页错误例外（page fault exception）。
RISC-V的分页方案以SvX的模式命名,其中X是以位为单位的虚拟地址的长度。
RV32的分页方案Sv32支持4GiB的虚址空间，这些空间被划分为 210 个 4 MiB大小的巨
页。每个巨页被进一步划分为 210 个 4 KiB大小的基页（分页的基本单位）。因此，Sv32的
页表是基数为 210 的两级树结构。页表中每个项的大小是四个字节，因此页表本身的大小
是 4 KiB。页表的大小和每个页的大小完全相同，这样的设计简化了操作系统的内存分
配。
图10.10显示了Sv32页表项（page-table entry，PTE）的布局，从左到右分别包含如下
所述的域：
⚫ V位决定了该页表项的其余部分是否有效（V = 1 时有效）。若V = 0 ，则任何遍历
到此页表项的虚址转换操作都会导致页错误。
⚫ R、W和X位分别表示此页是否可以读取、写入和执行。如果这三个位都是 0 ，
那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。
⚫ U位表示该页是否是用户页面。若U = 0 ，则U模式不能访问此页面，但S模式
可以。若U = 1 ，则U模式下能访问这个页面，而S模式不能。
⚫ G位表示这个映射是否对所有虚址空间有效，硬件可以用这个信息来提高地址转
换的性能。这一位通常只用于属于操作系统的页面。
⚫ A位表示自从上次A位被清除以来，该页面是否被访问过。
⚫ D位表示自从上次清除D位以来页面是否被弄脏（例如被写入）。
⚫ RSW域留给操作系统使用，它会被硬件忽略。
⚫ PPN域包含物理页号，这是物理地址的一部分。若这个页表项是一个叶节点，那
么PPN是转换后物理地址的一部分。否则PPN给出下一节页表的地址。（图
10.10将PPN划分为两个子域，以简化地址转换算法的描述。）
</code></pre>
<pre><code>RV64支持多种分页方案，但我们只介绍最受欢迎的一种，Sv 39 。Sv39使用和Sv32相
同的 4 KiB大的基页。页表项的大小变成 8 个字节，所以它们可以容纳更大的物理地址。
为了保证页表大小和页面大小一致，树的基数相应地降到 29 ，树也变为三层。Sv39的 512
GiB地址空间划分为 29 个 1 GiB大小的吉页。每个吉页被进一步划分为 29 个巨页。在
Sv39中这些巨页大小为 2 MiB，比Sv32中略小。每个巨页再进一步分为 29 个 4 KiB大小
的基页。
图10.11显示了Sv39页表项的布局。它和Sv32完全相同，只是PPN字段被扩展到了
44 位，以支持 56 位的物理地址，或者说 226 GiB大小的物理地址空间。
</code></pre>
<p>从IBM 360模型 67 开
始，4 KiB大小的页面
已经流行了五十年。
Atlas是第一台带分页
的计算机，有3 KiB大
小的页（字长 6 个字
节）。 我们发现，在计
算机性能和内存容量呈
指数增长半个世纪后，
页面大小基本保持不
变，这一点值得注意。</p>
<pre><code>操作系统依赖于A位和
D位来决定将哪些页面
交换到辅存。 定期清除
A位有助于OS判断哪
些页面是最近最少使用
的。 置上D位表示换
出该页面的成本更高，
因为它必须写回辅存。
</code></pre>
<pre><code>其他RV64分页方案只
是向页表添加更多级
别。 Sv48与Sv39几乎
相同，但其虚拟地址空
间大 29 倍，页表更深一
层。
</code></pre>
<pre><code>图 10.12 ：satp CSR 。来自 [Waterman and Asanovic 2017] 中的图 4.11 和 4.12 。
</code></pre>
<pre><code>图 10.13 ：satp CSR 中 MODE 域的编码。来自 [Waterman and Asanovic 2017] 中的表 4.3 。
</code></pre>
<p>一个叫satp（Supervisor Address Translation and Protection，监管者地址转换和保护）
的S模式控制状态寄存器控制了分页系统。如图10.12所示，satp有三个域。MODE域可
以开启分页并选择页表级数，图10.13展示了它的编码。ASID（Address Space Identifier，
地址空间标识符）域是可选的，它可以用来降低上下文切换的开销。最后，PPN字段保存
了根页表的物理地址，它以 4 KiB的页面大小为单位。通常M模式的程序在第一次进入S
模式之前会把零写入satp以禁用分页，然后S模式的程序在初始化页表以后会再次进行
satp寄存器的写操作。</p>
<pre><code>补充说明：未被使用的地址位
由于Sv39的虚拟地址比RV64整数寄存器要短，可能你想知道剩下的 35 位是什么。Sv39
要求地址位 63 - 39 是第 38 位的副本。因此有效的虚拟地址是 0000 _0000_0000_0000 hex -
0000_003f_ffff_ffff hex 和ffff_ffc0_0000_0000hex-ffff_ffff_ffff_ffff hex 。这两个区间之间间隔的大
小是两个区间长度大小的 225 倍，看上去似乎浪费了 64 位寄存器可以表达范围的
99.999997%。为什么不充分地利用这额外的 25 位空间呢？答案是，随着程序的增长，它们
可能会需要大于512 GiB的虚址空间。而架构师希望再不破坏向后兼容性的前提下增加地
址空间。如果我们允许程序在高 25 位中存储额外的数据，那么以后就不可能把这些位回收
从而存储更大的地址。像这样允许在未使用的地址位中存储数据的严重错误，在计算机的历
史中已经重复出现了多次。
</code></pre>
<pre><code>图 10.14 ： Sv32 中地址转换过程的图示。
</code></pre>
<p>当在satp寄存器中启用了分页时，S模式和U模式中的虚拟地址会以从根部遍历页表
的方式转换为物理地址。图10.14描述了这个过程：</p>
<ol>
<li>satp.PPN给出了一级页表的基址，VA[31:22]给出了一级页号，因此处理器会读取
位于地址(satp.PPN× 4096 +VA[ 31 : 22 ]× 4 )的页表项。</li>
<li>该PTE包含二级页表的基址，VA[21:12]给出了二级页号，因此处理器读取位于地
址(PTE.PPN× 4096 +VA[ 21 : 12 ]× 4 )的叶节点页表项。</li>
<li>叶节点页表项的PPN字段和页内偏移（原始虚址的最低 12 个有效位）组成了最
终结果：物理地址就是(LeafPTE.PPN× 4096 +VA[ 11 : 0 ])</li>
</ol>
<p>随后处理器会进行物理内存的访问。Sv39的转换过程几乎和Sv32相同，区别在于其
具有较大的PTE和更多级页表。本章末尾的图10.19给出了页表遍历算法的完整描述，详
细说明了例外条件和超页面转换的特殊情况。
除了一点以外，我们几乎讲完了RISC-V分页系统的所有内容。如果所有取指，load
和store操作都导致多次页表访问，那么分页会大大地降低性能！所有现代的处理器都用地
址转换缓存（通常称为TLB，全称为Translation Lookaside Buffer）来减少这种开销。为了
降低这个缓存本身的开销，大多数处理器不会让它时刻与页表保持一致。这意味着如果操
作系统修改了页表，那么这个缓存会变得陈旧而不可用。S模式添加了另一条指令来解决
这个问题。这条sfence.vma会通知处理器，软件可能已经修改了页表，于是处理器可以
相应地刷新转换缓存。它需要两个可选的参数，这样可以缩小缓存刷新的范围。一个位于
rs1，它指示了页表哪个虚址对应的转换被修改了；另一个位于rs2，它给出了被修改页表
的进程的地址空间标识符（ASID）。如果两者都是x0，便会刷新整个转换缓存。</p>
<p>图 <strong>10.15</strong> ：机器中断寄存器。它们是宽为 <strong>XLEN</strong> 位的读 <strong>/</strong> 写寄存器，用于保存待处理的中断（mip）和中断
使能位（mie） <strong>CSR</strong> 。只有与mip中的位对应的低权限软件中断（ <strong>USIP</strong> ， <strong>SSIP</strong> ）、时钟中断（ <strong>UTIP</strong> ，
<strong>STIP</strong> ）和外部中断（ <strong>UEIP</strong> ， <strong>SEIP</strong> ）的位才能通过该 <strong>CSR</strong> 的地址写入；其余的位是只读的。</p>
<pre><code>图 10.16 ：监管者中断寄存器。它们是宽为 XLEN 位的读 / 写寄存器，用于保存待处理的中断（sip）和中
断使能位（ sie ） CSR 。
</code></pre>
<pre><code>图 10.17 ：机器和监管者自陷向量（ trap-vector ）基地址寄存器（mtvec和stvec） CSR 。他们是位宽为
XLEN 的读 / 写寄存器，用于保存自陷向量的配置，包括向量基址（ BASE ）和向量模式（ MODE ）。
BASE 域中的值必须按 4 字节对齐。 MODE = 0 表示所有异常都把 PC 设置为 BASE 。 MODE = 1 会在一
部中断时将 PC 设置为(푩푨푺푬+(ퟒ×풄풂풖풔풆))。
</code></pre>
<pre><code>图 10.18 ：机器和监管者cause（mcause和scause） CSR 。当处理自陷时， CSR 中被写入一个指示导致
自陷的事件的代码。如果自陷由中断引起，则置上中断位。“异常代码”字段包含指示最后一个异常的代
码。 [Waterman and Asanovic 2017] 中的表 3.6 中包含自陷的来源到自陷代码的映射。
</code></pre>
<h3 id="107-结束语"><a class="header" href="#107-结束语">10.7 结束语</a></h3>
<p>研究表明，最优秀的设计师会设计出更快、更小、更简单的结构，而且设计过程也更轻松。伟大的结构和
一般的结构之间差了一个数量级。
——Fred Brooks,Jr.,1986
Brooks是图灵奖获得者，还是IBM System/ 360 系列计算机的架构师（这些计算机说明了将架构和实现
区分开来的重要性）。这个 1964 年诞生的架构的继承者至今仍在销售。</p>
<pre><code>补充说明： 多处理器中的地址转换缓存一致性
sfence.vma仅影响执行当前指令的hart的地址转换硬件。当hart更改了另一个hart正在使
用的页表时，前一个hart必须用处理器间中断来通知后一个hart，他应该执行sfence.vma
指令。这个过程通常被称为 TLB 击落。
</code></pre>
<h4 id="risc-v特权架构的模块化特性满足了各种系统的需求十分精简的机器模式以低成"><a class="header" href="#risc-v特权架构的模块化特性满足了各种系统的需求十分精简的机器模式以低成">RISC-V特权架构的模块化特性满足了各种系统的需求。十分精简的机器模式以低成</a></h4>
<h4 id="本的特征支持裸机嵌入式应用附加的用户模式和物理内存保护功能共同支持了更复杂"><a class="header" href="#本的特征支持裸机嵌入式应用附加的用户模式和物理内存保护功能共同支持了更复杂">本的特征支持裸机嵌入式应用。附加的用户模式和物理内存保护功能共同支持了更复杂</a></h4>
<h4 id="的嵌入式系统中的多任务处理最后监管者模式和基于页面的虚拟内存提供了运行现"><a class="header" href="#的嵌入式系统中的多任务处理最后监管者模式和基于页面的虚拟内存提供了运行现">的嵌入式系统中的多任务处理。最后，监管者模式和基于页面的虚拟内存提供了运行现</a></h4>
<h4 id="代操作系统所必需的灵活性"><a class="header" href="#代操作系统所必需的灵活性">代操作系统所必需的灵活性。</a></h4>
<h3 id="108-扩展阅读"><a class="header" href="#108-扩展阅读">10.8 扩展阅读</a></h3>
<p>A. Waterman and K. Asanovi ́c, editors. The RISC-V Instruction Set Manual Volume II:
Privileged Architecture Version 1.10. May 2017. URL https://riscv.org/specifications/privileged-
isa/.</p>
<p>注记</p>
<pre><code>http://parlab.eecs.berkeley.edu
</code></pre>
<p>图 <strong>10.19</strong> ：虚址到物理地址转换的完整算法。 <strong>va</strong> 是输入的虚拟地址， <strong>pa</strong> 是输出的物理地址。
<strong>PAGESIZE</strong> 是常数 <strong>212</strong> 。在 <strong>Sv32</strong> 中， <strong>LEVELS = 2</strong> 且 <strong>PTESIZE = 4</strong> ；而在 <strong>Sv39</strong> 中， <strong>LEVELS = 3</strong> 且
<strong>PTESIZE = 8</strong> 。来自 <strong>[Waterman and Asanovic 2017]</strong> 中的第 <strong>4.3.2</strong> 节。</p>
<h2 id="第十一章-risc-v未来的可选扩展"><a class="header" href="#第十一章-risc-v未来的可选扩展">第十一章 RISC-V未来的可选扩展</a></h2>
<pre><code>对于复杂性，傻子无视它，实用主义者忍受它，有的人有时能规避它，而天才则解决它。
——Alan Perlis, 1982
</code></pre>
<pre><code>以RISC-V为基础，至少可以有 8 种可选的扩展。
</code></pre>
<h3 id="111-b标准扩展位操作"><a class="header" href="#111-b标准扩展位操作">11.1 “B”标准扩展：位操作</a></h3>
<pre><code>B扩展提供位操作，包括插入、提取和测试位字段（insert, extract, and test bit fields），旋
转（rotations），漏斗位移（funnel shifts），位置换和字节置换（bit and byte permutations），计
算前导 0 和尾随 0 （count leading and trailing zeros）和计算置位数（count bits set）等。
</code></pre>
<h3 id="112-e标准扩展嵌入式"><a class="header" href="#112-e标准扩展嵌入式">11.2 “E”标准扩展：嵌入式</a></h3>
<h4 id="为了降低对低端核心的开销这个扩展少了-16-个寄存器正是因为rv32e被保存寄"><a class="header" href="#为了降低对低端核心的开销这个扩展少了-16-个寄存器正是因为rv32e被保存寄">为了降低对低端核心的开销，这个扩展少了 16 个寄存器。正是因为RV32E，被保存寄</a></h4>
<h4 id="存器和临时寄存器都是在-0---15-号和-16---31-号这两部分之间分开的图-3-2"><a class="header" href="#存器和临时寄存器都是在-0---15-号和-16---31-号这两部分之间分开的图-3-2">存器和临时寄存器都是在 0 - 15 号和 16 - 31 号这两部分之间分开的（图 3 .2）。</a></h4>
<h3 id="113-h特权态架构扩展支持管理程序hypervisor"><a class="header" href="#113-h特权态架构扩展支持管理程序hypervisor">11.3 “H”特权态架构扩展：支持管理程序（Hypervisor）</a></h3>
<h4 id="h特权架构扩展加入了管理程序模式和基于内存页的二级地址翻译机制提高在同一台"><a class="header" href="#h特权架构扩展加入了管理程序模式和基于内存页的二级地址翻译机制提高在同一台">H特权架构扩展加入了管理程序模式和基于内存页的二级地址翻译机制，提高在同一台</a></h4>
<h4 id="计算机上运行多个操作系统的效率"><a class="header" href="#计算机上运行多个操作系统的效率">计算机上运行多个操作系统的效率。</a></h4>
<h3 id="114-j标准扩展动态翻译语言"><a class="header" href="#114-j标准扩展动态翻译语言">11.4 “J”标准扩展：动态翻译语言</a></h3>
<pre><code>有许多常用的语言使用了动态翻译，比如Java和Javascript。这些语言的动态检查和垃
圾回收可以得到ISA的支持。（J表示即时（Just-In-Time）编译。）
</code></pre>
<h3 id="115-l标准扩展十进制浮点"><a class="header" href="#115-l标准扩展十进制浮点">11.5 “L”标准扩展：十进制浮点</a></h3>
<h4 id="l扩展的目的是支持ieee-754--2008-标准规定的十进制浮点算术运算二进制数的问题"><a class="header" href="#l扩展的目的是支持ieee-754--2008-标准规定的十进制浮点算术运算二进制数的问题">L扩展的目的是支持IEEE 754- 2008 标准规定的十进制浮点算术运算。二进制数的问题</a></h4>
<h4 id="在于无法表示出一些常用的十进制小数如-0-1rv32l使得计算基数可以和输入输出的基"><a class="header" href="#在于无法表示出一些常用的十进制小数如-0-1rv32l使得计算基数可以和输入输出的基">在于无法表示出一些常用的十进制小数，如 0 .1。RV32L使得计算基数可以和输入输出的基</a></h4>
<h4 id="数相同"><a class="header" href="#数相同">数相同。</a></h4>
<h3 id="116-n标准扩展用户态中断"><a class="header" href="#116-n标准扩展用户态中断">11.6 “N”标准扩展：用户态中断</a></h3>
<h4 id="n扩展允许用户态程序发生中断和例外后直接进入用户态的处理程序不触发外层运"><a class="header" href="#n扩展允许用户态程序发生中断和例外后直接进入用户态的处理程序不触发外层运">N扩展允许用户态程序发生中断和例外后，直接进入用户态的处理程序，不触发外层运</a></h4>
<p><strong>Alan Perlis</strong> （ 1922 -
1900 ），因为在高级编程
语言和编译器领域的贡
献而成为第一位图灵奖
得主（ 1966 ）。 1958 年参
与设计了ALGOL，对后来
所有的命令式语言，包
括C和Java都有巨大影
响。</p>
<h4 id="行环境响应用户态中断主要用于支持存在m模式和u模式的安全嵌入式系统见第-10"><a class="header" href="#行环境响应用户态中断主要用于支持存在m模式和u模式的安全嵌入式系统见第-10">行环境响应。用户态中断主要用于支持存在M模式和U模式的安全嵌入式系统（见第 10</a></h4>
<p>章）。不过，它也能支持类Unix操作系统中的用户态中断。当在Unix环境中使用时，传统
的信号处理机制依然保留，而用户态中断可以用来做未来的扩展，产生诸如垃圾回收屏障
（garbage collection barriers）、整数溢出（integer overflow）、浮点陷入（floating-point traps）
等用户态事件。</p>
<h3 id="117-p标准扩展封装的单指令多数据packed-simd指令"><a class="header" href="#117-p标准扩展封装的单指令多数据packed-simd指令">11.7 “P”标准扩展：封装的单指令多数据（Packed-SIMD）指令</a></h3>
<h4 id="p扩展细分了现有的寄存器架构提供更小数据类型上的并行计算封装的单指令多数"><a class="header" href="#p扩展细分了现有的寄存器架构提供更小数据类型上的并行计算封装的单指令多数">P扩展细分了现有的寄存器架构，提供更小数据类型上的并行计算。封装的单指令多数</a></h4>
<h4 id="据指令代表了一种合理复用现有宽数据通路的设计不过如果有额外的资源来进行并行计"><a class="header" href="#据指令代表了一种合理复用现有宽数据通路的设计不过如果有额外的资源来进行并行计">据指令代表了一种合理复用现有宽数据通路的设计。不过，如果有额外的资源来进行并行计</a></h4>
<h4 id="算第-8-章的向量架构通常是更好的选择设计者更应使用rvv扩展"><a class="header" href="#算第-8-章的向量架构通常是更好的选择设计者更应使用rvv扩展">算，第 8 章的向量架构通常是更好的选择，设计者更应使用RVV扩展。</a></h4>
<h3 id="118-q标准扩展四精度浮点"><a class="header" href="#118-q标准扩展四精度浮点">11.8 “Q”标准扩展：四精度浮点</a></h3>
<h4 id="q扩展增加了符合ieee-754--2008-标准的-128-位的四精度浮点指令扩展后的浮点寄存"><a class="header" href="#q扩展增加了符合ieee-754--2008-标准的-128-位的四精度浮点指令扩展后的浮点寄存">Q扩展增加了符合IEEE 754- 2008 标准的 128 位的四精度浮点指令。扩展后的浮点寄存</a></h4>
<h4 id="器可以存储一个单精度双精度或者四精度的浮点数四精度浮点扩展要求rv64ifd"><a class="header" href="#器可以存储一个单精度双精度或者四精度的浮点数四精度浮点扩展要求rv64ifd">器可以存储一个单精度、双精度或者四精度的浮点数。四精度浮点扩展要求RV64IFD。</a></h4>
<h3 id="119-结束语"><a class="header" href="#119-结束语">11.9 结束语</a></h3>
<pre><code>简化，简化。
——亨利·大卫·梭罗（Henry David Thoreau）， 19 世纪著名作家， 1854
</code></pre>
<p>RISC-V具有开放、标准的扩展方式，可能意味着可以在指令集最终确定之前得到反馈
和争论，使得进一步的修改为时未晚。理想情况下，一小部分成员将先把一个提议实现出来，
然后再提交通过，而FPGA上让实现的过程变得很容易。通过RISC-V基础委员会提交指令
扩展所需工作量比较适中，他们将努力控制ISA变动的速度，至少不会像x 86 - 32 那样有太
快的变化（见第[1]章的图 1 .2）。另外别忘了，不管有多少扩展被应用了，这一章提到的这些
东西都是可选的。
我们希望RISC-V可以在保持简洁和高效的同时适应技术需求的发展。如果RISC-V成
功了，它将成为以往增量式ISA上的一次革命性突破。</p>
<h2 id="附录a-risc-v指令列表"><a class="header" href="#附录a-risc-v指令列表">附录A RISC-V指令列表</a></h2>
<pre><code>简约是一切真正优雅的要义。——Coco Chanel， 1923
</code></pre>
<pre><code>本附录列出了RV32/64I的所有指令、本书中涵盖的所有扩展（RVM、RVA、RVF、RVD、
RVC和RVV）以及所有伪指令。每个条目都包括指令名称、操作数、寄存器传输级定义、
指令格式类型、中文描述、压缩版本（如果存在），以及一张带有操作码的指令布局图。我
们认为这些摘要对于您了解所有的指令已经足够，但如果您想了解更多细节，请参阅RISC-
V官方规范[Waterman and Asanovic 2017]。
为了帮助读者在本附录中找到所需的指令，左侧（奇数）页面的标题包含该页顶部的第
一条指令，右侧（偶数）页面的标题包含该页底部的最后一条指令。格式类似于字典的标题，
有助于您搜索单词所在的页面。例如，下一个偶数页的标题是 AMOADD.W ，这是该页的第
一条指令；下一个奇数页的标题是 AMOMINU.D ，这是该页的最后一条指令。如下是你能
在这两页中找到的指令：amoadd.w、adoand.d、amoadn.w、amomax.d、amomax.w、
amomaxu.d、amomaxu.w、amomin.d、amomin.w和amominu.d。
</code></pre>
<p>Coco Chanel ( 1883 -
1971 )香奈儿时装品牌
的创始人，她对昂贵的
简约的追求塑造了 20
世纪的时尚。</p>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>add rd, rs1, rs2 x[rd] = x[rs1] + x[rs2]
加 <em>(Add)</em>. R-type, RV32I and RV64I.
把寄存器x[ <em>rs2</em> ]加到寄存器x[ <em>rs1</em> ]上，结果写入x[ <em>rd</em> ]。忽略算术溢出。
压缩形式： <strong>c.add</strong> rd, rs2; <strong>c.mv</strong> rd, rs2</p>
<pre><code>0000000 rs2 rs1 000 Rd 0110011
</code></pre>
<p>addi rd, rs1, immediate x[rd] = x[rs1] + sext(immediate)
加立即数 <em>(Add Immediate)</em>. I-type, RV32I and RV64I.
把符号位扩展的立即数加到寄存器x[ <em>rs1</em> ]上，结果写入x[ <em>rd</em> ]。忽略算术溢出。
压缩形式： <strong>c.li</strong> rd, imm; <strong>c.addi</strong> rd, imm; <strong>c.addi16sp</strong> imm; <strong>c.addi4spn</strong> rd, imm</p>
<pre><code>immediate[11:0] rs1 000 rd 0010011
</code></pre>
<p>addiw rd, rs1, immediate x[rd] = sext((x[rs1] + sext(immediate))[31:0])
加立即数字 <em>(Add Word Immediate)</em>. I-type, RV64I.
把符号位扩展的立即数加到x[ <em>rs1</em> ]，将结果截断为 32 位，把符号位扩展的结果写入x[ <em>rd</em> ]。
忽略算术溢出。
压缩形式： <strong>c.addiw</strong> rd, imm</p>
<pre><code>immediate[11:0] rs1 000 rd 0011011
</code></pre>
<p>addw rd, rs1, rs2 x[rd] = sext((x[rs1] + x[rs2])[31:0])
加字 <em>(Add Word)</em>. R-type, RV64I.
把寄存器x[ <em>rs2</em> ]加到寄存器x[ <em>rs1</em> ]上，将结果截断为 32 位，把符号位扩展的结果写入x[ <em>rd</em> ]。
忽略算术溢出。
压缩形式： <strong>c.addw</strong> rd, rs2</p>
<pre><code>0000000 rs2 rs1 000 rd 0111011
</code></pre>
<p>amoadd.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] + x[rs2])
原子加双字 <em>(Atomic Memory Operation: Add Doubleword)</em>. R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为 <em>t</em> +x[ <em>rs2</em> ]，把
x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>00000 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>amoadd.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] + x[rs2])</p>
<p>原子加字 <em>(Atomic Memory Operation: Add Word)</em>. R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为 <em>t</em> +x[ <em>rs2</em> ]，把x[ <em>rd</em> ]
设为符号位扩展的 <em>t</em> 。</p>
<pre><code>00000 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>amoand.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] &amp; x[rs2])</p>
<p>原子双字与 <em>(Atomic Memory Operation: AND Doubleword)</em>. R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]位
与的结果，把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>01100 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amoand.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] &amp; x[rs2])</p>
<p>原子字与 <em>(Atomic Memory Operation: AND Word)</em>. R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]位与的
结果，把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>01100 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>amomax.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] MAX x[rs2])</p>
<p>原子最大双字 <em>(Atomic Memory Operation: Maximum Doubleword)</em>. R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]中
较大的一个（用二进制补码比较），把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>10100 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amomax.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] MAX x[rs2])</p>
<p>原子最大字 <em>(Atomic Memory Operation: Maximum Word)</em>. R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]中较大
的一个（用二进制补码比较），把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>10100 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>amomaxu.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] MAXU x[rs2])
原子无符号最大双字 <em>(Atomic Memory Operation: Maximum Doubleword, Unsigned).</em> R-type,
RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]中
较大的一个（用无符号比较），把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>11100 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amomaxu.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] MAXU x[rs2])
原子无符号最大字 <em>(Atomic Memory Operation: Maximum Word, Unsigned).</em> R-type, RV32A and
RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]中较大
的一个（用无符号比较），把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>11100 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>amomin.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] MIN x[rs2])
原子最小双字 <em>(Atomic Memory Operation: Minimum Doubleword).</em> R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]中
较小的一个（用二进制补码比较），把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>10000 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amomin.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] MIN x[rs2])
原子最小字 <em>(Atomic Memory Operation: Minimum Word).</em> R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]中较小
的一个（用二进制补码比较），把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>10000 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>amominu.d rd, rs2,(rs1) x[rd] = AMO64(M[x[rs1]] MINU x[rs2])
原子无符号最小双字 <em>(Atomic Memory Operation: Minimum Doubleword, Unsigned).</em> R-type,
RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]中
较小的一个（用无符号比较），把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>11000 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>amominu.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] MINU x[rs2])</p>
<p>原子无符号最大字 <em>(Atomic Memory Operation: Minimum Word, Unsigned).</em> R-type, RV32A and
RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]中较小
的一个（用无符号比较），把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>11000 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>amoor.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] | x[rs2])</p>
<p>原子双字或 <em>(Atomic Memory Operation: OR Doubleword)</em>. R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]位
或的结果，把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>01000 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amoor.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] | x[rs2])</p>
<p>原子字或 <em>(Atomic Memory Operation: OR Word)</em>. R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]位或的
结果，把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>01000 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>amoswap.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] SWAP x[rs2])</p>
<p>原子双字交换 <em>(Atomic Memory Operation: Swap Doubleword)</em>. R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为x[ <em>rs2</em> ]的值，
把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>00001 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amoor.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] SWAP x[rs2])
原子字交换 <em>(Atomic Memory Operation: Swap Word)</em>. R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为x[ <em>rs2</em> ]的值，把
x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>00001 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>amoxor.d rd, rs2, (rs1) x[rd] = AMO64(M[x[rs1]] ^ x[rs2])</p>
<p>原子双字异或 <em>(Atomic Memory Operation: XOR Doubleword)</em>. R-type, RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的双字记为 <em>t</em> ，把这个双字变为t和x[ <em>rs2</em> ]按
位异或的结果，把x[ <em>rd</em> ]设为 <em>t</em> 。</p>
<pre><code>00100 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<p>amoxor.w rd, rs2, (rs1) x[rd] = AMO32(M[x[rs1]] ^ x[rs2])</p>
<p>原子字异或 <em>(Atomic Memory Operation: XOR Word)</em>. R-type, RV32A and RV64A.
进行如下的原子操作：将内存中地址为x[ <em>rs1</em> ]中的字记为 <em>t</em> ，把这个字变为t和x[ <em>rs2</em> ]按位异
或的结果，把x[ <em>rd</em> ]设为符号位扩展的 <em>t</em> 。</p>
<pre><code>00100 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>and rd, rs1, rs2 x[rd] = x[rs1] &amp; x[rs2]
与 <em>(And)</em>. R-type, RV32I and RV64I.
将寄存器x[ <em>rs1</em> ]和寄存器x[ <em>rs 2</em> ]位与的结果写入x[ <em>rd</em> ]。
压缩形式： <strong>c.and</strong> rd, rs2</p>
<pre><code>0000000 rs2 rs1 111 rd 0110011
</code></pre>
<p>andi rd, rs1, immediate x[rd] = x[rs1] &amp; sext(immediate)</p>
<p>与立即数 <em>(And Immediate)</em>. I-type, RV32I and RV64I.
把符号位扩展的立即数和寄存器x[ <em>rs1</em> ]上的值进行位与，结果写入x[ <em>rd</em> ]。
压缩形式： <strong>c.andi</strong> rd, imm</p>
<pre><code>immediate[11:0] rs1 111 rd 0010011
</code></pre>
<p>auipc rd, immediate x[rd] = pc + sext(immediate[31:12] &lt;&lt; 12)</p>
<p><em>PC</em> 加立即数 <em>(Add Upper Immediate to PC)</em>. U-type, RV32I and RV64I.
把符号位扩展的 20 位（左移 12 位）立即数加到 <em>pc</em> 上，结果写入x[ <em>rd</em> ]。</p>
<pre><code>immediate[ 31 : 12 ] rd 0010111
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>beq rs1, rs2, offset if (rs1 == rs2) pc += sext(offset)
相等时分支 <em>(Branch if Equal)</em>. B-type, RV32I and RV64I.
若寄存器x[ <em>rs1</em> ]和寄存器x[ <em>rs 2</em> ]的值相等，把 <em>pc</em> 的值设为当前值加上符号位扩展的偏移 <em>offset</em> 。
压缩形式： <strong>c.beqz</strong> rs1, offset</p>
<pre><code>offset[12|10:5] rs2 rs1 000 offset[4:1|11]^1100011
</code></pre>
<p>beqz rs1, offset if (rs1 == 0) pc += sext(offset)
等于零时分支 <em>(Branch if Equal to Zero)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
可视为 <strong>beq</strong> rs1, x0, offset.</p>
<p>bge rs1, rs2, offset if (rs1 ≥s rs2) pc += sext(offset)
大于等于时分支 <em>(Branch if Greater Than or Equal)</em>. B-type, RV32I and RV64I.
若寄存器x[ <em>rs1</em> ]的值大于等于寄存器x[ <em>rs 2</em> ]的值（均视为二进制补码），把 <em>pc</em> 的值设为当前
值加上符号位扩展的偏移 <em>offset</em> 。</p>
<pre><code>offset[12|10:5] rs2 rs1 101 offset[4:1|11] 1100011
</code></pre>
<p>bgeu rs1, rs2, offset if (rs1 ≥u rs2) pc += sext(offset)
无符号大于等于时分支 <em>(Branch if Greater Than or Equal, Unsigned)</em>. B-type, RV32I and RV64I.
若寄存器x[ <em>rs1</em> ]的值大于等于寄存器x[ <em>rs 2</em> ]的值（均视为无符号数），把 <em>pc</em> 的值设为当前值
加上符号位扩展的偏移 <em>offset</em> 。</p>
<pre><code>offset[12|10:5] rs2 rs1 111 offset[4:1|11]^1100011
</code></pre>
<p>bgez rs1, offset if (rs1 ≥s 0) pc += sext(offset)
大于等于零时分支 <em>(Branch if Greater Than or Equal to Zero)</em>. 伪指令(Pesudoinstruction),
RV32I and RV64I.
可视为 <strong>bge</strong> rs1, x0, offset.</p>
<p>bgt rs1, rs2, offset if (rs1 &gt;s rs2) pc += sext(offset)
大于时分支 <em>(Branch if Greater Than)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
可视为 <strong>blt</strong> rs 2 , rs1, offset.</p>
<p>bgtu rs1, rs2, offset if (rs1 &gt;u rs2) pc += sext(offset)
无符号大于时分支 <em>(Branch if Greater Than, Unsigned)</em>. 伪指令(Pesudoinstruction), RV32I and
RV64I.
可视为 <strong>bltu</strong> rs 2 , rs1, offset.</p>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>bgtz rs1, offset if (rs2 &gt;s 0) pc += sext(offset)
大于零时分支 <em>(Branch if Greater Than Zero)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
可视为 <strong>blt</strong> x0, rs2, offset.</p>
<p>ble rs1, rs2, offset if (rs1 ≤s rs2) pc += sext(offset)
小于等于时分支 <em>(Branch if Less Than or Equal)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
可视为 <strong>bge</strong> rs 2 , rs1, offset.</p>
<p>bleu rs1, rs2, offset if (rs1 ≤u rs2) pc += sext(offset)
小于等于时分支 <em>(Branch if Less Than or Equal, Unsigned)</em>. 伪指令(Pesudoinstruction), RV32I
and RV64I.
可视为 <strong>bgeu</strong> rs 2 , rs1, offset.</p>
<p>blez rs 2 , offset if (rs2 ≤s 0) pc += sext(offset)
小于等于零时分支 <em>(Branch if Less Than or Equal to Zero)</em>. 伪指令(Pesudoinstruction), RV32I
and RV64I.
可视为 <strong>bge</strong> x0, rs2, offset.</p>
<p>blt rs1, rs2, offset if (rs1 &lt;s rs2) pc += sext(offset)
小于时分支 <em>(Branch if Less Than)</em>. B-type, RV32I and RV64I.
若寄存器x[ <em>rs1</em> ]的值小于寄存器x[ <em>rs 2</em> ]的值（均视为二进制补码），把 <em>pc</em> 的值设为当前值加
上符号位扩展的偏移 <em>offset</em> 。</p>
<pre><code>offset[12|10:5] rs2 rs1 100 offset[4:1|11] 1100011
</code></pre>
<p>bltz rs 2 , offset if (rs1 &lt;s 0) pc += sext(offset)
小于零时分支 <em>(Branch if Less Than Zero)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
可视为 <strong>blt</strong> rs1, x0, offset.</p>
<p>bltu rs1, rs2, offset if (rs1 &lt;u rs2) pc += sext(offset)
无符号小于时分支 <em>(Branch if Less Than, Unsigned)</em>. B-type, RV32I and RV64I.
若寄存器x[ <em>rs1</em> ]的值小于寄存器x[ <em>rs 2</em> ]的值（均视为无符号数），把 <em>pc</em> 的值设为当前值加上
符号位扩展的偏移 <em>offset</em> 。</p>
<pre><code>offset[12|10:5] rs2 rs1 110 offset[4:1|11]^1100011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 5 4 2 1 0
</code></pre>
<p>bne rs1, rs2, offset if (rs1 ≠ rs2) pc += sext(offset)
不相等时分支 <em>(Branch if Not Equal)</em>. B-type, RV32I and RV64I.
若寄存器x[ <em>rs1</em> ]和寄存器x[ <em>rs 2</em> ]的值不相等，把 <em>pc</em> 的值设为当前值加上符号位扩展的偏移
<em>offset</em> 。
压缩形式： <strong>c.bnez</strong> rs1, offset</p>
<pre><code>offset[12|10:5] rs2 rs1 001 offset[4:1|11]^1100011
</code></pre>
<p>bnez rs1, offset if (rs1 ≠ 0) pc += sext(offset)
不等于零时分支 <em>(Branch if Not Equal to Zero)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
可视为 <strong>bne</strong> rs1, x0, offset.</p>
<p>c.add rd, rs2 x[rd] = x[rd] + x[rs2]
加 <em>(Add)</em>. RV32IC and RV64IC.
扩展形式为 <strong>add</strong> rd, rd, rs2. rd=x0或rs2=x0时非法。</p>
<pre><code>100 1 rd rs2 10
</code></pre>
<p>c.addi rd, imm x[rd] = x[rd] + sext(imm)
加立即数 <em>(Add Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>addi</strong> rd, rd, imm.</p>
<pre><code>000 imm[5] rd imm[4:0] 01
</code></pre>
<p>c.addi16sp imm x[2] = x[2] + sext(imm)
加 16 倍立即数到栈指针 <em>(Add Immediate, Scaled by 16, to Stack Pointer)</em>. RV32IC and RV64IC.
扩展形式为 <strong>addi</strong> x2, x2, imm. imm=0时非法。</p>
<pre><code>011 imm[^9 ]^00010 imm[4|^6 |8:7|5]^01
</code></pre>
<p>c.addi 4 spn rd’, uimm x[8+rd’] = x[2] + uimm
加 4 倍立即数到栈指针 <em>(Add Immediate, Scaled by 4 , to Stack Pointer, Nondestructive)</em>. RV32IC
and RV64IC.
扩展形式为 <strong>addi</strong> rd, x2, uimm, 其中rd=8+rd’. uimm=0时非法。</p>
<pre><code>000 uimm[5:4|9:6| 2 |3] rd’ 00
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 11 10 9 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 2 1 0
</code></pre>
<p>c.addiw rd, imm x[rd] = sext((x[rd] + sext(imm))[31:0])
加立即数字 <em>(Add Word Immediate)</em>. RV64IC.
扩展形式为 <strong>addiw</strong> rd, rd, imm. rd=x0时非法。</p>
<pre><code>001 imm[5] rd imm[4:0] 01
</code></pre>
<p>c.and rd’, rs 2 ’ x[8+rd’] = x[8+rd’] &amp; x[8+rs2’]
与 <em>(AND)</em>. RV32IC and RV64IC.
扩展形式为 <strong>and</strong> rd, rd, rs2, 其中rd=8+rd’, rs2=8+rs2’.</p>
<pre><code>100011 rd’ 11 rs2’ 01
</code></pre>
<p>c.addw rd’, rs 2 ’ x[8+rd’] = sext((x[8+rd’] + x[8+rs2’])[31:0])
加字 <em>(Add Word)</em>. RV64IC.
扩展形式为 <strong>addw</strong> rd, rd, rs2, 其中rd=8+rd’, rs2=8+rs2’.</p>
<pre><code>100111 rd’ 01 rs2’ 01
</code></pre>
<p>c.andi rd’, imm x[8+rd’] = x[8+rd’] &amp; sext(imm)
与立即数 <em>(AND Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>andi</strong> rd, rd, imm, 其中rd=8+rd’.</p>
<pre><code>100 imm[5] 10 rd’ imm[4:0] 01
</code></pre>
<p>c.beqz rs 1 ’, offset if (x[8+rs1’] == 0) pc += sext(offset)
等于零时分支 <em>(Branch if Equal to Zero)</em>. RV32IC and RV64IC.
扩展形式为 <strong>beq</strong> rs1, x0, offset, 其中rs1=8+rs1’.</p>
<pre><code>110 offset[8|4:3] rs1’ offset[7:6|2:1|5] 01
</code></pre>
<p>c.bnez rs 1 ’, offset if (x[8+rs1’] ≠ 0) pc += sext(offset)
不等于零时分支 <em>(Branch if Not Equal to Zero)</em>. RV32IC and RV64IC.
扩展形式为 <strong>bne</strong> rs1, x0, offset, 其中rs1=8+rs1’.</p>
<pre><code>111 offset[8|4:3]^ rs1’ offset[7:6|2:1|5]^01
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<p>c.ebreak RaiseException(Breakpoint)
环境断点 <em>(Environment Breakpoint)</em>. RV32IC and RV64IC.
扩展形式为 <strong>ebreak</strong>.</p>
<pre><code>100 1 00000 00000 10
</code></pre>
<p>c.fld rd’, uimm(rs 1 ’) f[8+rd’] = M[x[8+rs1’] + uimm][63:0]
浮点双字加载 <em>(Floating-point Load Doubleword)</em>. RV32DC and RV64DC.
扩展形式为 <strong>fld</strong> rd, uimm(rs1), 其中rd=8+rd’, rs1=8+rs1’.</p>
<pre><code>001 uimm[5:3] rs1’ uimm[7:6] rd’ 00
</code></pre>
<p>c.fldsp rd, uimm(x2) f[rd] = M[x[2] + uimm][63:0]
栈指针相关浮点双字加载 <em>(Floating-point Load Doubleword, Stack-Pointer Relative)</em>. RV32DC
and RV64DC.
扩展形式为 <strong>fld</strong> rd, uimm(x2).</p>
<pre><code>001 uimm[5] rd uimm[4:3|8:6] 10
</code></pre>
<p>c.flw rd’, uimm(rs 1 ’) f[8+rd’] = M[x[8+rs1’] + uimm][31:0]
浮点字加载 <em>(Floating-point Load Word)</em>. RV32FC.
扩展形式为 <strong>flw</strong> rd, uimm(rs1), 其中rd=8+rd’, rs1=8+rs1’.</p>
<pre><code>011 uimm[5:3] rs1’ uimm[2|6] rd’ 00
</code></pre>
<p>c.flwsp rd, uimm(x2) f[rd] = M[x[2] + uimm][31:0]
栈指针相关浮点字加载 <em>(Floating-point Load Word, Stack-Pointer Relative)</em>. RV32FC.
扩展形式为 <strong>flw</strong> rd, uimm(x2).</p>
<pre><code>011 uimm[5] rd uimm[4:2|7:6] 10
</code></pre>
<p>c.fsd rs 2 ’, uimm(rs 1 ’) M[x[8+rs1’] + uimm][63:0] = f[8+rs2’]
浮点双字存储 <em>(Floating-point Store Doubleword)</em>. RV32DC and RV64DC.
扩展形式为 <strong>fsd</strong> rs2, uimm(rs1), 其中rs2=8+rs2’, rs1=8+rs1’.</p>
<pre><code>101 uimm[5:3] rs1’ uimm[7:6]^ rs2’^00
</code></pre>
<pre><code>15 13 12 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 2 1 0
</code></pre>
<pre><code>15 13 12 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<p>c.fsdsp rs2, uimm(x2) M[x[2] + uimm][63:0] = f[rs2]
栈指针相关浮点双字存储 <em>(Floating-point Store Doubleword, Stack-Pointer Relative)</em>. RV32DC
and RV64DC.
扩展形式为 <strong>fsd</strong> rs2, uimm(x2).</p>
<pre><code>101 uimm[5:3|8:6] rs2 10
</code></pre>
<p>c.fsw rs 2 ’, uimm(rs 1 ’) M[x[8+rs1’] + uimm][31:0] = f[8+rs2’]
浮点字存储 <em>(Floating-point Store Word)</em>. RV32FC.
扩展形式为 <strong>fsw</strong> rs2, uimm(rs1), 其中rs2=8+rs2’, rs1=8+rs1’.</p>
<pre><code>111 uimm[5:3] rs1’ uimm[2|6] rs2’ 00
</code></pre>
<p>c.fswsp rs2, uimm(x2) M[x[2] + uimm][31:0] = f[rs2]
栈指针相关浮点字存储 <em>(Floating-point Store Word, Stack-Pointer Relative)</em>. RV32FC.
扩展形式为 <strong>fsw</strong> rs2, uimm(x2).</p>
<pre><code>111 uimm[5: 2 | 7 :6] rs2 10
</code></pre>
<p>c.j offset pc += sext(offset)
跳转 <em>(Jump)</em>. RV32IC and RV64IC.
扩展形式为 <strong>jal</strong> x0, offset.</p>
<pre><code>101 offset[11|4|9:8|10|6|7|3:1|5] 01
</code></pre>
<p>c.jal offset x[1] = pc+2; pc += sext(offset)
链接跳转 <em>(Jump and Link)</em>. RV32IC.
扩展形式为 <strong>jal</strong> x1, offset.</p>
<pre><code>001 offset[11|4|9:8|10|6|7|3:1|5] 01
</code></pre>
<p>c.jalr rs1 t = pc+2; pc = x[rs1]; x[1] = t
寄存器链接跳转 <em>(Jump and Link Register)</em>. RV32IC and RV64IC.
扩展形式为 <strong>jalr</strong> x1, 0(rs1). 当rs1=x0时非法。</p>
<pre><code>100 1 rs1 00000 10
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<p>c.jr rs1 pc = x[rs1]
寄存器跳转 <em>(Jump Register)</em>. RV32IC and RV64IC.
扩展形式为 <strong>jalr</strong> x 0 , 0(rs1). 当rs1=x0时非法。</p>
<pre><code>100 0 rs1 00000 10
</code></pre>
<p>c.ld rd’, uimm(rs 1 ’) x[8+rd’] = M[x[8+rs1’] + uimm][63:0]
双字加载 <em>(Load Doubleword)</em>. RV64IC.
扩展形式为 <strong>ld</strong> rd, uimm(rs1), 其中rd=8+rd’, rs1=8+rs1’.</p>
<pre><code>011 uimm[5:3] rs1’ uimm[7:6] rd’ 00
</code></pre>
<p>c.ldsp rd, uimm(x2) x[rd] = M[x[2] + uimm][63:0]
栈指针相关双字加载 <em>(Load Doubleword, Stack-Pointer Relative)</em>. RV64IC.
扩展形式为 <strong>ld</strong> rd, uimm(x2). rd=x0时非法。</p>
<pre><code>011 uimm[5] rd uimm[4:3|8:6] 10
</code></pre>
<p>c.li rd, imm x[rd] = sext(imm)
立即数加载 <em>(Load Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>addi</strong> rd, x0, imm.</p>
<pre><code>010 imm[5] rd imm[4:0] 01
</code></pre>
<p>c.lui rd, imm x[rd] = sext(imm[17:12] &lt;&lt; 12)
高位立即数加载 <em>(Load Upper Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>lui</strong> rd, imm. 当rd=x2或imm=0时非法。</p>
<pre><code>011 imm[ 17 ] rd imm[ 16 : 12 ] 01
</code></pre>
<p>c.lw rd’, uimm(rs 1 ’) x[8+rd’] = sext(M[x[8+rs1’] + uimm][31:0])
字加载 <em>(Load Word)</em>. RV32IC and RV64IC.
扩展形式为 <strong>lw</strong> rd, uimm(rs1), 其中rd=8+rd’, rs1=8+rs1’.</p>
<pre><code>010 uimm[5:3] rs1’ uimm[2|6]^ rd’^00
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<pre><code>15 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 7 6 2 1 0
</code></pre>
<p>c.lwsp rd, uimm(x2) x[rd] = sext(M[x[2] + uimm][31:0])
栈指针相关字加载 <em>(Load Word, Stack-Pointer Relative)</em>. RV32IC and RV64IC.
扩展形式为 <strong>lw</strong> rd, uimm(x2). rd=x0时非法。</p>
<pre><code>010 uimm[5] rd uimm[4:2|7:6] 10
</code></pre>
<p>c.mv rd, rs2 x[rd] = x[rs2]
移动 <em>(Move)</em>. RV32IC and RV64IC.
扩展形式为 <strong>add</strong> rd, x0, rs2. rs2=x0时非法。</p>
<pre><code>100 0 rd rs2 10
</code></pre>
<p>c.or rd’, rs 2 ’ x[8+rd’] = x[8+rd’] | x[8+rs2’]
或 <em>(OR)</em>. RV32IC and RV64IC.
扩展形式为 <strong>or</strong> rd, rd, rs2, 其中rd=8+rd’, rs2=8+rs2’.</p>
<pre><code>100011 rd’ 10 rs2’ 01
</code></pre>
<p>c.sd rs 2 ’, uimm(rs 1 ’) M[x[8+rs1’] + uimm][63:0] = x[8+rs2’]
双字存储 <em>(Store Doubleword)</em>. RV64IC.
扩展形式为 <strong>sd</strong> rs2, uimm(rs1), 其中rs2=8+rs2’, rs1=8+rs1’.</p>
<pre><code>111 uimm[5:3] rs1’ uimm[7:6] rs2’ 00
</code></pre>
<p>c.sdsp rs2, uimm(x2) M[x[2] + uimm][63:0] = x[rs2]
栈指针相关双字存储 <em>(Store Doubleword, Stack-Pointer Relative)</em>. RV64IC.
扩展形式为 <strong>sd</strong> rs2, uimm(x2).</p>
<pre><code>111 uimm[5:3|8:6] rs2 10
</code></pre>
<p>c.slli rd, uimm x[rd] = x[rd] &lt;&lt; uimm
立即数逻辑左移 <em>(Shift Left Logical Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>slli</strong> rd, rd, uimm.</p>
<pre><code>000 uimm[5]^ rd uimm[4:0] 10
</code></pre>
<pre><code>15 13 12 11 10 9 7 6 2 1 0
</code></pre>
<pre><code>15 13 12 11 10 9 7 6 2 1 0
</code></pre>
<pre><code>15 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>15 13 12 7 6 2 1 0
</code></pre>
<p>c.srai rd’, uimm x[8+rd’] = x[8+rd’] &gt;&gt;s uimm
立即数算术右移 <em>(Shift Right Arithmetic Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>srai</strong> rd, rd, uimm, 其中rd=8+rd’.</p>
<pre><code>100 uimm[5] 01 rd’ uimm[4:0] 01
</code></pre>
<p>c.srli rd’, uimm x[8+rd’] = x[8+rd’] &gt;&gt;u uimm
立即数逻辑右移 <em>(Shift Right Logical Immediate)</em>. RV32IC and RV64IC.
扩展形式为 <strong>srli</strong> rd, rd, uimm, 其中rd=8+rd’.</p>
<pre><code>100 uimm[5] 00 rd’ uimm[4:0] 01
</code></pre>
<p>c.sub rd’, rs 2 ’ x[8+rd’] = x[8+rd’] - x[8+rs2’]
减 <em>(Subtract)</em>. RV32IC and RV64IC.
扩展形式为 <strong>sub</strong> rd, rd, rs2. 其中rd=8+rd’, rs2=8+rs2’..</p>
<pre><code>100011 rd’ 00 rs2’ 01
</code></pre>
<p>c.subw rd’, rs 2 ’ x[8+rd’] = sext((x[8+rd’] - x[8+rs2’])[31:0])
减字 <em>(Subtract Word)</em>. RV64IC.
扩展形式为 <strong>subw</strong> rd, rd, rs2. 其中rd=8+rd’, rs2=8+rs2’..</p>
<pre><code>100111 rd’ 00 rs2’ 01
</code></pre>
<p>c.sw rs 2 ’, uimm(rs 1 ’) M[x[8+rs1’] + uimm][31:0] = x[8+rs2’]
字存储 <em>(Store Word)</em>. RV32IC and RV64IC.
扩展形式为 <strong>sw</strong> rs2, uimm(rs1), 其中rs2=8+rs2’, rs1=8+rs1’.</p>
<pre><code>110 uimm[5:3] rs1’ uimm[2|6] rs2’ 00
</code></pre>
<p>c.swsp rs2, uimm(x2) M[x[2] + uimm][31:0] = x[rs2]
栈指针相关字存储 <em>(Store Word, Stack-Pointer Relative)</em>. RV32IC and RV64IC.
扩展形式为 <strong>sw</strong> rs2, uimm(x2).</p>
<pre><code>110 uimm[5: 2 | 7 :6] rs2 10
</code></pre>
<pre><code>15 10 9 7 6 5 4 2 1 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>c.xor rd’, rs 2 ’ x[8+rd’] = x[8+rd’] ^ x[8+rs2’]
异或 <em>(Exclusive-OR)</em>. RV32IC and RV64IC.
扩展形式为 <strong>xor</strong> rd, rd, rs2, 其中rd=8+rd’, rs2=8+rs2’.</p>
<pre><code>100011 rd’ 01 rs2’ 01
</code></pre>
<p>call rd, symbol x[rd] = pc+8; pc = &amp;symbol
调用 <em>(Call)</em>. 伪指令(Pesudoinstruction), RV32I and RV64I.
把下一条指令的地址（ <em>pc</em> +8）写入x[ <em>rd</em> ]，然后把 <em>pc</em> 设为 <em>symbol</em> 。等同于 <strong>auipc</strong> rd, offestHi,
再加上一条 <strong>jalr</strong> rd, offsetLo(rd). 若省略了 <em>rd</em> ，默认为x1.</p>
<p>csrr rd, csr x[rd] = CSRs[csr]
读控制状态寄存器 <em>(Control and Status Register Read)</em>. 伪指令(Pesudoinstruction), RV32I and
RV64I.
把控制状态寄存器 <em>csr</em> 的值写入x[ <em>rd</em> ]，等同于 <strong>csrrs</strong> rd, csr, x0.</p>
<p>csrc csr, rs1 CSRs[csr] &amp;= ~x[rs1]
清除控制状态寄存器 <em>(Control and Status Register Clear)</em>. 伪指令(Pesudoinstruction), RV32I
and RV64I.
对于x[ <em>rs1</em> ]中每一个为 1 的位，把控制状态寄存器 <em>csr</em> 的的对应位清零，等同于 <strong>csrrc</strong> x0, csr,
rs1.</p>
<p>csrci csr, zimm[4:0] CSRs[csr] &amp;= ~zimm
立即数清除控制状态寄存器 <em>(Control and Status Register Clear Immediate)</em>. 伪指令
(Pesudoinstruction), RV32I and RV64I.
对于五位的零扩展的立即数中每一个为 1 的位，把控制状态寄存器 <em>csr</em> 的的对应位清零，等
同于 <strong>csrrci</strong> x0, csr, zimm.</p>
<p>csrrc rd, csr, rs1 t = CSRs[csr]; CSRs[csr] = t &amp;~x[rs1]; x[rd] = t
读后清除控制状态寄存器 <em>(Control and Status Register Read and Clear)</em>. I-type, RV32I and
RV64I.
记控制状态寄存器 <em>csr</em> 中的值为 <em>t</em> 。把 <em>t</em> 和寄存器x[ <em>rs1</em> ]按位与的结果写入 <em>csr</em> ，再把 <em>t</em> 写入
x[ <em>rd</em> ]。</p>
<pre><code>csr rs1 011 rd 1110011
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>csrrci rd, csr, zimm[4:0] t = CSRs[csr]; CSRs[csr] = t &amp;~zimm; x[rd] = t
立即数读后清除控制状态寄存器 <em>(Control and Status Register Read and Clear Immediate)</em>. I-
type, RV32I and RV64I.
记控制状态寄存器 <em>csr</em> 中的值为 <em>t</em> 。把 <em>t</em> 和五位的零扩展的立即数 <em>zimm</em> 按位与的结果写入
<em>csr</em> ，再把 <em>t</em> 写入x[ <em>rd</em> ]（ <em>csr</em> 寄存器的第 5 位及更高位不变）。</p>
<pre><code>csr zimm[4:0] 111 rd 1110011
</code></pre>
<p>csrrs rd, csr, rs1 t = CSRs[csr]; CSRs[csr] = t | x[rs1]; x[rd] = t
读后置位控制状态寄存器 <em>(Control and Status Register Read and Set)</em>. I-type, RV32I and RV64I.
记控制状态寄存器 <em>csr</em> 中的值为 <em>t</em> 。把 <em>t</em> 和寄存器x[ <em>rs1</em> ]按位或的结果写入 <em>csr</em> ，再把 <em>t</em> 写入
x[ <em>rd</em> ]。</p>
<pre><code>csr rs1 010 rd 1110011
</code></pre>
<p>csrrci rd, csr, zimm[4:0] t = CSRs[csr]; CSRs[csr] = t | zimm; x[rd] = t
立即数读后设置控制状态寄存器 <em>(Control and Status Register Read and Set Immediate)</em>. I-type,
RV32I and RV64I.
记控制状态寄存器 <em>csr</em> 中的值为 <em>t</em> 。把 <em>t</em> 和五位的零扩展的立即数 <em>zimm</em> 按位或的结果写入
<em>csr</em> ，再把 <em>t</em> 写入x[ <em>rd</em> ]（ <em>csr</em> 寄存器的第 5 位及更高位不变）。</p>
<pre><code>csr zimm[4:0] 110 rd 1110011
</code></pre>
<p>csrrw rd, csr, zimm[4:0] t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t
读后写控制状态寄存器 <em>(Control and Status Register Read and Write)</em>. I-type, RV32I and RV64I.
记控制状态寄存器 <em>csr</em> 中的值为 <em>t</em> 。把寄存器x[ <em>rs1</em> ]的值写入 <em>csr</em> ，再把 <em>t</em> 写入x[ <em>rd</em> ]。</p>
<pre><code>csr rs1 001 rd 1110011
</code></pre>
<p>csrrwi rd, csr, zimm[4:0] x[rd] = CSRs[csr]; CSRs[csr] = zimm
立即数读后写控制状态寄存器 <em>(Control and Status Register Read and Write Immediate)</em>. I-type,
RV32I and RV64I.
把控制状态寄存器 <em>csr</em> 中的值拷贝到x[ <em>rd</em> ]中，再把五位的零扩展的立即数 <em>zimm</em> 的值写入
<em>csr</em> 。</p>
<pre><code>csr zimm[4:0] 101 rd 1110011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>csrc csr, rs1 CSRs[csr] |= x[rs1]
置位控制状态寄存器 <em>(Control and Status Register Set)</em>. 伪指令(Pesudoinstruction), RV32I and
RV64I.
对于x[ <em>rs1</em> ]中每一个为 1 的位，把控制状态寄存器 <em>csr</em> 的的对应位置位，等同于 <strong>csrrs</strong> x0, csr,
rs1.</p>
<p>csrci csr, zimm[4:0] CSRs[csr] |= zimm
立即数置位控制状态寄存器 <em>(Control and Status Register Set Immediate)</em>. 伪指令
(Pesudoinstruction), RV32I and RV64I.
对于五位的零扩展的立即数中每一个为 1 的位，把控制状态寄存器 <em>csr</em> 的的对应位清零，等
同于 <strong>csrrsi</strong> x0, csr, zimm.</p>
<p>csrw csr, rs1 CSRs[csr] = x[rs1]
写控制状态寄存器 <em>(Control and Status Register Set)</em>. 伪指令(Pesudoinstruction), RV32I and
RV64I.
对于x[ <em>rs1</em> ]中每一个为 1 的位，把控制状态寄存器 <em>csr</em> 的的对应位置位，等同于 <strong>csrrs</strong> x0, csr,
rs1.</p>
<p>csrwi csr, zimm[4:0] CSRs[csr] = zimm
立即数写控制状态寄存器 <em>(Control and Status Register Write Immediate)</em>. 伪指令
(Pesudoinstruction), RV32I and RV64I.
把五位的零扩展的立即数的值写入控制状态寄存器 <em>csr</em> 的，等同于 <strong>csrrwi</strong> x0, csr, zimm.</p>
<p>div rd, rs1, rs2 x[rd] = x[rs1] ÷s x[rs2]
除法 <em>(Divide)</em>. R-type, RV32M and RV64M.
用寄存器x[ <em>rs 1</em> ]的值除以寄存器x[ <em>rs 2</em> ]的值，向零舍入，将这些数视为二进制补码，把商写
入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 100 rd 0110011
</code></pre>
<p>divu rd, rs1, rs2 x[rd] = x[rs1] ÷u x[rs2]
无符号除法 <em>(Divide, Unsigned)</em>. R-type, RV32M and RV64M.
用寄存器x[ <em>rs 1</em> ]的值除以寄存器x[ <em>rs 2</em> ]的值，向零舍入，将这些数视为无符号数，把商写入
x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 101 rd 0110011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>divuw rd, rs1, rs2 x[rd] = sext(x[rs1][31:0] ÷u x[rs2][31:0])
无符号字除法 <em>(Divide Word, Unsigned)</em>. R-type, RV64M.
用寄存器x[ <em>rs 1</em> ]的低 32 位除以寄存器x[ <em>rs 2</em> ]的低 32 位，向零舍入，将这些数视为无符号数，
把经符号位扩展的 32 位商写入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 101 rd 0111011
</code></pre>
<p>divw rd, rs1, rs2 x[rd] = sext(x[rs1][31:0] ÷s x[rs2][31:0])
字除法 <em>(Divide Word)</em>. R-type, RV64M.
用寄存器x[ <em>rs 1</em> ]的低 32 位除以寄存器x[ <em>rs 2</em> ]的低 32 位，向零舍入，将这些数视为二进制补
码，把经符号位扩展的 32 位商写入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 100 rd 0111011
</code></pre>
<p>Ebreak RaiseException(Breakpoint)
环境断点 <em>(Environment Breakpoint)</em>. I-type, RV32I and RV64I.
通过抛出断点异常的方式请求调试器。</p>
<pre><code>000000000001 00000 000 00000 1110011
</code></pre>
<p>ecall RaiseException(EnvironmentCall)
环境调用 <em>(Environment Call)</em>. I-type, RV32I and RV64I.
通过引发环境调用异常来请求执行环境。</p>
<pre><code>000000000000 00000 000 00000 1110011
</code></pre>
<p>fabs.d rd, rs1 f[rd] = |f[rs1]|
浮点数绝对值 <em>(Floating-point Absolute Value)</em>. 伪指令(Pesudoinstruction), RV32D and RV64D.
把双精度浮点数f[ <em>rs1</em> ]的绝对值写入f[ <em>rd</em> ]。
等同于 <strong>fsgnjx.d</strong> rd, rs1, rs1.</p>
<p>fabs.s rd, rs1 f[rd] = |f[rs1]|
浮点数绝对值 <em>(Floating-point Absolute Value)</em>. 伪指令(Pesudoinstruction), RV32F and RV64F.
把单精度浮点数f[ <em>rs1</em> ]的绝对值写入f[ <em>rd</em> ]。
等同于 <strong>fsgnjx.s</strong> rd, rs1, rs1.</p>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fadd.d rd, rs1, rs2 f [rd] = f [rs1] + f [rs2]
双精度浮点加 <em>(Floating-point Add, Double-Precision)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相加，并将舍入后的和写入f[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 rm rd 1010011
</code></pre>
<p>fadd.s rd, rs1, rs2 f [rd] = f [rs1] + f [rs2]
单精度浮点加 <em>(Floating-point Add, Single-Precision)</em>. R-type, RV 32 F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相加，并将舍入后的和写入f[ <em>rd</em> ]。</p>
<pre><code>0000000 rs2 rs1 rm rd 1010011
</code></pre>
<p>fclass.d rd, rs1, rs2 x[rd] = classify <em>d</em> (f[rs1])
双精度浮点分类 <em>(Floating-point Classify, Double-Precision)</em>. R-type, RV32D and RV64D.
把一个表示寄存器f[ <em>rs 1</em> ]中双精度浮点数类别的掩码写入x[ <em>rd</em> ]中。关于如何解释写入x[ <em>rd</em> ]
的值，请参阅指令 <strong>fclass.s</strong> 的介绍。</p>
<pre><code>1110001 00000 rs1 001 rd 1010011
</code></pre>
<p>fclass.s rd, rs1, rs2 x[rd] = classify <em>s</em> (f[rs1])
单精度浮点分类 <em>(Floating-point Classify, Single-Precision)</em>. R-type, RV32F and RV64F.
把一个表示寄存器f[ <em>rs 1</em> ]中单精度浮点数类别的掩码写入x[ <em>rd</em> ]中。x[ <em>rd</em> ]中有且仅有一位被置
上，见下表。
x <em>[rd]</em> 位 含义
0 f [ <em>rs1</em> ]为−∞。
1 f [ <em>rs1</em> ]是负规格化数。
2 f [ <em>rs1</em> ]是负的非规格化数。
3 f [ <em>rs1</em> ]是- 0 。
4 f [ <em>rs1</em> ]是+0。
5 f [ <em>rs1</em> ]是正的非规格化数。
6 f [ <em>rs1</em> ]是正的规格化数。
7 f [ <em>rs1</em> ]为+∞。
8 f [ <em>rs1</em> ]是信号(signaling)NaN。
9 f [ <em>rs1</em> ]是一个安静(quiet)NaN。</p>
<pre><code>1110000 00000 rs1 001 rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fcvt.d.l rd, rs1, rs2 f[rd] = f64 <em>s</em> 64 (x[rs1])
长整型向双精度浮点转换 <em>(Floating-point Convert to Double from Long)</em>. R-type, RV64D.
把寄存器x[ <em>rs 1</em> ]中的 64 位二进制补码表示的整数转化为双精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101001 00010 rs1 rm rd 1010011
</code></pre>
<p>fcvt.d.lu rd, rs1, rs2 f[rd] = f64 <em>u</em> 64 (x[rs1])
无符号长整型向双精度浮点转换 <em>(Floating-point Convert to Double from Unsigned Long)</em>. R-
type, RV64D.
把寄存器x[ <em>rs 1</em> ]中的 64 位无符号整数转化为双精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101001 00011 rs1 rm rd 1010011
</code></pre>
<p>fcvt.d.s rd, rs1, rs2 f[rd] = f64 <em>f</em> 32 (f[rs1])
单精度向双精度浮点转换 <em>(Floating-point Convert to Double from Single)</em>. R-type, RV32D and
RV64D.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数转化为双精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>0100001 00000 rs1 rm rd 1010011
</code></pre>
<p>fcvt.d.w rd, rs1, rs2 f[rd] = f64 <em>s</em> 32 (x[rs1])
字向双精度浮点转换 <em>(Floating-point Convert to Double from Word)</em>. R-type, RV32D and RV64D.
把寄存器x[ <em>rs 1</em> ]中的 32 位二进制补码表示的整数转化为双精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101001 00000 rs1 rm rd 1010011
</code></pre>
<p>fcvt.d.wu rd, rs1, rs2 f[rd] = f64 <em>u</em> 32 (x[rs1])
无符号字向双精度浮点转换 <em>(Floating-point Convert to Double from Unsigned Word)</em>. R-type,
RV32D and RV64D.
把寄存器x[ <em>rs 1</em> ]中的 32 位无符号整数转化为双精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101001 00001 rs1 rm rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fcvt.l.d rd, rs1, rs2 x[rd] = s64 <em>f</em> 64 (f[rs1])
双精度浮点向长整型转换 <em>(Floating-point Convert to Long from Double)</em>. R-type, RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数转化为 64 位二进制补码表示的整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100001 00010 rs1 rm rd 1010011
</code></pre>
<p>fcvt.l.s rd, rs1, rs2 x[rd] = s64 <em>f</em> 32 (f[rs1])
单精度浮点向长整型转换 <em>(Floating-point Convert to Long from Single)</em>. R-type, RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数转化为 64 位二进制补码表示的整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100000 00010 rs1 rm rd 1010011
</code></pre>
<p>fcvt.lu.d rd, rs1, rs2 x[rd] = u64 <em>f</em> 64 (f[rs1])
双精度浮点向无符号长整型转换 <em>(Floating-point Convert to Unsigned Long from Double)</em>. R-
type, RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数转化为 64 位无符号整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100001 00011 rs1 rm rd 1010011
</code></pre>
<p>fcvt.lu.s rd, rs1, rs2 x[rd] = u64 <em>f</em> 32 (f[rs1])
单精度浮点向无符号长整型转换 <em>(Floating-point Convert to Unsigned Long from Single)</em>. R-type,
RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数转化为 64 位二进制补码表示的整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100000 00011 rs1 rm rd 1010011
</code></pre>
<p>fcvt.s.d rd, rs1, rs2 f[rd] = f32 <em>f</em> 64 (f[rs1])
双精度向单精度浮点转换 <em>(Floating-point Convert to Single from Double)</em>. R-type, RV32D and
RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数转化为单精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>0100000 00001 rs1 rm rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fcvt.s.l rd, rs1, rs2 f[rd] = f32 <em>s</em> 64 (x[rs1])
长整型向单精度浮点转换 <em>(Floating-point Convert to Single from Long)</em>. R-type, RV64F.
把寄存器x[ <em>rs 1</em> ]中的 64 位二进制补码表示的整数转化为单精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101000 00010 rs1 rm rd 1010011
</code></pre>
<p>fcvt.s.lu rd, rs1, rs2 f[rd] = f32 <em>u</em> 64 (x[rs1])
无符号长整型向单精度浮点转换 <em>(Floating-point Convert to Single from Unsigned Long)</em>. R-type,
RV64F.
把寄存器x[ <em>rs 1</em> ]中的 64 位的无符号整数转化为单精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101000 00011 rs1 rm rd 1010011
</code></pre>
<p>fcvt.s.w rd, rs1, rs2 f[rd] = f32 <em>s</em> 32 (x[rs1])
字向单精度浮点转换 <em>(Floating-point Convert to Single from Word)</em>. R-type, RV32F and RV64F.
把寄存器x[ <em>rs 1</em> ]中的 32 位二进制补码表示的整数转化为单精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101000 00000 rs1 rm rd 1010011
</code></pre>
<p>fcvt.s.wu rd, rs1, rs2 f[rd] = f32 <em>u</em> 32 (x[rs1])
无符号字向单精度浮点转换 <em>(Floating-point Convert to Single from Unsigned Word)</em>. R-type,
RV32F and RV64F.
把寄存器x[ <em>rs 1</em> ]中的 32 位无符号整数转化为单精度浮点数，再写入f[ <em>rd</em> ]中。</p>
<pre><code>1101000 00001 rs1 rm rd 1010011
</code></pre>
<p>fcvt.w.d rd, rs1, rs2 x[rd] = sext(s32 <em>f</em> 64 (f[rs1]))
双精度浮点向字转换 <em>(Floating-point Convert to Word from Double)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数转化为 32 位二进制补码表示的整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100001 00000 rs1 rm rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fcvt.wu.d rd, rs1, rs2 x[rd] = sext(u32 <em>f</em> 64 (f[rs1]))
双精度浮点向无符号字转换 <em>(Floating-point Convert to Unsigned Word from Double)</em>. R-type,
RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数转化为 32 位无符号整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100001 00001 rs1 rm rd 1010011
</code></pre>
<p>fcvt.w.s rd, rs1, rs2 x[rd] = sext(s32 <em>f</em> 32 (f[rs1]))
单精度浮点向字转换 <em>(Floating-point Convert to Word from Single)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数转化为 32 位二进制补码表示的整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100000 00000 rs1 rm rd 1010011
</code></pre>
<p>fcvt.wu.s rd, rs1, rs2 x[rd] = sext(u32 <em>f</em> 32 (f[rs1]))
单精度浮点向无符号字转换 <em>(Floating-point Convert to Unsigned Word from Single)</em>. R-type,
RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数转化为 32 位无符号整数，再写入x[ <em>rd</em> ]中。</p>
<pre><code>1100000 00001 rs1 rm rd 1010011
</code></pre>
<p>fdiv.d rd, rs1, rs2 f[rd] = f[rs1] ÷ f[rs2]
双精度浮点除法 <em>(Floating-point Divide, Double-Precision)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相除，并将舍入后的商写入f[ <em>rd</em> ]。</p>
<pre><code>0001101 rs2 rs1 rm rd 1010011
</code></pre>
<p>fdiv.s rd, rs1, rs2 f[rd] = f[rs1] ÷ f[rs2]
单精度浮点除法 <em>(Floating-point Divide, Single-Precision)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相除，并将舍入后的商写入f[ <em>rd</em> ]。</p>
<pre><code>0001100 rs2 rs1 rm rd 1010011
</code></pre>
<pre><code>31 28 27 24 23 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fence pred, succ Fence(pred, succ)
同步内存和I/O <em>(Fence Memory and I/O)</em>. I-type, RV32I and RV64I.
在后续指令中的内存和I/O访问对外部（例如其他线程）可见之前，使这条指令之前的内存
及I/O访问对外部可见。比特中的第3,2,1和 0 位分别对应于设备输入，设备输出，内存读
写。例如 <strong>fence</strong> r, rw，将前面读取与后面的读取和写入排序，使用 <em>pred</em> = 0010和 <em>succ</em> = 0011
进行编码。如果省略了参数，则表示 <strong>fence</strong> iorw, iorw，即对所有访存请求进行排序。</p>
<pre><code>0000 pred succ 00000 000 00000 0001111
</code></pre>
<p>fence.i Fence(Store, Fetch)
同步指令流 <em>(Fence Instruction Stream)</em>. I-type, RV32I and RV64I.
使对内存指令区域的读写，对后续取指令可见。</p>
<pre><code>000000000000 00000 001 00000 0001111
</code></pre>
<p>feq.d rd, rs1, rs2 x[rd] = f[rs1] == f[rs2]
双精度浮点相等 <em>(Floating-point Equals, Double-Precision)</em>. R-type, RV32D and RV64D.
若寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相等，则在x[ <em>rd</em> ]中写入 1 ，反之写 0 。</p>
<pre><code>1010001 rs2 rs1 010 rd 1010011
</code></pre>
<p>feq.s rd, rs1, rs2 x[rd] = f[rs1] == f[rs2]
单精度浮点相等 <em>(Floating-point Equals, Single-Precision)</em>. R-type, RV32F and RV64F.
若寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相等，则在x[ <em>rd</em> ]中写入 1 ，反之写 0 。</p>
<pre><code>1010000 rs2 rs1 010 rd 1010011
</code></pre>
<p>fld rd, offset(rs1) f[rd] = M[x[rs1] + sext(offset)][63:0]
浮点加载双字 <em>(Floating-point Load Doubleword)</em>. I-type, RV32D and RV64D.
从内存地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )中取双精度浮点数，并写入f[ <em>rd</em> ]。
压缩形式： <strong>c.fldsp</strong> rd, offset; <strong>c.fld</strong> rd, offset(rs1)</p>
<pre><code>offset[11:0] rs1 011 rd 0000111
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fle.d rd, rs1, rs2 x[rd] = f[rs1] ≤ f[rs2]
双精度浮点小于等于 <em>(Floating-point Less Than or Equal, Double-Precision)</em>. R-type, RV32D and
RV64D.
若寄存器f[ <em>rs 1</em> ]中的双精度浮点数小于等于f[ <em>rs 2</em> ]中的双精度浮点数，则在x[ <em>rd</em> ]中写入 1 ，反
之写 0 。</p>
<pre><code>1010001 rs2 rs1 000 rd 1010011
</code></pre>
<p>fle.s rd, rs1, rs2 x[rd] = f[rs1] ≤ f[rs2]
单精度浮点小于等于 <em>(Floating-point Less Than or Equal, Single-Precision)</em>. R-type, RV32F and
RV64F.
若寄存器f[ <em>rs 1</em> ]中的单精度浮点数小于等于f[ <em>rs 2</em> ]中的单精度浮点数，则在x[ <em>rd</em> ]中写入 1 ，反
之写 0 。</p>
<pre><code>1010000 rs2 rs1 000 rd 1010011
</code></pre>
<p>fle.d rd, rs1, rs2 x[rd] = f[rs1] &lt; f[rs2]
双精度浮点小于 <em>(Floating-point Less Than, Double-Precision)</em>. R-type, RV32D and RV64D.
若寄存器f[ <em>rs 1</em> ]中的双精度浮点数小于f[ <em>rs 2</em> ]中的双精度浮点数，则在x[ <em>rd</em> ]中写入 1 ，反之写
0 。</p>
<pre><code>1010001 rs2 rs1 001 rd 1010011
</code></pre>
<p>fle.s rd, rs1, rs2 x[rd] = f[rs1] &lt; f[rs2]
单精度浮点小于 <em>(Floating-point Less Than, Single-Precision)</em>. R-type, RV32F and RV64F.
若寄存器f[ <em>rs 1</em> ]中的单精度浮点数小于f[ <em>rs 2</em> ]中的单精度浮点数，则在x[ <em>rd</em> ]中写入 1 ，反之写
0 。</p>
<pre><code>1010000 rs2 rs1 001 rd 1010011
</code></pre>
<p>flw rd, offset(rs1) f[rd] = M[x[rs1] + sext(offset)][31:0]
浮点加载字 <em>(Floating-point Load Word)</em>. I-type, RV32F and RV64F.
从内存地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )中取单精度浮点数，并写入f[ <em>rd</em> ]。
压缩形式： <strong>c.flwsp</strong> rd, offset; <strong>c.flw</strong> rd, offset(rs1)</p>
<pre><code>offset[11:0] rs1 010 rd 0000111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fmadd.d rd, rs1, rs2, rs3 f[rd] = f[rs1]×f[rs2]+f[rs3]
双精度浮点乘加 <em>(Floating-point Fused Multiply-Add, Double-Precision)</em>. R 4 - type, RV32D and
RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相乘，并将未舍入的积和寄存器f[ <em>rs 3</em> ]中的双精度
浮点数相加，将舍入后的双精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 01 rs2 rs1 rm rd 1000011
</code></pre>
<p>fmadd.s rd, rs1, rs2, rs3 f[rd] = f[rs1]×f[rs2]+f[rs3]
单精度浮点乘加 <em>(Floating-point Fused Multiply-Add, Single-Precision)</em>. R 4 - type, RV32F and
RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相乘，并将未舍入的积和寄存器f[ <em>rs 3</em> ]中的单精度
浮点数相加，将舍入后的单精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 00 rs2 rs1 rm rd 1000011
</code></pre>
<p>fmax.d rd, rs1, rs2 f[rd] = max(f[rs1], f[rs2])
双精度浮点最大值 <em>(Floating-point Maximum, Double-Precision)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数中的较大值写入f[ <em>rd</em> ]中。</p>
<pre><code>0010101 rs2 rs1 001 rd 1010011
</code></pre>
<p>fmax.s rd, rs1, rs2 f[rd] = max(f[rs1], f[rs2])
单精度浮点最大值 <em>(Floating-point Maximum, Single-Precision)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数中的较大值写入f[ <em>rd</em> ]中。</p>
<pre><code>0010100 rs2 rs1 001 rd 1010011
</code></pre>
<p>fmin.d rd, rs1, rs2 f[rd] = min(f[rs1], f[rs2])
双精度浮点最小值 <em>(Floating-point Minimum, Double-Precision)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数中的较小值写入f[ <em>rd</em> ]中。</p>
<pre><code>0010101 rs2 rs1 000 rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fmin.s rd, rs1, rs2 f[rd] = min(f[rs1], f[rs2])
单精度浮点最小值 <em>(Floating-point Minimum, Single-Precision)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数中的较小值写入f[ <em>rd</em> ]中。</p>
<pre><code>0010100 rs2 rs1 000 rd 1010011
</code></pre>
<p>fmsub.d rd, rs1, rs2, rs3 f[rd] = f[rs1]×f[rs2]-f[rs3]
双精度浮点乘减 <em>(Floating-point Fused Multiply-Subtract, Double-Precision)</em>. R 4 - type, RV32D
and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相乘，并将未舍入的积减去寄存器f[ <em>rs 3</em> ]中的双精
度浮点数，将舍入后的双精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 01 rs2 rs1 rm rd 1000111
</code></pre>
<p>fmsub.s rd, rs1, rs2, rs3 f[rd] = f[rs1]×f[rs2]-f[rs3]
单精度浮点乘减 <em>(Floating-point Fused Multiply-Subtarct, Single-Precision)</em>. R 4 - type, RV32F and
RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相乘，并将未舍入的积减去寄存器f[ <em>rs 3</em> ]中的单精
度浮点数，将舍入后的单精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 00 rs2 rs1 rm rd 1000111
</code></pre>
<p>fmul.d rd, rs1, rs2 f[rd] = f[rs1] × f[rs2]
双精度浮点乘 <em>(Floating-point Multiply, Double-Precision)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相乘，将舍入后的双精度结果写入f[ <em>rd</em> ]中。</p>
<pre><code>0001001 rs2 rs1 rm rd 1010011
</code></pre>
<p>fmul.s rd, rs1, rs2 f[rd] = f[rs1] × f[rs2]
单精度浮点乘 <em>(Floating-point Multiply, Single-Precision)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相乘，将舍入后的单精度结果写入f[ <em>rd</em> ]中。</p>
<pre><code>0001000 rs2 rs1 rm rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fmv.d rd, rs1 f[rd] = f[rs1]
双精度浮点移动 <em>(Floating-point Move)</em>. 伪指令(Pesudoinstruction), RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数复制到f[ <em>rd</em> ]中，等同于 <strong>fsgnj.d</strong> rd, rs1, rs1.</p>
<p>fmv.d.x rd, rs1, rs2 f[rd] = x[rs1][63:0]
双精度浮点移动 <em>(Floating-point Move Doubleword from Integer)</em>. R-type, RV 64 D.
把寄存器x[ <em>rs 1</em> ]中的双精度浮点数复制到f[ <em>rd</em> ]中。</p>
<pre><code>1111001 00000 rs1 000 rd 1010011
</code></pre>
<p>fmv.s rd, rs1 f[rd] = f[rs1]
单精度浮点移动 <em>(Floating-point Move)</em>. 伪指令(Pesudoinstruction), RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数复制到f[ <em>rd</em> ]中，等同于 <strong>fsgnj.s</strong> rd, rs1, rs1.</p>
<p>fmv.d.x rd, rs1, rs2 f[rd] = x[rs1][31:0]
单精度浮点移动 <em>(Floating-point Move Word from Integer)</em>. R-type, RV32F and RV64F.
把寄存器x[ <em>rs 1</em> ]中的单精度浮点数复制到f[ <em>rd</em> ]中。</p>
<pre><code>1111000 00000 rs1 000 rd 1010011
</code></pre>
<p>fmv.x.d rd, rs1, rs2 x[rd] = f[rs1][63:0]
双精度浮点移动 <em>(Floating-point Move Doubleword to Integer)</em>. R-type, RV 64 D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数复制到x[ <em>rd</em> ]中。</p>
<pre><code>1110001 00000 rs1 000 rd 1010011
</code></pre>
<p>fmv.x.w rd, rs1, rs2 x[rd] = sext(f[rs1][31:0])
单精度浮点移动 <em>(Floating-point Move Word to Integer)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数复制到x[ <em>rd</em> ]中，对于RV64F，将结果进行符号扩展。</p>
<pre><code>1110000 00000 rs1 000 rd 1010011
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fneg.d rd, rs1 f[rd] = -f[rs1]
双精度浮点取反 <em>(Floating-point Negate)</em>. 伪指令(Pesudoinstruction), RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]中的双精度浮点数取反后写入f[ <em>rd</em> ]中，等同于 <strong>fsgnjn.d</strong> rd, rs1, rs1.</p>
<p>fneg.s rd, rs1 f[rd] = -f[rs1]
单精度浮点取反 <em>(Floating-point Negate)</em>. 伪指令(Pesudoinstruction), RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]中的单精度浮点数取反后写入f[ <em>rd</em> ]中，等同于 <strong>fsgnjn.s</strong> rd, rs1, rs1.</p>
<p>fnmadd.d rd, rs1, rs2, rs3 f[rd] = f[rs1]×f[rs2]+f[rs3]
双精度浮点乘取反加 <em>(Floating-point Fused Negative Multiply-Add, Double-Precision)</em>. R 4 - type,
RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相乘，将结果取反，并将未舍入的积和寄存器f[ <em>rs 3</em> ]
中的双精度浮点数相加，将舍入后的双精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 01 rs2 rs1 rm rd 1001111
</code></pre>
<p>fnmadd.s rd, rs1, rs2, rs3 f[rd] = -f[rs1]_f[rs2]-f[rs3]
单精度浮点乘取反加 <em>(Floating-point Fused Negative Multiply-Add, Single-Precision)</em>. R 4 - type,
RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相乘，将结果取反，并将未舍入的积和寄存器f[ <em>rs 3</em> ]
中的单精度浮点数相加，将舍入后的单精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 00 rs2 rs1 rm rd 1001111
</code></pre>
<p>fnmsub.d rd, rs1, rs2, rs3 f[rd] = -f[rs1]_f[rs2]+f[rs3]
双精度浮点乘取反减 <em>(Floating-point Fused Negative Multiply-Subtract, Double-Precision)</em>. R 4 -
type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相乘，将结果取反，并将未舍入的积减去寄存器
f[ <em>rs 3</em> ]中的双精度浮点数，将舍入后的双精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 01 rs2 rs1 rm rd 1001011
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fnmsub.s rd, rs1, rs2, rs3 f[rd] = -f[rs1]×f[rs2]+f[rs3]
单精度浮点乘取反减 <em>(Floating-point Fused Negative Multiply-Subtract, Single-Precision)</em>. R 4 -
type, RV32F and RV64F.
把寄存器 f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相乘，将结果取反，并将未舍入的积减去寄存器
f[ <em>rs 3</em> ]中的单精度浮点数，将舍入后的单精度浮点数写入f[ <em>rd</em> ]。</p>
<pre><code>rs3 00 rs2 rs1 rm rd 1001011
</code></pre>
<p>frcsr rd x[rd] = CSRs[fcsr]
浮点读控制状态寄存器 <em>(Floating-point Read Control and Status Register)</em>. 伪指令
(Pseudoinstruction), RV32F and RV64F.
把浮点控制状态寄存器的值写入x[ <em>rd</em> ]，等同于 <strong>csrrs</strong> rd, fcsr, x0.</p>
<p>frflags rd x[rd] = CSRs[fflags]</p>
<p>浮点读异常标志 <em>(Floating-point Read Exception Flags)</em>. 伪指令(Pseudoinstruction), RV32F and</p>
<p>RV64F.
把浮点异常标志的值写入x[ <em>rd</em> ]，等同于 <strong>csrrs</strong> rd, fflags, x0.</p>
<p>frrm rd x[rd] = CSRs[frm]
浮点读舍入模式 <em>(Floating-point Read Rounding Mode)</em>. 伪指令(Pseudoinstruction), RV32F and
RV64F.
把浮点舍入模式的值写入x[ <em>rd</em> ]，等同于 <strong>csrrs</strong> rd, frm, x0.</p>
<p>fscsr rd, rs1 t = CSRs[fcsr]; CSRs[fcsr] = x[rs1]; x[rd] = t
浮点换出控制状态寄存器 <em>(Floating-point Swap Control and Status Register)</em>. 伪指令
(Pseudoinstruction), RV32F and RV64F.
把寄存器x[ <em>rs 1</em> ]的值写入浮点控制状态寄存器，并将浮点控制状态寄存器的原值写入x[ <em>rd</em> ]，
等同于 <strong>csrrw</strong> rd, fcsr, rs1。 <em>rd</em> 默认为x0。</p>
<p>fsd rs2, offset(rs1) M[x[rs1] + sext(offset)] = f[rs2][63:0]
双精度浮点存储 <em>(Floating-point Store Doubleword)</em>. S-type, RV32D and RV64D.
将寄存器f[ <em>rs 2</em> ]中的双精度浮点数存入内存地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )中。
压缩形式： <strong>c.fsdsp</strong> rs2, offset; <strong>c.fsd</strong> rs2, offset(rs1)</p>
<pre><code>offset[11:5] rs2 rs1 011 offset[4:0] 0100111
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fsflags rd, rs1 t = CSRs[fflags]; CSRs[fflags] = x[rs1]; x[rd] = t
浮点换出异常标志 <em>(Floating-point Swap Exception Flags)</em>. 伪指令(Pseudoinstruction), RV32F
and RV64F.
把寄存器x[ <em>rs 1</em> ]的值写入浮点异常标志寄存器，并将浮点异常标志寄存器的原值写入x[ <em>rd</em> ]，
等同于 <strong>csrrw</strong> rd, fflags, rs1。 <em>rd</em> 默认为x0。</p>
<p>fsgnj.d rd, rs1, rs2 f[rd] = {f[rs2][63], f[rs1][62:0]}
双精度浮点符号注入 <em>(Floating-point Sign Inject, Double-Precision)</em>. R-type, RV32D and RV64D.
用f[ <em>rs1</em> ]指数和有效数以及f[ <em>rs2</em> ]的符号的符号位，来构造一个新的双精度浮点数，并将其写
入f[ <em>rd</em> ]。</p>
<pre><code>0010001 rs2 rs1 000 rd 1010011
</code></pre>
<p>fsgnj.s rd, rs1, rs2 f[rd] = {f[rs2][31], f[rs1][30:0]}
单精度浮点符号注入 <em>(Floating-point Sign Inject, Single-Precision)</em>. R-type, RV32F and RV64F.
用f[ <em>rs1</em> ]指数和有效数以及f[ <em>rs2</em> ]的符号的符号位，来构造一个新的单精度浮点数，并将其写
入f[ <em>rd</em> ]。</p>
<pre><code>0010000 rs2 rs1 000 rd 1010011
</code></pre>
<p>fsgnjn.d rd, rs1, rs2 f[rd] = {~f[rs2][63], f[rs1][62:0]}
双精度浮点符号取反注入 <em>(Floating-point Sign Inject-Negate, Double-Precision)</em>. R-type, RV32D
and RV64D.
用f[ <em>rs1</em> ]指数和有效数以及f[ <em>rs2</em> ]的符号的符号位取反，来构造一个新的双精度浮点数，并将
其写入f[ <em>rd</em> ]。</p>
<pre><code>0010001 rs2 rs1 001 rd 1010011
</code></pre>
<p>fsgnjn.s rd, rs1, rs2 f[rd] = {~f[rs2][31], f[rs1][30:0]}
单精度浮点符号取反注入 <em>(Floating-point Sign Inject-Negate, Single-Precision)</em>. R-type, RV32F
and RV64F.
用f[ <em>rs1</em> ]指数和有效数以及f[ <em>rs2</em> ]的符号的符号位取反，来构造一个新的单精度浮点数，并将
其写入f[ <em>rd</em> ]。</p>
<pre><code>0010000 rs2 rs1 001 rd 1010011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>fsgnjx.d rd, rs1, rs2 f[rd] = {f[rs1][63] ^ f[rs2][63], f[rs1][62:0]}
双精度浮点符号异或注入 <em>(Floating-point Sign Inject-XOR, Double-Precision)</em>. R-type, RV32D
and RV64D.
用f[ <em>rs1</em> ]指数和有效数以及f[ <em>rs1</em> ]和f[ <em>rs2</em> ]的符号的符号位异或，来构造一个新的双精度浮点
数，并将其写入f[ <em>rd</em> ]。</p>
<pre><code>0010001 rs2 rs1 010 rd 1010011
</code></pre>
<p>fsgnjx.s rd, rs1, rs2 f[rd] = {f[rs1][31] ^ f[rs2][31], f[rs1][30:0]}
单精度浮点符号异或注入 <em>(Floating-point Sign Inject-XOR, Single-Precision)</em>. R-type, RV32F
and RV64F.
用f[ <em>rs1</em> ]指数和有效数以及f[ <em>rs1</em> ]和f[ <em>rs2</em> ]的符号的符号位异或，来构造一个新的单精度浮点
数，并将其写入f[ <em>rd</em> ]。</p>
<pre><code>0010000 rs2 rs1 010 rd 1010011
</code></pre>
<p>fsqrt.d rd, rs1, rs2 f[rd] =√ f[rs1]</p>
<p>双精度浮点平方根 <em>(Floating-point Square Root, Double-Precision)</em>. R-type, RV32D and RV64D.
将f[ <em>rs1</em> ]中的双精度浮点数的平方根舍入和写入f[ <em>rd</em> ]。</p>
<pre><code>0101101 00000 rs1 rm rd 1010011
</code></pre>
<p>fsqrt.s rd, rs1, rs2 f[rd] =√ f[rs1]
单精度浮点平方根 <em>(Floating-point Square Root, Single-Precision)</em>. R-type, RV32F and RV64F.
将f[ <em>rs1</em> ]中的单精度浮点数的平方根舍入和写入f[ <em>rd</em> ]。</p>
<pre><code>0101100 00000 rs1 rm rd 1010011
</code></pre>
<p>fsrm rd, rs1 t = CSRs[frm]; CSRs[frm] = x[rs1]; x[rd] = t
浮点换出舍入模式 <em>(Floating-point Swap Rounding Mode)</em>. 伪指令(Pseudoinstruction), RV32F
and RV64F.
把寄存器x[ <em>rs 1</em> ]的值写入浮点舍入模式寄存器，并将浮点舍入模式寄存器的原值写入x[ <em>rd</em> ]，
等同于 <strong>csrrw</strong> rd, frm, rs1。 <em>rd</em> 默认为x0。</p>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 12 11 7 6 0
</code></pre>
<p>fsub.d rd, rs1, rs2 f[rd] = f[rs1] - f[rs2]
双精度浮点减 <em>(Floating-point Subtract, Double-Precision)</em>. R-type, RV32D and RV64D.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的双精度浮点数相减，并将舍入后的差写入f[ <em>rd</em> ]。</p>
<pre><code>0000101 rs2 rs1 rm rd 1010011
</code></pre>
<p>fsub.s rd, rs1, rs2 f[rd] = f[rs1] - f[rs2]
单精度浮点减 <em>(Floating-point Subtract, Single-Precision)</em>. R-type, RV32F and RV64F.
把寄存器f[ <em>rs 1</em> ]和f[ <em>rs 2</em> ]中的单精度浮点数相减，并将舍入后的差写入f[ <em>rd</em> ]。</p>
<pre><code>0000100 rs2 rs1 rm rd 1010011
</code></pre>
<p>fsw rs2, offset(rs1) M[x[rs1] + sext(offset)] = f[rs2][31:0]
单精度浮点存储 <em>(Floating-point Store Word)</em>. S-type, RV32F and RV64F.
将寄存器f[ <em>rs 2</em> ]中的单精度浮点数存入内存地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )中。
压缩形式： <strong>c.fswsp</strong> rs2, offset; <strong>c.fsw</strong> rs2, offset(rs1)</p>
<pre><code>offset[11:5] rs2 rs1 010 offset[4:0] 0100111
</code></pre>
<p>j offset pc += sext(offset)
跳转 <em>(Jump)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把 <em>pc</em> 设置为当前值加上符号位扩展的 <em>offset</em> ，等同于 <strong>jal</strong> x0, offset.</p>
<p>jal rd, offset x[rd] = pc+4; pc += sext(offset)
跳转并链接 <em>(Jump and Link)</em>. J-type, RV32I and RV64I.
把下一条指令的地址( <em>pc+4</em> )，然后把 <em>pc</em> 设置为当前值加上符号位扩展的 <em>offset</em> 。 <em>rd</em> 默认为x1。
压缩形式： <strong>c.j</strong> offset; <strong>c.jal</strong> offset</p>
<pre><code>offset[20|10:1| 11 |19:12] rd 1101111
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>jalr rd, offset(rs1) t =pc+4; pc=(x[rs1]+sext(offset))&amp;~1; x[rd]=t
跳转并寄存器链接 <em>(Jump and Link Register)</em>. I-type, RV32I and RV64I.
把 <em>pc</em> 设置为x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )，把计算出的地址的最低有效位设为 0 ，并将原 <em>pc+4</em>
的值写入f[ <em>rd</em> ]。 <em>rd</em> 默认为x1。
压缩形式： <strong>c.jr</strong> rs1; <strong>c.jalr</strong> rs1</p>
<pre><code>offset[11:0] rs1 010 rd 1100111
</code></pre>
<p>jr rs1 pc = x[rs1]
寄存器跳转 <em>(Jump Register)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把 <em>pc</em> 设置为x[ <em>rs1</em> ]，等同于 <strong>jalr</strong> x0, 0(rs1)。</p>
<p>la rd, symbol x[rd] = &amp;symbol
地址加载 <em>(Load Address)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
将 <em>symbol</em> 的地址加载到x[ <em>rd</em> ]中。当编译位置无关的代码时，它会被扩展为对全局偏移量表
(Global Offset Table)的加载。对于RV32I，等同于执行 <strong>auipc</strong> rd, offsetHi，然后是 <strong>lw</strong> rd，
offsetLo(rd);对于RV64I，则等同于 <strong>auipc</strong> rd，offsetHi和 <strong>ld</strong> rd, offsetLo(rd)。如果offset过大，
开始的算加载地址的指令会变成两条，先是 <strong>auipc</strong> rd, offsetHi然后是 <strong>addi</strong> rd, rd, offsetLo。</p>
<p>lb rd, offset(rs1) x[rd] = sext(M[x[rs1] + sext(offset)][7:0])
字节加载 <em>(Load Byte)</em>. I-type, RV32I and RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取一个字节，经符号位扩展后写入x[ <em>rd</em> ]。</p>
<pre><code>offset[11:0] rs1 000 rd 0000011
</code></pre>
<p>lbu rd, offset(rs1) x[rd] = M[x[rs1] + sext(offset)][7:0]
无符号字节加载 <em>(Load Byte, Unsigned)</em>. I-type, RV32I and RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取一个字节，经零扩展后写入x[ <em>rd</em> ]。</p>
<pre><code>offset[11:0] rs1 100 rd 0000011
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>ld rd, offset(rs1) x[rd] = M[x[rs1] + sext(offset)][63:0]
双字加载 <em>(Load Doubleword)</em>. I-type, RV32I and RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取八个字节，写入x[ <em>rd</em> ]。
压缩形式： <strong>c.ldsp</strong> rd, offset; <strong>c.ld</strong> rd, offset(rs1)</p>
<pre><code>offset[11:0] rs1 011 rd 0000011
</code></pre>
<p>lh rd, offset(rs1) x[rd] = sext(M[x[rs1] + sext(offset)][15:0])
半字加载 <em>(Load Halfword)</em>. I-type, RV32I and RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取两个字节，经符号位扩展后写入x[ <em>rd</em> ]。</p>
<pre><code>offset[11:0] rs1 001 rd 0000011
</code></pre>
<p>lhu rd, offset(rs1) x[rd] = M[x[rs1] + sext(offset)][15:0]
无符号半字加载 <em>(Load Halfword, Unsigned)</em>. I-type, RV32I and RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取两个字节，经零扩展后写入x[ <em>rd</em> ]。</p>
<pre><code>offset[11:0] rs1 101 rd 0000011
</code></pre>
<p>li rd, immediate x[rd] = immediate
立即数加载 <em>(Load Immediate)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
使用尽可能少的指令将常量加载到x[ <em>rd</em> ]中。在RV32I中，它等同于执行 <strong>lui</strong> 和/或 <strong>addi</strong> ；对
于RV64I，会扩展为这种指令序列 <strong>lui, addi, slli, addi, slli, addi ,slli, addi</strong> 。</p>
<p>lla rd, symbol x[rd] = &amp;symbol
本地地址加载 <em>(Load Local Address)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
将 <em>symbol</em> 的地址加载到x[ <em>rd</em> ]中。等同于执行 <strong>auipc</strong> rd, offsetHi，然后是 <strong>addi</strong> rd, rd, offsetLo。</p>
<p>lr.d rd, (rs1) x[rd] = LoadReserved64(M[x[rs1]])
加载保留双字 <em>(Load-Reserved Doubleword)</em>. R-type, RV64A.
从内存中地址为x[ <em>rs1</em> ]中加载八个字节，写入x[ <em>rd</em> ]，并对这个内存双字注册保留。</p>
<pre><code>00010 aq rl 00000 rs1 011 rd 0101111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 12 11 7 6 0
</code></pre>
<p>lr.w rd, (rs1) x[rd] = LoadReserved32(M[x[rs1]])
加载保留字 <em>(Load-Reserved Word)</em>. R-type, RV32A and RV64A.
从内存中地址为x[ <em>rs1</em> ]中加载四个字节，符号位扩展后写入x[ <em>rd</em> ]，并对这个内存字注册保
留。</p>
<pre><code>00010 aq rl 00000 rs1 010 rd 0101111
</code></pre>
<p>lw rd, offset(rs1) x[rd] = sext(M[x[rs1] + sext(offset)][31:0])
字加载 <em>(Load Word)</em>. I-type, RV32I and RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取四个字节，写入x[ <em>rd</em> ]。对于RV64I，结果要进行符号
位扩展。
压缩形式： <strong>c.lwsp</strong> rd, offset; <strong>c.lw</strong> rd, offset(rs1)</p>
<pre><code>offset[11:0] rs1 010 rd 0000011
</code></pre>
<p>lwu rd, offset(rs1) x[rd] = M[x[rs1] + sext(offset)][31:0]
无符号字加载 <em>(Load Word, Unsigned)</em>. I-type, RV64I.
从地址x[ <em>rs1</em> ] + <em>sign-extend</em> ( <em>offset</em> )读取四个字节，零扩展后写入x[ <em>rd</em> ]。</p>
<pre><code>offset[11:0] rs1 110 rd 0000011
</code></pre>
<p>lui rd, immediate x[rd] = sext(immediate[31:12] &lt;&lt; 12)
高位立即数加载 <em>(Load Upper Immediate)</em>. U-type, RV32I and RV64I.
将符号位扩展的 20 位立即数 <em>immediate</em> 左移 12 位，并将低 12 位置零，写入x[ <em>rd</em> ]中。
压缩形式： <strong>c.lui</strong> rd, imm</p>
<pre><code>immediate[ 3 1: 12 ] rd 0110111
</code></pre>
<p>mret ExceptionReturn(Machine)
机器模式异常返回 <em>(Machine-mode Exception Return)</em>. R-type, RV32I and RV64I特权架构
从机器模式异常处理程序返回。将 <em>pc</em> 设置为CSRs[mepc], 将特权级设置成
CSRs[mstatus].MPP, CSRs[mstatus].MIE置成CSRs[mstatus].MPIE, 并且将
CSRs[mstatus].MPIE为1;并且，如果支持用户模式，则将CSR [mstatus].MPP设置为 0 。</p>
<pre><code>0011000 00010 00000 000 00000 1110011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>mul rd, rs1, rs2 x[rd]=x[rs1]×x[rs2]
乘 <em>(Multiply)</em>. R-type, RV32M and RV64M.
把寄存器x[ <em>rs2</em> ]乘到寄存器x[ <em>rs1</em> ]上，乘积写入x[ <em>rd</em> ]。忽略算术溢出。</p>
<pre><code>0000001 rs2 rs1 000 rd 0110011
</code></pre>
<p>mulh rd, rs1, rs2 x[rd]=(x[rs1] (^) 푠×푠x[rs2])≫푠XLEN
高位乘 <em>(Multiply High)</em>. R-type, RV32M and RV64M.
把寄存器x[ <em>rs2</em> ]乘到寄存器x[ <em>rs1</em> ]上，都视为 2 的补码，将乘积的高位写入x[ <em>rd</em> ]。
0000001 rs2 rs1 001 rd 0110011
mulhsu rd, rs1, rs2 x[rd]=(x[rs1] (^) 푠×푢x[rs2])≫푠XLEN
高位有符号-无符号乘 <em>(Multiply High Signed-Unsigned)</em>. R-type, RV32M and RV64M.
把寄存器x[ <em>rs2</em> ]乘到寄存器x[ <em>rs1</em> ]上，x[ <em>rs1</em> ]为 2 的补码，x[ <em>rs2</em> ]为无符号数，将乘积的高位
写入x[ <em>rd</em> ]。
0000001 rs2 rs1 010 rd 0110011
mulhu rd, rs1, rs2 x[rd]=(x[rs1] (^) 푢×푢x[rs2])≫푢XLEN
高位无符号乘 <em>(Multiply High Unsigned)</em>. R-type, RV32M and RV64M.
把寄存器x[ <em>rs2</em> ]乘到寄存器x[ <em>rs1</em> ]上，x[ <em>rs1</em> ]、x[ <em>rs2</em> ]均为无符号数，将乘积的高位写入x[ <em>rd</em> ]。
0000001 rs2 rs1 011 rd 0110011
mulw rd, rs1, rs2 x[rd]=sext((x[rs1]×x[rs2])[ 31 : 0 ])
乘字 <em>(Multiply Word)</em>. R-type, RV64M only.
把寄存器x[ <em>rs2</em> ]乘到寄存器x[ <em>rs1</em> ]上，乘积截为 32 位，进行有符号扩展后写入x[ <em>rd</em> ]。忽略
算术溢出。
0000001 rs2 rs1 000 rd 0111011
mv rd, rs1 x[rd]=x[rs1]
移动 <em>(Move)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]复制到x[ <em>rd</em> ]中。实际被扩展为 <strong>addi</strong> rd, rs1, 0</p>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>neg rd, rs2 x[rd]=−x[rs2]
取反 <em>(Negate)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把寄存器x[ <em>rs2</em> ]的二进制补码写入x[ <em>rd</em> ]。实际被扩展为 <strong>sub</strong> rd, x0, rs2。</p>
<p>negw rd, rs2 x[rd]=sext((−x[rs2])[ 31 : 0 ])
取非字 <em>(Negate Word)</em>. 伪指令(Pseudoinstruction), RV64I only.
计算寄存器x[ <em>rs2</em> ]对于 2 的补码，结果截为 32 位，进行符号扩展后写入x[ <em>rd</em> ]。实际被扩展
为 <strong>subw</strong> rd, x0, rs2。</p>
<p>nop 푁표푡ℎ푖푛푔
无操作 <em>(No operation)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
将 <em>pc</em> 推进到下一条指令。实际被扩展为 <strong>addi</strong> x0, x0, 0。</p>
<p>not rd, rs1 x[rd]=~x[rs1]
取反 <em>(NOT)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]对于 1 的补码（即按位取反的值）写入x[ <em>rd</em> ]。实际被扩展为 <strong>xori</strong> rd, rs1, - 1 。</p>
<p>or rd, rs1, rs2 x[rd]=x[rs1] | 푥[푟푠 2 ]
取或 <em>(OR)</em>. R-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]和寄存器x[ <em>rs2</em> ]按位取或，结果写入x[ <em>rd</em> ]。
压缩形式： <strong>c.or</strong> rd, rs2</p>
<pre><code>0000000 rs2 rs1 110 rd 0110011
</code></pre>
<p>ori rd, rs1, immediate x[rd]=x[rs1] | sext(immediate)
立即数取或 <em>(OR Immediate)</em>. R-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]和有符号扩展的立即数 <em>immediate</em> 按位取或，结果写入x[ <em>rd</em> ]。
压缩形式： <strong>c.or</strong> rd, rs2</p>
<pre><code>Immediate[11:0] rs2 rs1 110 rd 0010011
</code></pre>
<p>rdcycle rd x[rd]=CSRS[cycle]
读周期计数器 <em>(Read Cycle Counter)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把周期数写入x[ <em>rd</em> ]。实际被扩展为 <strong>csrrs</strong> rd, cycle, x0。</p>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>rdcycleh rd x[rd]=CSRs[cycleh]
读周期计数器高位 <em>(Read Cycle Counte High)</em>. 伪指令(Pseudoinstruction), RV32I only.
把周期数右移 32 位后写入x[ <em>rd</em> ]。实际被扩展为 <strong>csrrs</strong> rd, cycleh, x0。</p>
<p>rdinstret rd x[rd]=CSRs[instret]
读已完成指令计数器 <em>(Read Instruction-Retired Counter)</em>. 伪指令(Pseudoinstruction), RV32I and
RV64I.
把已完成指令数写入x[ <em>rd</em> ]。实际被扩展为 <strong>csrrs</strong> rd, instret, x0。</p>
<p>rdinstreth rd x[rd]=CSRs[instreth]
读已完成指令计数器高位 <em>(Read Instruction-Retired Counter High)</em>. 伪指令(Pseudoinstruction),
RV32I only.
把已完成指令数右移 32 位后写入x[ <em>rd</em> ]。实际被扩展为 <strong>csrrs</strong> rd, instreth, x0。</p>
<p>rdtime rd x[rd]=CSRs[time]
读取时间 <em>(Read Time)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
把当前时间写入x[ <em>rd</em> ]，时间频率与平台相关。实际被扩展为 <strong>csrrs</strong> rd, time, x0。</p>
<p>rdtimeh rd x[rd]=CSRs[timeh]
读取时间高位 <em>(Read Time High)</em>. 伪指令(Pseudoinstruction), RV32I only.
把当前时间右移 32 位后写入x[ <em>rd</em> ]，时间频率与平台相关。实际被扩展为 <strong>csrrs</strong> rd, timeh, x0。</p>
<p>rem rd, rs1, rs2 x[rd]=x[rs1] %푠 x[rs2]
求余数 <em>(Remainder)</em>. R-type, RV32M and RV64M.
x[ <em>rs1</em> ]除以x[ <em>rs2</em> ]，向 0 舍入，都视为 2 的补码，余数写入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 110 rd 0110011
</code></pre>
<p>remu rd, rs1, rs2 x[rd]=x[rs1] %푢 x[rs2]
求无符号数的余数 <em>(Remainder, Unsigned)</em>. R-type, RV32M and RV64M.
x[ <em>rs1</em> ]除以x[ <em>rs2</em> ]，向 0 舍入，都视为无符号数，余数写入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 111 rd 0110011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>remuw rd, rs1, rs2 x[rd]=sext(x[rs1][ 31 : 0 ] %푢 x[rs2][ 31 : 0 ])
求无符号数的余数字 <em>(Remainder Word, Unsigned)</em>. R-type, RV64M only.
x[ <em>rs1</em> ]的低 32 位除以x[ <em>rs2</em> ]的低 32 位，向 0 舍入，都视为无符号数，将余数的有符号扩展
写入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 111 rd 0111011
</code></pre>
<p>remw rd, rs1, rs2 x[rd]=sext(x[rs1][ 31 : 0 ] %푠 x[rs2][ 31 : 0 ])
求余数字 <em>(Remainder Word)</em>. R-type, RV64M only.
x[ <em>rs1</em> ]的低 32 位除以x[ <em>rs2</em> ]的低 32 位，向 0 舍入，都视为 2 的补码，将余数的有符号扩展
写入x[ <em>rd</em> ]。</p>
<pre><code>0000001 rs2 rs1 110 rd 0111011
</code></pre>
<p>ret pc=x[ 1 ]
返回 <em>(Return)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
从子过程返回。实际被扩展为 <strong>jalr</strong> x0, 0(x1)。</p>
<p>sb rs2, offset(rs1) M[x[rs1]+sext(offset)=x[rs2][ 7 : 0 ]
存字节 <em>(Store Byte)</em>. S-type, RV32I and RV64I.
将x[ <em>rs2</em> ]的低位字节存入内存地址x[ <em>rs1</em> ]+ <em>sign-extend(offset)</em> 。</p>
<pre><code>offset[11:5] rs2 rs1 000 offset[4:0] 0100011
</code></pre>
<p>sc.d rd, rs2, (rs1) x[rd]=StoreConditonal64(M[x[rs1],x[rs2])
条件存入双字 <em>(Store-Conditional Doubleword)</em>. R-type, RV64A only.
如果内存地址x[ <em>rs1</em> ]上存在加载保留，将x[ <em>rs2</em> ]寄存器中的 8 字节数存入该地址。如果存入
成功，向寄存器x[ <em>rd</em> ]中存入 0 ，否则存入一个非 0 的错误码。</p>
<pre><code>00011 aq rl rs2 rs1 011 rd 0101111
</code></pre>
<pre><code>31 27 26 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>sc.w rd, rs2, (rs1) x[rd]=StoreConditonal32(M[x[rs1],x[rs2])
条件存入字 <em>(Store-Conditional Word)</em>. R-type, RV32A and RV64A.
内存地址x[ <em>rs1</em> ]上存在加载保留，将x[ <em>rs2</em> ]寄存器中的 4 字节数存入该地址。如果存入成功，
向寄存器x[ <em>rd</em> ]中存入 0 ，否则存入一个非 0 的错误码。</p>
<pre><code>00011 aq rl rs2 rs1 010 rd 0101111
</code></pre>
<p>sd rs2, offset(rs1) M[x[rs1]+sext(offset)=x[rs2][ 63 : 0 ]
存双字 <em>(Store Doubleword)</em>. S-type, RV64I only.
将x[ <em>rs2</em> ]中的 8 字节存入内存地址x[ <em>rs1</em> ]+ <em>sign-extend(offset)</em> 。
压缩形式： <strong>c.sdsp</strong> rs2, offset; <strong>c.sd</strong> rs2, offset(rs1)</p>
<pre><code>offset[11:5] rs2 rs1 011 offset[4:0] 0100011
</code></pre>
<p>seqz rd, rs1 x[rd]=(x[rs1]== 0 )
等于 0 则置位 <em>(Set if Equal to Zero)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
如果x[ <em>rs1</em> ]等于 0 ，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。实际被扩展为 <strong>sltiu</strong> rd, rs1, 1。</p>
<p>sext.w rd, rs1 x[rd]=sext(x[rs1][ 31 : 0 ])
有符号字扩展 <em>(Sign-extend Word)</em>. 伪指令(Pseudoinstruction), RV64I only.
读入x[ <em>rs1</em> ]的低 32 位，有符号扩展，结果写入x[ <em>rd</em> ]。实际被扩展为 <strong>addiw</strong> rd, rs1, 0。</p>
<p>sfence.vma rs1, rs2 Fence(Store,AddressTranslation)
虚拟内存屏障 <em>(Fence Virtual Memory)</em>. R-type, RV32I and RV64I特权指令。
根据后续的虚拟地址翻译对之前的页表存入进行排序。当 <em>rs2</em> = 0 时，所有地址空间的翻译都
会受到影响；否则，仅对x[ <em>rs2</em> ]标识的地址空间的翻译进行排序。当 <em>rs 1</em> =0时，对所选地址
空间中的所有虚拟地址的翻译进行排序；否则，仅对其中包含虚拟地址x[ <em>rs1</em> ]的页面地址翻
译进行排序。</p>
<pre><code>0001001 rs2 rs1 000 00000 1110011
</code></pre>
<p>sgtz rd, rs2 x[rd]=(x[rs1]&gt;푠 0 )
大于 0 则置位 <em>(Set if Greater Than Zero)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
如果x[ <em>rs2</em> ]大于 0 ，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。实际被扩展为 <strong>slt</strong> rd, x0, rs2。</p>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 26 25 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 26 25 20 19 15 14 12 11 7 6 0
</code></pre>
<p>sh rs2, offset(rs1) M[x[rs1]+sext(offset)=x[rs2][ 15 : 0 ]
存半字 <em>(Store Halfword)</em>. S-type, RV32I and RV64I.
将x[ <em>rs2</em> ]的低位 2 个字节存入内存地址x[ <em>rs1</em> ]+ <em>sign-extend(offset)</em> 。</p>
<pre><code>offset[11:5] rs2 rs1 001 offset[4:0] 0100011
</code></pre>
<p>sw rs2, offset(rs1) M[x[rs1]+sext(offset)=x[rs2][ 31 : 0 ]
存字 <em>(Store Word)</em>. S-type, RV32I and RV64I.
将x[ <em>rs2</em> ]的低位 4 个字节存入内存地址x[ <em>rs1</em> ]+ <em>sign-extend(offset)</em> 。
压缩形式： <strong>c.swsp</strong> rs2, offset; <strong>c.sw</strong> rs2, offset(rs1)</p>
<pre><code>offset[11:5] rs2 rs1 010 offset[4:0] 0100011
</code></pre>
<p>sll rd, rs1, rs2 x[rd]=x[rs1]≪x[rs2]
逻辑左移 <em>(Shift Left Logical)</em>. R-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]左移x[ <em>rs2</em> ]位，空出的位置填入 0 ，结果写入x[ <em>rd</em> ]。x[ <em>rs2</em> ]的低 5 位（如果是
RV64I则是低 6 位）代表移动位数，其高位则被忽略。</p>
<pre><code>0000000 rs2 rs1 001 rd 0110011
</code></pre>
<p>slli rd, rs1, shamt x[rd]=x[rs1]≪shamt
立即数逻辑左移 <em>(Shift Left Logical Immediate)</em>. I-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]左移 <em>shamt</em> 位，空出的位置填入 0 ，结果写入x[ <em>rd</em> ]。对于RV32I，仅当 <em>shamt</em> [5]= 0
时，指令才是有效的。
压缩形式： <strong>c.slli</strong> rd, shamt</p>
<pre><code>000000 shamt rs1 001 rd 0010011
</code></pre>
<p>slliw rd, rs1, shamt x[rd]=sext((x[rs1]≪shamt)[ 31 : 0 ])
立即数逻辑左移字 <em>(Shift Left Logical Word Immediate)</em>. I-type, RV64I only.
把寄存器x[ <em>rs1</em> ]左移 <em>shamt</em> 位，空出的位置填入 0 ，结果截为 32 位，进行有符号扩展后写入
x[ <em>rd</em> ]。仅当 <em>shamt</em> [5]= 0 时，指令才是有效的。</p>
<pre><code>000000 shamt rs1 001 rd 0011011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>sllw rd, rs1, rs 2 x[rd]=sext((x[rs1]≪x[rs2][ 4 : 0 ])[ 31 : 0 ])
逻辑左移字 <em>(Shift Left Logical Word)</em>. R-type, RV64I only.
把寄存器x[ <em>rs1</em> ]的低 32 位左移x[ <em>rs2</em> ]位，空出的位置填入 0 ，结果进行有符号扩展后写入
x[ <em>rd</em> ]。x[ <em>rs2</em> ]的低 5 位代表移动位数，其高位则被忽略。</p>
<pre><code>0000000 rs 2 rs1 001 rd 0111011
</code></pre>
<p>slt rd, rs1, rs2 x[rd]=(x[rs1]&lt;푠x[rs2])
小于则置位 <em>(Set if Less Than)</em>. R-type, RV32I and RV64I.
比较x[ <em>rs1</em> ]和x[ <em>rs2</em> ]中的数，如果x[ <em>rs1</em> ]更小，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。</p>
<pre><code>0000000 rs2 rs1 010 rd 0110011
</code></pre>
<p>slti rd, rs1, immediate x[rd]=(x[rs1]&lt;푠sext(immediate))
小于立即数则置位 <em>(Set if Less Than Immediate)</em>. I-type, RV32I and RV64I.
比较x[ <em>rs1</em> ]和有符号扩展的 <em>immediate</em> ，如果x[ <em>rs1</em> ]更小，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。</p>
<pre><code>immediate[11:0] rs1 010 rd 0010011
</code></pre>
<p>sltiu rd, rs1, immediate x[rd]=(x[rs1]&lt;푢sext(immediate))
无符号小于立即数则置位 <em>(Set if Less Than Immediate, Unsigned)</em>. I-type, RV32I and RV64I.
比较x[ <em>rs1</em> ]和有符号扩展的 <em>immediate</em> ，比较时视为无符号数。如果x[ <em>rs1</em> ]更小，向x[ <em>rd</em> ]写入
1 ，否则写入 0 。</p>
<pre><code>immediate[11:0] rs1 011 rd 0010011
</code></pre>
<p>sltu rd, rs1, rs 2 x[rd]=(x[rs1]&lt;푢x[rs2])
无符号小于则置位 <em>(Set if Less Than, Unsigned)</em>. R-type, RV32I and RV64I.
比较x[ <em>rs1</em> ]和x[ <em>rs2</em> ]，比较时视为无符号数。如果x[ <em>rs1</em> ]更小，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。</p>
<pre><code>0000000 rs2 rs1 011 rd 0110011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 26 25 20 19 15 14 12 11 7 6
0
</code></pre>
<pre><code>31 26 25 20 19 15 14 12 11 7 6
0
</code></pre>
<p>sltz rd, rs1 x[rd]=(x[rs1]&lt;푠 0 )
小于 0 则置位 <em>(Set if Less Than to Zero)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
如果x[ <em>rs1</em> ]小于 0 ，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。实际扩展为 <strong>slt</strong> rd, rs1, x0。</p>
<p>snez rd, rs 2 x[rd]=x[rs2]≠ 0 )
不等于 0 则置位 <em>(Set if Not Equal to Zero)</em>. 伪指令(Pseudoinstruction), RV32I and RV64I.
如果x[ <em>rs1</em> ]不等于 0 ，向x[ <em>rd</em> ]写入 1 ，否则写入 0 。实际扩展为 <strong>sltu</strong> rd, x0, rs2。</p>
<p>sra rd, rs1, rs 2 x[rd]=(x[rs1]≫푠x[rs2])
算术右移 <em>(Shift Right Arithmetic)</em>. R-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]右移x[ <em>rs2</em> ]位，空位用x[ <em>rs1</em> ]的最高位填充，结果写入x[ <em>rd</em> ]。x[ <em>rs2</em> ]的低 5 位
（如果是RV64I则是低 6 位）为移动位数，高位则被忽略。</p>
<pre><code>0100000 rs2 rs1 101 rd 0110011
</code></pre>
<p>srai rd, rs1, shamt x[rd]=(x[rs1]≫푠shamt)
立即数算术右移 <em>(Shift Right Arithmetic Immediate)</em>. I-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]右移 <em>shamt</em> 位，空位用x[ <em>rs1</em> ]的最高位填充，结果写入x[ <em>rd</em> ]。对于RV32I，
仅当 <em>shamt</em> [5]=0时指令有效。
压缩形式： <strong>c.srai</strong> rd, shamt</p>
<pre><code>010000 shamt rs1 101 rd 0010011
</code></pre>
<p>sraiw rd, rs1, shamt x[rd]=sext(x[rs1][ 31 : 0 ]≫푠shamt)
立即数算术右移字 <em>(Shift Right Arithmetic Word Immediate)</em>. I-type, RV64I only.
把寄存器x[ <em>rs1</em> ]的低 32 位右移 <em>shamt</em> 位，空位用x[ <em>rs1</em> ][31]填充，结果进行有符号扩展后写
入x[ <em>rd</em> ]。仅当 <em>shamt</em> [5]=0时指令有效。
压缩形式： <strong>c.srai</strong> rd, shamt</p>
<pre><code>010000 shamt rs1 101 rd 0011011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 26 25 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 26 25 20 19 15 14 12 11 7 6 0
</code></pre>
<p>sraw rd, rs1, rs 2 x[rd]=sext(x[rs1][ 31 : 0 ]≫푠x[rs2][ 4 : 0 ])
算术右移字 <em>(Shift Right Arithmetic Word)</em>. R-type, RV64I only.
把寄存器x[ <em>rs1</em> ]的低 32 位右移x[ <em>rs2</em> ]位，空位用x[ <em>rs1</em> ][31]填充，结果进行有符号扩展后写
入x[ <em>rd</em> ]。x[ <em>rs2</em> ]的低 5 位为移动位数，高位则被忽略。</p>
<pre><code>0100000 rs2 rs1 101 rd 0111011
</code></pre>
<p>sret ExceptionReturn(Supervisor)
管理员模式例外返回 <em>(Supervisor-mode Exception Return)</em>. R-type, RV32I and RV64I特权指令。
从管理员模式的例外处理程序中返回，设置 <em>pc</em> 为CSRs[spec]，权限模式为CSRs[sstatus].SPP，
CSRs[sstatus].SIE为CSRs[sstatus].SPIE，CSRs[sstatus].SPIE为 1 ，CSRs[sstatus].spp为 0 。</p>
<pre><code>0001000 00010 00000 000 00000 1110011
</code></pre>
<p>srl rd, rs1, rs2 x[rd]=(x[rs1]≫푢x[rs2])
逻辑右移 <em>(Shift Right Logical)</em>. R-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]右移x[ <em>rs2</em> ]位，空出的位置填入 0 ，结果写入x[ <em>rd</em> ]。x[ <em>rs2</em> ]的低 5 位（如果是
RV64I则是低 6 位）代表移动位数，其高位则被忽略。</p>
<pre><code>0000000 rs2 rs1 101 rd 0110011
</code></pre>
<p>srli rd, rs1, shamt x[rd]=(x[rs1]≫푢shamt)
立即数逻辑右移 <em>(Shift Right Logical Immediate)</em>. I-type, RV32I and RV64I.
把寄存器x[ <em>rs1</em> ]右移 <em>shamt</em> 位，空出的位置填入 0 ，结果写入x[ <em>rd</em> ]。对于RV32I，仅当 <em>shamt</em> [5]= 0
时，指令才是有效的。
压缩形式： <strong>c.srli</strong> rd, shamt</p>
<pre><code>000000 shamt rs1 101 rd 0010011
</code></pre>
<p>srliw rd, rs1, shamt x[rd]=sext(x[rs1][ 31 : 0 ]≫푢shamt)
立即数逻辑右移字 <em>(Shift Right Logical Word Immediate)</em>. I-type, RV64I only.
把寄存器x[ <em>rs1</em> ]右移 <em>shamt</em> 位，空出的位置填入 0 ，结果截为 32 位，进行有符号扩展后写入
x[ <em>rd</em> ]。仅当 <em>shamt</em> [5]= 0 时，指令才是有效的。</p>
<pre><code>000000 shamt rs1 101 rd 0011011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<p>srlw rd, rs1, rs 2 x[rd]=sext(x[rs1][ 31 : 0 ]≫푢x[rs2][ 4 : 0 ])
逻辑右移字 <em>(Shift Right Logical Word)</em>. R-type, RV64I only.
把寄存器x[ <em>rs1</em> ]的低 32 位右移x[ <em>rs2</em> ]位，空出的位置填入 0 ，结果进行有符号扩展后写入
x[ <em>rd</em> ]。x[ <em>rs2</em> ]的低 5 位代表移动位数，其高位则被忽略。</p>
<pre><code>0000000 rs 2 rs1 101 rd 0111011
</code></pre>
<p>sub rd, rs1, rs2 x[rd]=x[rs1]−x[rs2]
减 <em>(Substract)</em>. R-type, RV32I and RV64I.
x[ <em>rs1</em> ]减去x[ <em>rs2</em> ]，结果写入x[ <em>rd</em> ]。忽略算术溢出。
压缩形式： <strong>c.sub</strong> rd, rs2</p>
<pre><code>0100000 rs2 rs1 000 rd 0110011
</code></pre>
<p>subw rd, rs1, rs2 x[rd]=sext((x[rs1]−x[rs2])[ 31 : 0 ])
减去字 <em>(Substract Word)</em>. R-type, RV64I only.
x[ <em>rs1</em> ]减去x[ <em>rs2</em> ]，结果截为 32 位，有符号扩展后写入x[ <em>rd</em> ]。忽略算术溢出。
压缩形式： <strong>c.subw</strong> rd, rs2</p>
<pre><code>0100000 rs2 rs1 000 rd 0111011
</code></pre>
<p>tail symbol pc=&amp;symbol; clobber x[ 6 ]
尾调用 <em>(Tail call)</em>. 伪指令(Pseudoinstuction), RV32I and RV64I.
设置 <em>pc</em> 为 <em>symbol</em> ，同时覆写x[6]。实际扩展为 <strong>auipc</strong> x6, offsetHi和 <strong>jalr</strong> x0, offsetLo(x6)。</p>
<p>wfi while (noInterruptPending) idle
等待中断 <em>(Wait for Interrupt)</em>. R-type, RV32I and RV64I特权指令。
如果没有待处理的中断，则使处理器处于空闲状态。</p>
<pre><code>0001000 00101 00000 000 00000 1110011
</code></pre>
<pre><code>31 25 24 20 19 15 14 12 11 7 6 0
</code></pre>
<pre><code>31 20 19 15 14 12 11 7 6 0
</code></pre>
<p>xor rd, rs1, rs2 x[rd]=x[rs1] ^ x[rs2]
异或 <em>(Exclusive-OR)</em>. R-type, RV32I and RV64I.
x[ <em>rs1</em> ]和x[ <em>rs2</em> ]按位异或，结果写入x[ <em>rd</em> ]。
压缩形式： <strong>c.xor</strong> rd, rs2</p>
<pre><code>0000000 rs2 rs1 100 rd 0110011
</code></pre>
<p>xori rd, rs1, immediate x[rd]=x[rs1] ^ sext(immediate)
立即数异或 <em>(Exclusive-OR Immediate)</em>. I-type, RV32I and RV64I.
x[ <em>rs1</em> ]和有符号扩展的 <em>immediate</em> 按位异或，结果写入x[ <em>rd</em> ]。
压缩形式： <strong>c.xor</strong> rd, rs2</p>
<pre><code>immediate[11:0] rs1 100 rd 0010011
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="daliy/7-7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="daliy/7-7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
